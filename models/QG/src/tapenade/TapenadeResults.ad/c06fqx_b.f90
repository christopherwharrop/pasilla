!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:54
!
!  Differentiation of c06fqx in reverse (adjoint) mode:
!   gradient     of useful results: a b
!   with respect to varying inputs: a b
SUBROUTINE C06FQX_B(a, ab, b, bb, m, n, q, nq, trig)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!
!     Hermitian to Real Fast Fourier Transform Kernel Driver
!
!     Self-sorting, decimation in frequency
!
!     .. Scalar Arguments ..
  INTEGER :: m, n, nq
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:m*n-1), b(0:m*n-1), trig(0:2*n-1)
  DOUBLE PRECISION :: ab(0:m*n-1), bb(0:m*n-1)
  INTEGER :: q(nq)
!     .. Local Scalars ..
  DOUBLE PRECISION :: factor
  INTEGER :: i, p, qi, r
  LOGICAL :: ina
!     .. External Subroutines ..
  EXTERNAL C06FQQ, C06FQR, C06FQS, C06FQT, C06FQU, C06FQV, C06FQW
  EXTERNAL C06FQQ_B, C06FQR_B, C06FQS_B, C06FQT_B, C06FQU_B, C06FQV_B, &
&     C06FQW_B
!     .. Intrinsic Functions ..
  INTRINSIC SQRT, DBLE
  INTEGER :: arg1
  INTEGER :: branch
!     .. Executable Statements ..
  ina = .true.
  p = 1
  r = n
  IF (n .NE. 1) THEN
    DO i=1,nq
      qi = q(i)
      CALL PUSHINTEGER4(r)
      r = r/qi
      IF (ina) THEN
        IF (qi .EQ. 2) THEN
          CALL PUSHINTEGER4(arg1)
          arg1 = m*p
          CALL PUSHCONTROL4B(0)
        ELSE IF (qi .EQ. 3) THEN
          CALL PUSHINTEGER4(arg1)
          arg1 = m*p
          CALL PUSHCONTROL4B(1)
        ELSE IF (qi .EQ. 4) THEN
          CALL PUSHINTEGER4(arg1)
          arg1 = m*p
          CALL PUSHCONTROL4B(2)
        ELSE IF (qi .EQ. 5) THEN
          CALL PUSHINTEGER4(arg1)
          arg1 = m*p
          CALL PUSHCONTROL4B(3)
        ELSE IF (qi .EQ. 6) THEN
          CALL PUSHINTEGER4(arg1)
          arg1 = m*p
          CALL PUSHCONTROL4B(4)
        ELSE
          CALL PUSHINTEGER4(arg1)
          arg1 = m*p
          CALL PUSHCONTROL4B(5)
        END IF
      ELSE IF (qi .EQ. 2) THEN
        CALL PUSHINTEGER4(arg1)
        arg1 = m*p
        CALL PUSHCONTROL4B(6)
      ELSE IF (qi .EQ. 3) THEN
        CALL PUSHINTEGER4(arg1)
        arg1 = m*p
        CALL PUSHCONTROL4B(7)
      ELSE IF (qi .EQ. 4) THEN
        CALL PUSHINTEGER4(arg1)
        arg1 = m*p
        CALL PUSHCONTROL4B(8)
      ELSE IF (qi .EQ. 5) THEN
        CALL PUSHINTEGER4(arg1)
        arg1 = m*p
        CALL PUSHCONTROL4B(9)
      ELSE IF (qi .EQ. 6) THEN
        CALL PUSHINTEGER4(arg1)
        arg1 = m*p
        CALL PUSHCONTROL4B(10)
      ELSE
        CALL PUSHINTEGER4(arg1)
        arg1 = m*p
        CALL PUSHCONTROL4B(11)
      END IF
      ina = .NOT.ina
      CALL PUSHINTEGER4(p)
      p = p*qi
    END DO
!
    factor = 2.0d0/SQRT(DBLE(n))
    IF (ina) THEN
      DO i=m*n-1,0,-1
        ab(i) = factor*ab(i)
      END DO
    ELSE
      DO i=m*n-1,0,-1
        bb(i) = bb(i) + factor*ab(i)
        ab(i) = 0.D0
      END DO
    END IF
    DO i=nq,1,-1
      qi = q(i)
      CALL POPINTEGER4(p)
      CALL POPCONTROL4B(branch)
      IF (branch .LT. 6) THEN
        IF (branch .LT. 3) THEN
          IF (branch .EQ. 0) THEN
            CALL C06FQW_B(a, ab, b, bb, arg1, r, trig((p-1)*qi*r), trig(&
&                   n+(p-1)*qi*r))
            CALL POPINTEGER4(arg1)
          ELSE IF (branch .EQ. 1) THEN
            CALL C06FQV_B(a, ab, b, bb, arg1, r, trig((p-1)*qi*r), trig(&
&                   n+(p-1)*qi*r))
            CALL POPINTEGER4(arg1)
          ELSE
            CALL C06FQU_B(a, ab, b, bb, arg1, r, trig((p-1)*qi*r), trig(&
&                   n+(p-1)*qi*r))
            CALL POPINTEGER4(arg1)
          END IF
        ELSE IF (branch .EQ. 3) THEN
          CALL C06FQT_B(a, ab, b, bb, arg1, r, trig((p-1)*qi*r), trig(n+&
&                 (p-1)*qi*r))
          CALL POPINTEGER4(arg1)
        ELSE IF (branch .EQ. 4) THEN
          CALL C06FQS_B(a, ab, b, bb, arg1, r, trig((p-1)*qi*r), trig(n+&
&                 (p-1)*qi*r))
          CALL POPINTEGER4(arg1)
        ELSE
          CALL C06FQR_B(a, ab, b, bb, arg1, qi, r, trig((p-1)*qi*r), &
&                 trig(n+(p-1)*qi*r))
          CALL POPINTEGER4(arg1)
        END IF
      ELSE IF (branch .LT. 9) THEN
        IF (branch .EQ. 6) THEN
          CALL C06FQW_B(b, bb, a, ab, arg1, r, trig((p-1)*qi*r), trig(n+&
&                 (p-1)*qi*r))
          CALL POPINTEGER4(arg1)
        ELSE IF (branch .EQ. 7) THEN
          CALL C06FQV_B(b, bb, a, ab, arg1, r, trig((p-1)*qi*r), trig(n+&
&                 (p-1)*qi*r))
          CALL POPINTEGER4(arg1)
        ELSE
          CALL C06FQU_B(b, bb, a, ab, arg1, r, trig((p-1)*qi*r), trig(n+&
&                 (p-1)*qi*r))
          CALL POPINTEGER4(arg1)
        END IF
      ELSE IF (branch .EQ. 9) THEN
        CALL C06FQT_B(b, bb, a, ab, arg1, r, trig((p-1)*qi*r), trig(n+(p&
&               -1)*qi*r))
        CALL POPINTEGER4(arg1)
      ELSE IF (branch .EQ. 10) THEN
        CALL C06FQS_B(b, bb, a, ab, arg1, r, trig((p-1)*qi*r), trig(n+(p&
&               -1)*qi*r))
        CALL POPINTEGER4(arg1)
      ELSE
        CALL C06FQR_B(b, bb, a, ab, arg1, qi, r, trig((p-1)*qi*r), trig(&
&               n+(p-1)*qi*r))
        CALL POPINTEGER4(arg1)
      END IF
      CALL POPINTEGER4(r)
    END DO
    CALL C06FQQ_B(a, ab, m, n)
  END IF
END SUBROUTINE C06FQX_B
