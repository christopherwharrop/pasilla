!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:54
!
MODULE TAPENADE_B
  IMPLICIT NONE
! value of pi
  REAL*8, PARAMETER :: pi=4d0*ATAN(1d0)
! The truncation is of type T(riangular) nm
  INTEGER, PARAMETER :: nm=21
! Number of longitude points of the Gaussian grid
  INTEGER, PARAMETER :: nlon=64
! Number of latitude  points of the Gaussian grid
  INTEGER, PARAMETER :: nlat=32
! Number of vorticity levels in the vertical (should be set to 3)
  INTEGER, PARAMETER :: nvl=3
! Number of temperature levels in the vertical (equal to nvl-1)
  INTEGER, PARAMETER :: ntl=2
! Half of nsh2
  INTEGER, PARAMETER :: nsh=(nm+1)*(nm+2)/2
  INTEGER, PARAMETER :: nsh2=2*nsh
! Model time step
  INTEGER, PARAMETER :: time_step=1200
  REAL*8, PARAMETER :: nsteps_per_day=24.0d0*3600.0d0/REAL(time_step)
! dimensionless time step
  REAL*8, PARAMETER :: dtt=1d0/nsteps_per_day*pi*4d0
! Model state
! Stream function at the nvl levels
  REAL*8 :: psi(nsh2, nvl)
  REAL*8 :: psib(nsh2, nvl)
! Thickness at the ntl levels
  REAL*8 :: psit(nsh2, ntl)
  REAL*8 :: psitb(nsh2, ntl)
! Potential vorticity
  REAL*8 :: qprime(nsh2, nvl)
  REAL*8 :: qprimeb(nsh2, nvl)
! Model Forcing
! Constant potential vorticity forcing at the nvl levels
  REAL*8, PARAMETER :: for(nsh2, nvl)
! Spectral Coefficients
! Contains numbers 22 down to 1 for index 0 to 21
  INTEGER, PARAMETER :: nshm(0:nm)
! Contains total wavenumber n of each spherical harmonic of the corresponding index
  INTEGER, PARAMETER :: ll(nsh)
  INTEGER :: lat
! Legendre polynomials defined at Gausian latitudes
  REAL*8, PARAMETER :: pp(lat, nsh)
! Mu derivative of Legendre polynomials
  REAL*8, PARAMETER :: pd(lat, nsh)
! Weights for Legendre integrals
  REAL*8, PARAMETER :: pw(lat, nsh)
! contains zonal wavenumber m of each spherical harmonic of the corresponding index for zonal derivative operator
  REAL*8, PARAMETER :: rm(:)
! Laplace/Helmholtz direct and inverse operators
! Laplace and Helmholtz operator for Q-PSI inversion
  REAL*8, PARAMETER :: rinhel(nsh2, 0:5)
! Dissipation coefficients for each spherical harmonic
  REAL*8, PARAMETER :: diss(nsh2, 2)
!   diss(k,1) : Hyperviscosity at the three levels (tdif sets timescale)
!   diss(k,2) : Ekman friction at lower level (tdis sets timescale)
! One over Rossby rad. of def. squared of 200-500 thickness
  REAL*8, PARAMETER :: rl1
! One over Rossby rad. of def. squared of 500-800 thickness
  REAL*8, PARAMETER :: rl2
! Nondimensional relaxation coefficient of 200-500 thickness
  REAL*8, PARAMETER :: relt1
! Nondimensional relaxation coefficient of 500-800 thickness
  REAL*8, PARAMETER :: relt2
! Orography
! Gauss points in radians
  REAL*8, PARAMETER :: phi(nlat)
! Sine of phi
  REAL*8, PARAMETER :: sinfi(nlat)
! Cosine of phi
  REAL*8, PARAMETER :: cosfi(nlat)
! If .true. then orography and land-sea mask dependent friction at the lower level plus Ekman friction, else only Ekman friction
  LOGICAL, PARAMETER :: lgdiss
! Derivative of orog wrt lambda
  REAL*8, PARAMETER :: dorodl(nlat, nlon)
! Derivative of orag wrt sin(fi)
  REAL*8, PARAMETER :: dorodm(nlat, nlon)
! Landsea-mask/orography dependent friction
  REAL*8, PARAMETER :: rdiss(nlat, nlon)
! Landsea-mask/orography dependent friction
  REAL*8, PARAMETER :: ddisdx(nlat, nlon)
! Landsea-mask/orography dependent friction
  REAL*8, PARAMETER :: ddisdy(nlat, nlon)
! Copy of input gaussian grid field
  REAL*8 :: agg_copy(nlat, nlon)
  REAL*8 :: agg_copyb(nlat, nlon)
! Work space used by the nag version of the fft    
  REAL*8 :: tmp(nlat, nlon)
  REAL*8 :: tmpb(nlat, nlon)

CONTAINS
!  Differentiation of adv_nsteps in reverse (adjoint) mode:
!   gradient     of useful results: qprime
!   with respect to varying inputs: psi tmp qprime psit
!   RW status of diff variables: psi:out agg_copy:(loc) tmp:out
!                qprime:in-out psit:out
!-----------------------------------------------------------------------
! performs a fourth order runge kutta time step at truncation nm
! with time step dt
! dqdt calculates the time derivative
! input  qprime at current time
! output qprime at current time plus dt
!-----------------------------------------------------------------------
  SUBROUTINE ADV_NSTEPS_B(nsteps)
    IMPLICIT NONE
    INTEGER :: nsteps
    INTEGER :: step, k, l, nvar
    REAL*8 :: dt2, dt6
    REAL*8 :: y(nsh2, nvl), dydt(nsh2, nvl), yt(nsh2, nvl)
    REAL*8 :: yb(nsh2, nvl), dydtb(nsh2, nvl), ytb(nsh2, nvl)
    REAL*8 :: dyt(nsh2, nvl), dym(nsh2, nvl)
    REAL*8 :: dytb(nsh2, nvl), dymb(nsh2, nvl)
    REAL*8 :: tempb
    nvar = (nm+2)*nm
    dt2 = dtt*0.5d0
    dt6 = dtt/6d0
! Advance the model forward in time n steps
    y = FMTOFS(qprime)
    CALL PUSHREAL8ARRAY(psit, nsh2*ntl)
    CALL PUSHREAL8ARRAY(qprime, nsh2*nvl)
    CALL PUSHREAL8ARRAY(tmp, nlat*nlon)
    CALL PUSHREAL8ARRAY(psi, nsh2*nvl)
    CALL DQDT(y, dydt)
    DO l=1,nvl
      DO k=1,nvar
        yt(k, l) = y(k, l) + dt2*dydt(k, l)
      END DO
    END DO
    CALL PUSHREAL8ARRAY(psit, nsh2*ntl)
    CALL PUSHREAL8ARRAY(tmp, nlat*nlon)
    CALL PUSHREAL8ARRAY(psi, nsh2*nvl)
    CALL DQDT(yt, dyt)
    DO l=1,nvl
      DO k=1,nvar
        CALL PUSHREAL8(yt(k, l))
        yt(k, l) = y(k, l) + dt2*dyt(k, l)
      END DO
    END DO
    CALL PUSHREAL8ARRAY(psit, nsh2*ntl)
    CALL PUSHREAL8ARRAY(tmp, nlat*nlon)
    CALL PUSHREAL8ARRAY(psi, nsh2*nvl)
    CALL DQDT(yt, dym)
    DO l=1,nvl
      DO k=1,nvar
        CALL PUSHREAL8(yt(k, l))
        yt(k, l) = y(k, l) + dtt*dym(k, l)
        dym(k, l) = dyt(k, l) + dym(k, l)
      END DO
    END DO
    CALL PUSHREAL8ARRAY(psit, nsh2*ntl)
    CALL PUSHREAL8ARRAY(tmp, nlat*nlon)
    CALL PUSHREAL8ARRAY(psi, nsh2*nvl)
    CALL DQDT(yt, dyt)
    DO l=1,nvl
      DO k=1,nvar
        CALL PUSHREAL8(y(k, l))
        y(k, l) = y(k, l) + dt6*(dydt(k, l)+dyt(k, l)+2.*dym(k, l))
      END DO
    END DO
    yb = 0.0_8
    CALL FSTOFM_B(y, yb, nm, qprimeb)
    dymb = 0.0_8
    dytb = 0.0_8
    dydtb = 0.0_8
    DO l=nvl,1,-1
      DO k=nvar,1,-1
        CALL POPREAL8(y(k, l))
        tempb = dt6*yb(k, l)
        dydtb(k, l) = dydtb(k, l) + tempb
        dytb(k, l) = dytb(k, l) + tempb
        dymb(k, l) = dymb(k, l) + 2.*tempb
      END DO
    END DO
    CALL POPREAL8ARRAY(psi, nsh2*nvl)
    CALL POPREAL8ARRAY(tmp, nlat*nlon)
    CALL POPREAL8ARRAY(psit, nsh2*ntl)
    ytb = 0.0_8
    psitb = 0.0_8
    tmpb = 0.0_8
    psib = 0.0_8
    CALL DQDT_B(yt, ytb, dyt, dytb)
    dytb = 0.0_8
    DO l=nvl,1,-1
      DO k=nvar,1,-1
        dytb(k, l) = dytb(k, l) + dymb(k, l)
        CALL POPREAL8(yt(k, l))
        yb(k, l) = yb(k, l) + ytb(k, l)
        dymb(k, l) = dymb(k, l) + dtt*ytb(k, l)
        ytb(k, l) = 0.0_8
      END DO
    END DO
    CALL POPREAL8ARRAY(psi, nsh2*nvl)
    CALL POPREAL8ARRAY(tmp, nlat*nlon)
    CALL POPREAL8ARRAY(psit, nsh2*ntl)
    CALL DQDT_B(yt, ytb, dym, dymb)
    DO l=nvl,1,-1
      DO k=nvar,1,-1
        CALL POPREAL8(yt(k, l))
        yb(k, l) = yb(k, l) + ytb(k, l)
        dytb(k, l) = dytb(k, l) + dt2*ytb(k, l)
        ytb(k, l) = 0.0_8
      END DO
    END DO
    CALL POPREAL8ARRAY(psi, nsh2*nvl)
    CALL POPREAL8ARRAY(tmp, nlat*nlon)
    CALL POPREAL8ARRAY(psit, nsh2*ntl)
    CALL DQDT_B(yt, ytb, dyt, dytb)
    DO l=nvl,1,-1
      DO k=nvar,1,-1
        yb(k, l) = yb(k, l) + ytb(k, l)
        dydtb(k, l) = dydtb(k, l) + dt2*ytb(k, l)
        ytb(k, l) = 0.0_8
      END DO
    END DO
    CALL POPREAL8ARRAY(psi, nsh2*nvl)
    CALL POPREAL8ARRAY(tmp, nlat*nlon)
    CALL POPREAL8ARRAY(qprime, nsh2*nvl)
    CALL POPREAL8ARRAY(psit, nsh2*ntl)
    CALL DQDT_B(y, yb, dydt, dydtb)
    CALL FMTOFS_B(qprime, qprimeb, yb)
  END SUBROUTINE ADV_NSTEPS_B
!-----------------------------------------------------------------------
! performs a fourth order runge kutta time step at truncation nm
! with time step dt
! dqdt calculates the time derivative
! input  qprime at current time
! output qprime at current time plus dt
!-----------------------------------------------------------------------
  SUBROUTINE ADV_NSTEPS(nsteps)
    IMPLICIT NONE
    INTEGER :: nsteps
    INTEGER :: step, k, l, nvar
    REAL*8 :: dt2, dt6
    REAL*8 :: y(nsh2, nvl), dydt(nsh2, nvl), yt(nsh2, nvl)
    REAL*8 :: dyt(nsh2, nvl), dym(nsh2, nvl)
    nvar = (nm+2)*nm
    dt2 = dtt*0.5d0
    dt6 = dtt/6d0
! Advance the model forward in time n steps
    y = FMTOFS(qprime)
    CALL DQDT(y, dydt)
    DO l=1,nvl
      DO k=1,nvar
        yt(k, l) = y(k, l) + dt2*dydt(k, l)
      END DO
    END DO
    CALL DQDT(yt, dyt)
    DO l=1,nvl
      DO k=1,nvar
        yt(k, l) = y(k, l) + dt2*dyt(k, l)
      END DO
    END DO
    CALL DQDT(yt, dym)
    DO l=1,nvl
      DO k=1,nvar
        yt(k, l) = y(k, l) + dtt*dym(k, l)
        dym(k, l) = dyt(k, l) + dym(k, l)
      END DO
    END DO
    CALL DQDT(yt, dyt)
    DO l=1,nvl
      DO k=1,nvar
        y(k, l) = y(k, l) + dt6*(dydt(k, l)+dyt(k, l)+2.*dym(k, l))
      END DO
    END DO
    qprime = FSTOFM(y, nm)
! Make stream function consistent with potential vorticity
    CALL QTOPSI(qprime, psi, psit)
  END SUBROUTINE ADV_NSTEPS
!  Differentiation of dqdt in reverse (adjoint) mode:
!   gradient     of useful results: psi tmp psit y dydt
!   with respect to varying inputs: psi tmp psit y
!-----------------------------------------------------------------------
! computation of time derivative of the potential vorticity field
! input  y potential vorticity in french format
! output dydt time derivative of y in french format
! values of qprime,  psi and psit are changed
!-----------------------------------------------------------------------
  SUBROUTINE DQDT_B(y, yb, dydt, dydtb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    REAL*8 :: yb(:, :)
    REAL*8 :: dydt(:, :)
    REAL*8 :: dydtb(:, :)
! time derivative of qprime
    REAL*8 :: dqprdt(nsh2, nvl)
    REAL*8 :: dqprdtb(nsh2, nvl)
    CALL PUSHREAL8ARRAY(qprime, 506*3)
    qprime = FSTOFM(y, nm)
    CALL PUSHREAL8ARRAY(psit, 506*2)
    CALL PUSHREAL8ARRAY(psi, 506*3)
    CALL QTOPSI(qprime, psi, psit)
! qprime --> psi and psit
! psi, psit, qprime, for, diss --> dqprdt
    CALL PUSHREAL8ARRAY(tmp, nlat*nlon)
    dqprdt = DDT(psi, psit, qprime, for)
    CALL FMTOFS_B(dqprdt, dqprdtb, dydtb)
    CALL POPREAL8ARRAY(tmp, nlat*nlon)
    CALL DDT_B(psi, psib, psit, psitb, qprime, qprimeb, for, dqprdtb)
    CALL POPREAL8ARRAY(psi, 506*3)
    CALL POPREAL8ARRAY(psit, 506*2)
    CALL QTOPSI_B(qprime, qprimeb, psi, psib, psit, psitb)
    CALL POPREAL8ARRAY(qprime, 506*3)
    CALL FSTOFM_B(y, yb, nm, qprimeb)
  END SUBROUTINE DQDT_B
!-----------------------------------------------------------------------
! computation of time derivative of the potential vorticity field
! input  y potential vorticity in french format
! output dydt time derivative of y in french format
! values of qprime,  psi and psit are changed
!-----------------------------------------------------------------------
  SUBROUTINE DQDT(y, dydt)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    REAL*8, INTENT(OUT) :: dydt(:, :)
! time derivative of qprime
    REAL*8 :: dqprdt(nsh2, nvl)
    qprime = FSTOFM(y, nm)
    CALL QTOPSI(qprime, psi, psit)
! qprime --> psi and psit
! psi, psit, qprime, for, diss --> dqprdt
    dqprdt = DDT(psi, psit, qprime, for)
    dydt = FMTOFS(dqprdt)
    RETURN
  END SUBROUTINE DQDT
!  Differentiation of ddt in reverse (adjoint) mode:
!   gradient     of useful results: tmp psi dqprdt psit
!   with respect to varying inputs: tmp psi qprime psit
!----------------------------------------------------------------------
! ddt
!
! computation of time derivative of the potential vorticity fields
!
! input qprime,  psi,  psit
! output dqprdt
!----------------------------------------------------------------------
  SUBROUTINE DDT_B(psi, psib, psit, psitb, qprime, qprimeb, for, dqprdtb&
& )
    IMPLICIT NONE
! stream function at the nvl levels
    REAL*8, INTENT(IN) :: psi(nsh2, nvl)
    REAL*8 :: psib(nsh2, nvl)
! thickness at the ntl levels
    REAL*8, INTENT(IN) :: psit(nsh2, ntl)
    REAL*8 :: psitb(nsh2, ntl)
! potential vorticity
    REAL*8, INTENT(IN) :: qprime(nsh2, nvl)
    REAL*8 :: qprimeb(nsh2, nvl)
! constant potential vorticity forcing at the nvl levels
    REAL*8, INTENT(IN) :: for(nsh2, nvl)
    REAL*8 :: dqprdt(nsh2, nvl)
    REAL*8 :: dqprdtb(nsh2, nvl)
    INTEGER :: k, l, i, j
    REAL*8 :: dum1, dum2
    REAL*8 :: dum1b, dum2b
    REAL*8, DIMENSION(nsh2) :: res
    REAL*8, DIMENSION(nsh2) :: resb
    REAL*8, DIMENSION(nsh2) :: res0
    REAL*8, DIMENSION(nsh2) :: resb0
! advection of potential vorticity at upper level
    CALL PUSHREAL8ARRAY(tmp, nlat*nlon)
    res = JACOB(psi(:, 1), qprime(:, 1))
! advection of potential vorticity at middle level
    CALL PUSHREAL8ARRAY(tmp, nlat*nlon)
    res0 = JACOB(psi(:, 2), qprime(:, 2))
! advection of potential vorticity and dissipation at lower level
    qprimeb = 0.0_8
    DO l=3,1,-1
      DO k=nsh2,1,-1
        qprimeb(k, l) = qprimeb(k, l) + diss(k, 1)*dqprdtb(k, l)
      END DO
    END DO
    DO k=nsh2,1,-1
      dum2b = dqprdtb(k, 2) - dqprdtb(k, 3)
      dum1b = dqprdtb(k, 1) - dqprdtb(k, 2)
      psitb(k, 2) = psitb(k, 2) + relt2*dum2b
      psitb(k, 1) = psitb(k, 1) + relt1*dum1b
    END DO
    CALL JACOBD_B(psi(:, 3), psib(:, 3), qprime(:, 3), qprimeb(:, 3), &
&           dqprdtb(:, 3))
    dqprdtb(:, 3) = 0.0_8
    resb0 = dqprdtb(:, 2)
    dqprdtb(:, 2) = 0.0_8
    CALL POPREAL8ARRAY(tmp, nlat*nlon)
    CALL JACOB_B(psi(:, 2), psib(:, 2), qprime(:, 2), qprimeb(:, 2), &
&          resb0)
    resb = dqprdtb(:, 1)
    CALL POPREAL8ARRAY(tmp, nlat*nlon)
    CALL JACOB_B(psi(:, 1), psib(:, 1), qprime(:, 1), qprimeb(:, 1), &
&          resb)
  END SUBROUTINE DDT_B
!----------------------------------------------------------------------
! ddt
!
! computation of time derivative of the potential vorticity fields
!
! input qprime,  psi,  psit
! output dqprdt
!----------------------------------------------------------------------
  FUNCTION DDT(psi, psit, qprime, for) RESULT (DQPRDT)
    IMPLICIT NONE
! stream function at the nvl levels
    REAL*8, INTENT(IN) :: psi(nsh2, nvl)
! thickness at the ntl levels
    REAL*8, INTENT(IN) :: psit(nsh2, ntl)
! potential vorticity
    REAL*8, INTENT(IN) :: qprime(nsh2, nvl)
! constant potential vorticity forcing at the nvl levels
    REAL*8, INTENT(IN) :: for(nsh2, nvl)
    REAL*8 :: dqprdt(nsh2, nvl)
    INTEGER :: k, l, i, j
    REAL*8 :: dum1, dum2
! advection of potential vorticity at upper level
    dqprdt(:, 1) = JACOB(psi(:, 1), qprime(:, 1))
! advection of potential vorticity at middle level
    dqprdt(:, 2) = JACOB(psi(:, 2), qprime(:, 2))
! advection of potential vorticity and dissipation at lower level
    dqprdt(:, 3) = JACOBD(psi(:, 3), qprime(:, 3))
! relaxation of temperature and forcing
    DO k=1,nsh2
      dum1 = relt1*psit(k, 1)
      dum2 = relt2*psit(k, 2)
      dqprdt(k, 1) = dqprdt(k, 1) + dum1 + for(k, 1)
      dqprdt(k, 2) = dqprdt(k, 2) - dum1 + dum2 + for(k, 2)
      dqprdt(k, 3) = dqprdt(k, 3) - dum2 + for(k, 3)
    END DO
! explicit horizontal diffusion
    DO l=1,3
      DO k=1,nsh2
        dqprdt(k, l) = dqprdt(k, l) + diss(k, 1)*qprime(k, l)
      END DO
    END DO
    RETURN
  END FUNCTION DDT
!  Differentiation of jacob in reverse (adjoint) mode:
!   gradient     of useful results: tmp sjacob psiloc pvor
!   with respect to varying inputs: tmp psiloc pvor
!----------------------------------------------------------------------
! advection of potential vorticity
! input psiloc,  pvor
! output sjacob
!----------------------------------------------------------------------
  SUBROUTINE JACOB_B(psiloc, psilocb, pvor, pvorb, sjacobb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: psiloc(nsh2)
    REAL*8 :: psilocb(nsh2)
    REAL*8, INTENT(IN) :: pvor(nsh2)
    REAL*8 :: pvorb(nsh2)
    REAL*8 :: sjacob(nsh2)
    REAL*8 :: sjacobb(nsh2)
    INTEGER :: i, j, k
    REAL*8 :: vv(nsh2)
    REAL*8 :: vvb(nsh2)
    REAL*8 :: dpsidl(nlat, nlon), dpsidm(nlat, nlon), dvordl(nlat, nlon)
    REAL*8 :: dpsidlb(nlat, nlon), dpsidmb(nlat, nlon), dvordlb(nlat, &
&   nlon)
    REAL*8 :: dvordm(nlat, nlon), gjacob(nlat, nlon), dpsidls(nsh2)
    REAL*8 :: dvordmb(nlat, nlon), gjacobb(nlat, nlon), dpsidlsb(nsh2)
! space derivatives of potential vorticity
    vv = DDL(pvor)
    dvordl = SPTOGG_PP(vv)
    dvordm = SPTOGG_PD(pvor)
! space derivatives of streamfunction
    dpsidls = DDL(psiloc)
    dpsidl = SPTOGG_PP(dpsidls)
    dpsidm = SPTOGG_PD(psiloc)
    dpsidlsb = 0.0_8
    DO k=nsh2,1,-1
      dpsidlsb(k) = dpsidlsb(k) - sjacobb(k)
    END DO
    CALL GGTOSP_B(gjacob, gjacobb, sjacobb)
    dpsidlb = 0.0_8
    dpsidmb = 0.0_8
    dvordlb = 0.0_8
    dvordmb = 0.0_8
    DO j=nlon,1,-1
      DO i=nlat,1,-1
        dpsidmb(i, j) = dpsidmb(i, j) + dvordl(i, j)*gjacobb(i, j)
        dvordlb(i, j) = dvordlb(i, j) + dpsidm(i, j)*gjacobb(i, j)
        dpsidlb(i, j) = dpsidlb(i, j) - dvordm(i, j)*gjacobb(i, j)
        dvordmb(i, j) = dvordmb(i, j) - dpsidl(i, j)*gjacobb(i, j)
        gjacobb(i, j) = 0.0_8
      END DO
    END DO
    CALL SPTOGG_PD_B(psiloc, psilocb, dpsidmb)
    CALL SPTOGG_PP_B(dpsidls, dpsidlsb, dpsidlb)
    CALL DDL_B(psiloc, psilocb, dpsidlsb)
    CALL SPTOGG_PD_B(pvor, pvorb, dvordmb)
    vvb = 0.0_8
    CALL SPTOGG_PP_B(vv, vvb, dvordlb)
    CALL DDL_B(pvor, pvorb, vvb)
  END SUBROUTINE JACOB_B
!----------------------------------------------------------------------
! advection of potential vorticity
! input psiloc,  pvor
! output sjacob
!----------------------------------------------------------------------
  FUNCTION JACOB(psiloc, pvor) RESULT (SJACOB)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: psiloc(nsh2)
    REAL*8, INTENT(IN) :: pvor(nsh2)
    REAL*8 :: sjacob(nsh2)
    INTEGER :: i, j, k
    REAL*8 :: vv(nsh2)
    REAL*8 :: dpsidl(nlat, nlon), dpsidm(nlat, nlon), dvordl(nlat, nlon)
    REAL*8 :: dvordm(nlat, nlon), gjacob(nlat, nlon), dpsidls(nsh2)
! space derivatives of potential vorticity
    vv = DDL(pvor)
    dvordl = SPTOGG_PP(vv)
    dvordm = SPTOGG_PD(pvor)
! space derivatives of streamfunction
    dpsidls = DDL(psiloc)
    dpsidl = SPTOGG_PP(dpsidls)
    dpsidm = SPTOGG_PD(psiloc)
! jacobian term
    DO j=1,nlon
      DO i=1,nlat
        gjacob(i, j) = dpsidm(i, j)*dvordl(i, j) - dpsidl(i, j)*dvordm(i&
&         , j)
      END DO
    END DO
    sjacob = GGTOSP(gjacob)
! planetary vorticity advection
    DO k=1,nsh2
      sjacob(k) = sjacob(k) - dpsidls(k)
    END DO
    RETURN
  END FUNCTION JACOB
!  Differentiation of jacobd in reverse (adjoint) mode:
!   gradient     of useful results: tmp sjacob psiloc pvor
!   with respect to varying inputs: tmp psiloc pvor
!----------------------------------------------------------------------
! advection of potential vorticity and dissipation on gaussian grid
! input psiloc,  pvor
! output sjacob
!----------------------------------------------------------------------
  SUBROUTINE JACOBD_B(psiloc, psilocb, pvor, pvorb, sjacobb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: psiloc(nsh2)
    REAL*8 :: psilocb(nsh2)
    REAL*8, INTENT(IN) :: pvor(nsh2)
    REAL*8 :: pvorb(nsh2)
    REAL*8 :: sjacob(nsh2)
    REAL*8 :: sjacobb(nsh2)
    INTEGER :: i, j, k
    REAL*8 :: dpsidl(nlat, nlon), dpsidm(nlat, nlon), dvordl(nlat, nlon)
    REAL*8 :: dpsidlb(nlat, nlon), dpsidmb(nlat, nlon), dvordlb(nlat, &
&   nlon)
    REAL*8 :: dvordm(nlat, nlon), gjacob(nlat, nlon), vv(nsh2)
    REAL*8 :: dvordmb(nlat, nlon), gjacobb(nlat, nlon), vvb(nsh2)
    REAL*8 :: azeta(nlat, nlon), dpsidls(nsh2)
    REAL*8 :: azetab(nlat, nlon), dpsidlsb(nsh2)
    INTEGER :: branch
! space derivatives of potential vorticity 
    vv = DDL(pvor)
    dvordl = SPTOGG_PP(vv)
    dvordm = SPTOGG_PD(pvor)
! space derivatives of streamfunction
    dpsidls = DDL(psiloc)
    dpsidl = SPTOGG_PP(dpsidls)
    dpsidm = SPTOGG_PD(psiloc)
! dissipation 
    IF (lgdiss) THEN
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    dpsidlsb = 0.0_8
    DO k=nsh2,1,-1
      dpsidlsb(k) = dpsidlsb(k) - sjacobb(k)
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO k=nsh2,1,-1
        psilocb(k) = psilocb(k) + diss(k, 2)*sjacobb(k)
      END DO
      CALL GGTOSP_B(gjacob, gjacobb, sjacobb)
      dpsidlb = 0.0_8
      dpsidmb = 0.0_8
      vvb = 0.0_8
    ELSE
      CALL GGTOSP_B(gjacob, gjacobb, sjacobb)
      dpsidlb = 0.0_8
      dpsidmb = 0.0_8
      azetab = 0.0_8
      DO j=nlon,1,-1
        DO i=nlat,1,-1
          dpsidmb(i, j) = dpsidmb(i, j) - ddisdy(i, j)*gjacobb(i, j)
          azetab(i, j) = azetab(i, j) + rdiss(i, j)*gjacobb(i, j)
          dpsidlb(i, j) = dpsidlb(i, j) - ddisdx(i, j)*gjacobb(i, j)
        END DO
      END DO
      vvb = 0.0_8
      CALL SPTOGG_PP_B(vv, vvb, azetab)
      DO k=nsh2,1,-1
        psilocb(k) = psilocb(k) + diss(k, 2)*vvb(k)
        vvb(k) = 0.0_8
      END DO
    END IF
    dvordlb = 0.0_8
    dvordmb = 0.0_8
    DO j=nlon,1,-1
      DO i=nlat,1,-1
        dpsidmb(i, j) = dpsidmb(i, j) + (sinfi(i)*dorodl(i, j)+dvordl(i&
&         , j))*gjacobb(i, j)
        dvordlb(i, j) = dvordlb(i, j) + dpsidm(i, j)*gjacobb(i, j)
        dpsidlb(i, j) = dpsidlb(i, j) - (sinfi(i)*dorodm(i, j)+dvordm(i&
&         , j))*gjacobb(i, j)
        dvordmb(i, j) = dvordmb(i, j) - dpsidl(i, j)*gjacobb(i, j)
        gjacobb(i, j) = 0.0_8
      END DO
    END DO
    CALL SPTOGG_PD_B(psiloc, psilocb, dpsidmb)
    CALL SPTOGG_PP_B(dpsidls, dpsidlsb, dpsidlb)
    CALL DDL_B(psiloc, psilocb, dpsidlsb)
    CALL SPTOGG_PD_B(pvor, pvorb, dvordmb)
    CALL SPTOGG_PP_B(vv, vvb, dvordlb)
    CALL DDL_B(pvor, pvorb, vvb)
  END SUBROUTINE JACOBD_B
!----------------------------------------------------------------------
! advection of potential vorticity and dissipation on gaussian grid
! input psiloc,  pvor
! output sjacob
!----------------------------------------------------------------------
  FUNCTION JACOBD(psiloc, pvor) RESULT (SJACOB)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: psiloc(nsh2)
    REAL*8, INTENT(IN) :: pvor(nsh2)
    REAL*8 :: sjacob(nsh2)
    INTEGER :: i, j, k
    REAL*8 :: dpsidl(nlat, nlon), dpsidm(nlat, nlon), dvordl(nlat, nlon)
    REAL*8 :: dvordm(nlat, nlon), gjacob(nlat, nlon), vv(nsh2)
    REAL*8 :: azeta(nlat, nlon), dpsidls(nsh2)
! space derivatives of potential vorticity 
    vv = DDL(pvor)
    dvordl = SPTOGG_PP(vv)
    dvordm = SPTOGG_PD(pvor)
! space derivatives of streamfunction
    dpsidls = DDL(psiloc)
    dpsidl = SPTOGG_PP(dpsidls)
    dpsidm = SPTOGG_PD(psiloc)
! jacobian term + orographic forcing
    DO j=1,nlon
      DO i=1,nlat
        gjacob(i, j) = dpsidm(i, j)*(dvordl(i, j)+sinfi(i)*dorodl(i, j))&
&         - dpsidl(i, j)*(dvordm(i, j)+sinfi(i)*dorodm(i, j))
      END DO
    END DO
! dissipation 
    IF (lgdiss) THEN
!   spatially varying dissipation 
      DO k=1,nsh2
        vv(k) = diss(k, 2)*psiloc(k)
      END DO
      azeta = SPTOGG_PP(vv)
      DO j=1,nlon
        DO i=1,nlat
          gjacob(i, j) = gjacob(i, j) - dpsidm(i, j)*ddisdy(i, j) - &
&           dpsidl(i, j)*ddisdx(i, j) + rdiss(i, j)*azeta(i, j)
        END DO
      END DO
      sjacob = GGTOSP(gjacob)
    ELSE
!   uniform dissipation
      sjacob = GGTOSP(gjacob)
      DO k=1,nsh2
        sjacob(k) = sjacob(k) + diss(k, 2)*psiloc(k)
      END DO
    END IF
! planetary vorticity advection
    DO k=1,nsh2
      sjacob(k) = sjacob(k) - dpsidls(k)
    END DO
    RETURN
  END FUNCTION JACOBD
!  Differentiation of qtopsi in reverse (adjoint) mode:
!   gradient     of useful results: psi psit qprime
!   with respect to varying inputs: psi psit qprime
!-----------------------------------------------------------------------
! computation of streamfunction from potential vorticity
! input  qprime which is potential vorticity field
! output psi,  the streamfunction and psit,  the layer thicknesses
!-----------------------------------------------------------------------
  SUBROUTINE QTOPSI_B(qprime, qprimeb, psi, psib, psit, psitb)
    IMPLICIT NONE
! potential vorticity
    REAL*8, INTENT(IN) :: qprime(:, :)
    REAL*8 :: qprimeb(:, :)
! stream function at the nvl levels
    REAL*8 :: psi(:, :)
    REAL*8 :: psib(:, :)
! thickness at the ntl levels
    REAL*8 :: psit(:, :)
    REAL*8 :: psitb(:, :)
    INTEGER :: k
    REAL*8 :: r3
! only used as portable workspace
    REAL*8 :: ws(nsh2)
    REAL*8 :: wsb(nsh2)
    INTRINSIC SIZE
    REAL*8 :: tempb
    REAL*8 :: tempb0
    INTEGER :: ad_to
    INTEGER :: ad_to0
    INTEGER :: ad_to1
    DO k=1,SIZE(psi, 1)
      ws(k) = qprime(k, 1) + qprime(k, 3)
      psi(k, 1) = rinhel(k, 1)*(ws(k)+qprime(k, 2))
      psi(k, 2) = ws(k) - 2.d0*qprime(k, 2)
      psi(k, 3) = qprime(k, 1) - qprime(k, 3)
    END DO
    CALL PUSHINTEGER4(k - 1)
    DO k=1,SIZE(psit, 1)
      psit(k, 1) = rinhel(k, 2)*psi(k, 2) + rinhel(k, 3)*psi(k, 3)
      psit(k, 2) = rinhel(k, 4)*psi(k, 2) + rinhel(k, 5)*psi(k, 3)
    END DO
    CALL PUSHINTEGER4(k - 1)
    r3 = 1./3.
    DO k=1,SIZE(psi, 1)
      psi(k, 2) = r3*(psi(k, 1)-psit(k, 1)+psit(k, 2))
      psi(k, 1) = psi(k, 2) + psit(k, 1)
      psi(k, 3) = psi(k, 2) - psit(k, 2)
    END DO
    CALL PUSHINTEGER4(k - 1)
    CALL POPINTEGER4(ad_to1)
    DO k=ad_to1,1,-1
      psib(k, 2) = psib(k, 2) + psib(k, 3)
      psitb(k, 2) = psitb(k, 2) - psib(k, 3)
      psib(k, 3) = 0.0_8
      psib(k, 2) = psib(k, 2) + psib(k, 1)
      psitb(k, 1) = psitb(k, 1) + psib(k, 1)
      psib(k, 1) = 0.0_8
      tempb0 = r3*psib(k, 2)
      psib(k, 1) = psib(k, 1) + tempb0
      psitb(k, 1) = psitb(k, 1) - tempb0
      psitb(k, 2) = psitb(k, 2) + tempb0
      psib(k, 2) = 0.0_8
    END DO
    CALL POPINTEGER4(ad_to0)
    DO k=ad_to0,1,-1
      psib(k, 2) = psib(k, 2) + rinhel(k, 4)*psitb(k, 2)
      psib(k, 3) = psib(k, 3) + rinhel(k, 5)*psitb(k, 2)
      psitb(k, 2) = 0.0_8
      psib(k, 2) = psib(k, 2) + rinhel(k, 2)*psitb(k, 1)
      psib(k, 3) = psib(k, 3) + rinhel(k, 3)*psitb(k, 1)
      psitb(k, 1) = 0.0_8
    END DO
    wsb = 0.0_8
    CALL POPINTEGER4(ad_to)
    DO k=ad_to,1,-1
      qprimeb(k, 1) = qprimeb(k, 1) + psib(k, 3)
      qprimeb(k, 3) = qprimeb(k, 3) - psib(k, 3)
      psib(k, 3) = 0.0_8
      wsb(k) = wsb(k) + psib(k, 2)
      qprimeb(k, 2) = qprimeb(k, 2) - 2.d0*psib(k, 2)
      psib(k, 2) = 0.0_8
      tempb = rinhel(k, 1)*psib(k, 1)
      wsb(k) = wsb(k) + tempb
      qprimeb(k, 2) = qprimeb(k, 2) + tempb
      psib(k, 1) = 0.0_8
      qprimeb(k, 1) = qprimeb(k, 1) + wsb(k)
      qprimeb(k, 3) = qprimeb(k, 3) + wsb(k)
      wsb(k) = 0.0_8
    END DO
  END SUBROUTINE QTOPSI_B
!-----------------------------------------------------------------------
! computation of streamfunction from potential vorticity
! input  qprime which is potential vorticity field
! output psi,  the streamfunction and psit,  the layer thicknesses
!-----------------------------------------------------------------------
  SUBROUTINE QTOPSI(qprime, psi, psit)
    IMPLICIT NONE
! potential vorticity
    REAL*8, INTENT(IN) :: qprime(:, :)
! stream function at the nvl levels
    REAL*8, INTENT(OUT) :: psi(:, :)
! thickness at the ntl levels
    REAL*8, INTENT(OUT) :: psit(:, :)
    INTEGER :: k
    REAL*8 :: r3
! only used as portable workspace
    REAL*8 :: ws(nsh2)
    INTRINSIC SIZE
    DO k=1,SIZE(psi, 1)
      ws(k) = qprime(k, 1) + qprime(k, 3)
      psi(k, 1) = rinhel(k, 1)*(ws(k)+qprime(k, 2))
      psi(k, 2) = ws(k) - 2.d0*qprime(k, 2)
      psi(k, 3) = qprime(k, 1) - qprime(k, 3)
    END DO
    DO k=1,SIZE(psit, 1)
      psit(k, 1) = rinhel(k, 2)*psi(k, 2) + rinhel(k, 3)*psi(k, 3)
      psit(k, 2) = rinhel(k, 4)*psi(k, 2) + rinhel(k, 5)*psi(k, 3)
    END DO
    r3 = 1./3.
    DO k=1,SIZE(psi, 1)
      psi(k, 2) = r3*(psi(k, 1)-psit(k, 1)+psit(k, 2))
      psi(k, 1) = psi(k, 2) + psit(k, 1)
      psi(k, 3) = psi(k, 2) - psit(k, 2)
    END DO
    RETURN
  END SUBROUTINE QTOPSI
!-----------------------------------------------------------------------
! computation of potential vorticity from stream function
! input psi streamfunction
! output qprime,  the potential vorticity and psit,  the layer thick.
!-----------------------------------------------------------------------
  SUBROUTINE PSITOQ(psi, psit, qprime)
    IMPLICIT NONE
! stream function at the nvl levels
    REAL*8, INTENT(IN) :: psi(:, :)
! thickness at the ntl levels
    REAL*8, INTENT(OUT) :: psit(:, :)
! potential vorticity
    REAL*8, INTENT(OUT) :: qprime(:, :)
    INTEGER :: k
    INTRINSIC SIZE
    DO k=1,SIZE(psit, 1)
      psit(k, 1) = psi(k, 1) - psi(k, 2)
      psit(k, 2) = psi(k, 2) - psi(k, 3)
      qprime(k, 1) = rinhel(k, 0)*psi(k, 1) - rl1*psit(k, 1)
      qprime(k, 2) = rinhel(k, 0)*psi(k, 2) + rl1*psit(k, 1) - rl2*psit(&
&       k, 2)
      qprime(k, 3) = rinhel(k, 0)*psi(k, 3) + rl2*psit(k, 2)
    END DO
    RETURN
  END SUBROUTINE PSITOQ
!  Differentiation of fmtofs in reverse (adjoint) mode:
!   gradient     of useful results: z
!   with respect to varying inputs: y
!-----------------------------------------------------------------------
! transforms francos format to the french format for global fields
! input  y spectral coefficients in francos format
! output z spectral coefficients in french format
! fm format:
! k       m  n
! 1       0  0
! 2       0  1
! 3       0  2
! :       :  :
! nm+1    0  nm
! nm+2    1  1 --> real part
! nm+3    1  2 --> real part
! :       :  :
! nm+nm+1 1  nm --> real part
! :       :  :
! :       nm nm --> real part
!  repeat for imaginary part
!  disadvantage: 0 0 mode and imaginary parts of m = 0 modes are obsolete
! fs format stores all m for every n first and has no obsolete indices
! 
! k       m  n
! 1       0  1
! 2       1  1 --> real part
! 3       1  1 --> imaginary part: k = 1-3 is T1 truncation
! 4       0  2
! 5       1  2 --> real part
! 6       1  2 --> imaginary part
! 7       2  2 --> real part
! 8       2  2 --> imaginary part: k = 1-8 is T2 truncation
! etcetera
!-----------------------------------------------------------------------
  SUBROUTINE FMTOFS_B(y, yb, zb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    REAL*8 :: yb(:, :)
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: z
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: zb
    INTEGER :: m, n, k, indx, l
    INTRINSIC SIZE
    INTRINSIC MAX
    INTEGER :: max1
    INTEGER :: branch
    INTEGER :: ad_from
    INTEGER :: ad_to
    DO l=1,SIZE(y, 2)
      CALL PUSHINTEGER4(k)
      k = 1
      DO m=0,nm
        IF (m .LT. 1) THEN
          max1 = 1
        ELSE
          max1 = m
        END IF
        ad_from = max1
        DO n=ad_from,nm
          CALL PUSHINTEGER4(k)
          k = k + 1
          IF (m .EQ. 0) THEN
            CALL PUSHINTEGER4(indx)
            indx = n**2
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHINTEGER4(indx)
            indx = n**2 + 2*m - 1
            CALL PUSHCONTROL1B(1)
          END IF
          IF (m .NE. 0) THEN
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
        END DO
        CALL PUSHINTEGER4(ad_from)
      END DO
    END DO
    CALL PUSHINTEGER4(l - 1)
    yb = 0.0_8
    CALL POPINTEGER4(ad_to)
    DO l=ad_to,1,-1
      DO m=nm,0,-1
        CALL POPINTEGER4(ad_from)
        DO n=nm,ad_from,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            yb(k+nsh, l) = yb(k+nsh, l) + zb(indx+1, l)
            zb(indx+1, l) = 0.0_8
          END IF
          yb(k, l) = yb(k, l) + zb(indx, l)
          zb(indx, l) = 0.0_8
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPINTEGER4(indx)
          ELSE
            CALL POPINTEGER4(indx)
          END IF
          CALL POPINTEGER4(k)
        END DO
      END DO
      CALL POPINTEGER4(k)
    END DO
  END SUBROUTINE FMTOFS_B
!-----------------------------------------------------------------------
! transforms francos format to the french format for global fields
! input  y spectral coefficients in francos format
! output z spectral coefficients in french format
! fm format:
! k       m  n
! 1       0  0
! 2       0  1
! 3       0  2
! :       :  :
! nm+1    0  nm
! nm+2    1  1 --> real part
! nm+3    1  2 --> real part
! :       :  :
! nm+nm+1 1  nm --> real part
! :       :  :
! :       nm nm --> real part
!  repeat for imaginary part
!  disadvantage: 0 0 mode and imaginary parts of m = 0 modes are obsolete
! fs format stores all m for every n first and has no obsolete indices
! 
! k       m  n
! 1       0  1
! 2       1  1 --> real part
! 3       1  1 --> imaginary part: k = 1-3 is T1 truncation
! 4       0  2
! 5       1  2 --> real part
! 6       1  2 --> imaginary part
! 7       2  2 --> real part
! 8       2  2 --> imaginary part: k = 1-8 is T2 truncation
! etcetera
!-----------------------------------------------------------------------
  FUNCTION FMTOFS(y) RESULT (Z)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: z
    INTEGER :: m, n, k, indx, l
    INTRINSIC SIZE
    INTRINSIC MAX
    INTEGER :: max1
    DO l=1,SIZE(y, 2)
      k = 1
      DO m=0,nm
        IF (m .LT. 1) THEN
          max1 = 1
        ELSE
          max1 = m
        END IF
        DO n=max1,nm
          k = k + 1
          IF (m .EQ. 0) THEN
            indx = n**2
          ELSE
            indx = n**2 + 2*m - 1
          END IF
          z(indx, l) = y(k, l)
          IF (m .NE. 0) z(indx+1, l) = y(k+nsh, l)
        END DO
      END DO
    END DO
    RETURN
  END FUNCTION FMTOFS
!  Differentiation of fstofm in reverse (adjoint) mode:
!   gradient     of useful results: y z
!   with respect to varying inputs: y
!-----------------------------------------------------------------------
! transforms the french format to francos format for global fields
! input  y spectral coef. in french format,  ntr is truncation limit
! output z spectral coefficients in francos format
! fm format:
! k       m  n
! 1       0  0
! 2       0  1
! 3       0  2
! :       :  :
! nm+1    0  nm
! nm+2    1  1 --> real part
! nm+3    1  2 --> real part
! :       :  :
! nm+nm+1 1  nm --> real part
! :       :  :
! :       nm nm --> real part
!  repeat for imaginary part
!  disadvantage: 0 0 mode and imaginary parts of m = 0 modes are obsolete
! fs format stores all m for every n first and has no obsolete indices
! 
! k       m  n
! 1       0  1
! 2       1  1 --> real part
! 3       1  1 --> imaginary part: k = 1-3 is T1 truncation
! 4       0  2
! 5       1  2 --> real part
! 6       1  2 --> imaginary part
! 7       2  2 --> real part
! 8       2  2 --> imaginary part: k = 1-8 is T2 truncation
! etcetera
!-----------------------------------------------------------------------
  SUBROUTINE FSTOFM_B(y, yb, ntr, zb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    REAL*8 :: yb(:, :)
    INTEGER, INTENT(IN) :: ntr
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: z
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: zb
    INTEGER :: m, n, k, indx, i, l
    INTRINSIC SIZE
    INTRINSIC MAX
    INTEGER :: max1
    INTEGER :: ad_to
    INTEGER :: branch
    INTEGER :: ad_from
    INTEGER :: ad_to0
    DO l=1,SIZE(y, 2)
      DO i=1,SIZE(y, 1)

      END DO
      CALL PUSHINTEGER4(i - 1)
      CALL PUSHINTEGER4(k)
      k = 1
      DO m=0,nm
        IF (m .LT. 1) THEN
          max1 = 1
        ELSE
          max1 = m
        END IF
        ad_from = max1
        DO n=ad_from,nm
          CALL PUSHINTEGER4(k)
          k = k + 1
          IF (m .LE. ntr .AND. n .LE. ntr) THEN
            IF (m .EQ. 0) THEN
              CALL PUSHINTEGER4(indx)
              indx = n**2
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHINTEGER4(indx)
              indx = n**2 + 2*m - 1
              CALL PUSHCONTROL1B(1)
            END IF
            IF (m .NE. 0) THEN
              CALL PUSHCONTROL2B(0)
            ELSE
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            CALL PUSHCONTROL2B(2)
          END IF
        END DO
        CALL PUSHINTEGER4(ad_from)
      END DO
    END DO
    CALL PUSHINTEGER4(l - 1)
    CALL POPINTEGER4(ad_to0)
    DO l=ad_to0,1,-1
      DO m=nm,0,-1
        CALL POPINTEGER4(ad_from)
        DO n=nm,ad_from,-1
          CALL POPCONTROL2B(branch)
          IF (branch .EQ. 0) THEN
            yb(indx+1, l) = yb(indx+1, l) + zb(k+nsh, l)
            zb(k+nsh, l) = 0.0_8
          ELSE IF (branch .NE. 1) THEN
            GOTO 100
          END IF
          yb(indx, l) = yb(indx, l) + zb(k, l)
          zb(k, l) = 0.0_8
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPINTEGER4(indx)
          ELSE
            CALL POPINTEGER4(indx)
          END IF
 100      CALL POPINTEGER4(k)
        END DO
      END DO
      CALL POPINTEGER4(k)
      CALL POPINTEGER4(ad_to)
      DO i=ad_to,1,-1
        zb(i, l) = 0.0_8
      END DO
    END DO
  END SUBROUTINE FSTOFM_B
!-----------------------------------------------------------------------
! transforms the french format to francos format for global fields
! input  y spectral coef. in french format,  ntr is truncation limit
! output z spectral coefficients in francos format
! fm format:
! k       m  n
! 1       0  0
! 2       0  1
! 3       0  2
! :       :  :
! nm+1    0  nm
! nm+2    1  1 --> real part
! nm+3    1  2 --> real part
! :       :  :
! nm+nm+1 1  nm --> real part
! :       :  :
! :       nm nm --> real part
!  repeat for imaginary part
!  disadvantage: 0 0 mode and imaginary parts of m = 0 modes are obsolete
! fs format stores all m for every n first and has no obsolete indices
! 
! k       m  n
! 1       0  1
! 2       1  1 --> real part
! 3       1  1 --> imaginary part: k = 1-3 is T1 truncation
! 4       0  2
! 5       1  2 --> real part
! 6       1  2 --> imaginary part
! 7       2  2 --> real part
! 8       2  2 --> imaginary part: k = 1-8 is T2 truncation
! etcetera
!-----------------------------------------------------------------------
  FUNCTION FSTOFM(y, ntr) RESULT (Z)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    INTEGER, INTENT(IN) :: ntr
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: z
    INTEGER :: m, n, k, indx, i, l
    INTRINSIC SIZE
    INTRINSIC MAX
    INTEGER :: max1
    DO l=1,SIZE(y, 2)
      DO i=1,SIZE(y, 1)
        z(i, l) = 0d0
      END DO
      k = 1
      DO m=0,nm
        IF (m .LT. 1) THEN
          max1 = 1
        ELSE
          max1 = m
        END IF
        DO n=max1,nm
          k = k + 1
          IF (m .LE. ntr .AND. n .LE. ntr) THEN
            IF (m .EQ. 0) THEN
              indx = n**2
            ELSE
              indx = n**2 + 2*m - 1
            END IF
            z(k, l) = y(indx, l)
            IF (m .NE. 0) z(k+nsh, l) = y(indx+1, l)
          END IF
        END DO
      END DO
    END DO
    RETURN
  END FUNCTION FSTOFM
!  Differentiation of sptogg_pp in reverse (adjoint) mode:
!   gradient     of useful results: tmp agg as
!   with respect to varying inputs: tmp as
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid using
! legendre polynomials
!
! input  spectral field as
! output gaussian grid agg
!-----------------------------------------------------------------------
  SUBROUTINE SPTOGG_PP_B(as, asb, aggb)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: as(nsh, 2)
    REAL*8 :: asb(nsh, 2)
! Return value
    REAL*8 :: agg(nlat, nlon)
    REAL*8 :: aggb(nlat, nlon)
    CALL SPTOGG_B(as, asb, pp, aggb)
  END SUBROUTINE SPTOGG_PP_B
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid using
! legendre polynomials
!
! input  spectral field as
! output gaussian grid agg
!-----------------------------------------------------------------------
  FUNCTION SPTOGG_PP(as) RESULT (AGG)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: as(nsh, 2)
! Return value
    REAL*8 :: agg(nlat, nlon)
    agg = SPTOGG(as, pp)
  END FUNCTION SPTOGG_PP
!  Differentiation of sptogg_pd in reverse (adjoint) mode:
!   gradient     of useful results: tmp agg as
!   with respect to varying inputs: tmp as
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid using
! derivatives with respect to sin(fi) .
!
! input  spectral field as
! output gaussian grid agg
!-----------------------------------------------------------------------
  SUBROUTINE SPTOGG_PD_B(as, asb, aggb)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: as(nsh, 2)
    REAL*8 :: asb(nsh, 2)
! Return value
    REAL*8 :: agg(nlat, nlon)
    REAL*8 :: aggb(nlat, nlon)
    CALL SPTOGG_B(as, asb, pd, aggb)
  END SUBROUTINE SPTOGG_PD_B
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid using
! derivatives with respect to sin(fi) .
!
! input  spectral field as
! output gaussian grid agg
!-----------------------------------------------------------------------
  FUNCTION SPTOGG_PD(as) RESULT (AGG)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: as(nsh, 2)
! Return value
    REAL*8 :: agg(nlat, nlon)
    agg = SPTOGG(as, pd)
  END FUNCTION SPTOGG_PD
!  Differentiation of sptogg in reverse (adjoint) mode:
!   gradient     of useful results: tmp agg as
!   with respect to varying inputs: tmp as
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid
! input  spectral field as,  legendre polynomials pploc (pp or pd) 
!        where pp are legendre polynomials and pd derivatives with
!        respect to sin(fi)
! output gaussian grid agg
!-----------------------------------------------------------------------
  SUBROUTINE SPTOGG_B(as, asb, pploc, aggb)
    IMPLICIT NONE
! Input 
    REAL*8, INTENT(IN) :: as(:, :)
    REAL*8 :: asb(:, :)
    REAL*8, INTENT(IN) :: pploc(:, :)
! Return value
    REAL*8 :: agg(nlat, nlon)
    REAL*8 :: aggb(nlat, nlon)
! Local data
!    real*8, allocatable :: tmp(:,:)   ! Work space used by the nag version of the fft    
    INTEGER :: i, j, k, k1, k2, m, mi, mr, nlon1
    INTEGER :: ifail
    REAL :: trigi
    INTEGER :: ad_to
    INTEGER :: ad_from
    INTEGER :: ad_to0
    nlon1 = nlon + 1
    k2 = nshm(0)
    k = k2 + 1
    CALL PUSHINTEGER4(k - 1)
    DO m=1,nm
      CALL PUSHINTEGER4(mr)
      mr = m + 1
      CALL PUSHINTEGER4(mi)
      mi = nlon1 - m
      k1 = k2 + 1
      k2 = k2 + nshm(m)
      ad_from = k1
      k = k2 + 1
      CALL PUSHINTEGER4(k - 1)
      CALL PUSHINTEGER4(ad_from)
    END DO
    CALL C06FQF_B(nlat, nlon, agg, aggb, 'r', trigi, tmp, tmpb, ifail)
    DO m=nm,1,-1
      CALL POPINTEGER4(ad_from)
      CALL POPINTEGER4(ad_to0)
      DO k=ad_to0,ad_from,-1
        DO i=nlat,1,-1
          asb(k, 2) = asb(k, 2) - pploc(i, k)*aggb(i, mi)
        END DO
        DO i=nlat,1,-1
          asb(k, 1) = asb(k, 1) + pploc(i, k)*aggb(i, mr)
        END DO
      END DO
      CALL POPINTEGER4(mi)
      CALL POPINTEGER4(mr)
    END DO
    CALL POPINTEGER4(ad_to)
    DO k=ad_to,1,-1
      DO i=nlat,1,-1
        asb(k, 1) = asb(k, 1) + pploc(i, k)*aggb(i, 1)
      END DO
    END DO
  END SUBROUTINE SPTOGG_B
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid
! input  spectral field as,  legendre polynomials pploc (pp or pd) 
!        where pp are legendre polynomials and pd derivatives with
!        respect to sin(fi)
! output gaussian grid agg
!-----------------------------------------------------------------------
  FUNCTION SPTOGG(as, pploc) RESULT (AGG)
    IMPLICIT NONE
! Input 
    REAL*8, INTENT(IN) :: as(:, :)
    REAL*8, INTENT(IN) :: pploc(:, :)
! Return value
    REAL*8 :: agg(nlat, nlon)
! Local data
!    real*8, allocatable :: tmp(:,:)   ! Work space used by the nag version of the fft    
    INTEGER :: i, j, k, k1, k2, m, mi, mr, nlon1
    INTEGER :: ifail
    REAL :: trigi
! inverse legendre transform
    DO j=1,nlon
      DO i=1,nlat
        agg(i, j) = 0.0d0
      END DO
    END DO
    nlon1 = nlon + 1
    k2 = nshm(0)
    DO k=1,k2
      DO i=1,nlat
        agg(i, 1) = agg(i, 1) + as(k, 1)*pploc(i, k)
      END DO
    END DO
    DO m=1,nm
      mr = m + 1
      mi = nlon1 - m
      k1 = k2 + 1
      k2 = k2 + nshm(m)
      DO k=k1,k2
        DO i=1,nlat
          agg(i, mr) = agg(i, mr) + as(k, 1)*pploc(i, k)
        END DO
        DO i=1,nlat
          agg(i, mi) = agg(i, mi) - as(k, 2)*pploc(i, k)
        END DO
      END DO
    END DO
! inverse fourier transform
    ifail = 0
!   allocate(tmp(nlat,nlon))
    CALL C06FQF(nlat, nlon, agg, 'r', trigi, tmp, ifail)
  END FUNCTION SPTOGG
!  Differentiation of ggtosp in reverse (adjoint) mode:
!   gradient     of useful results: tmp as
!   with respect to varying inputs: tmp agg
!-----------------------------------------------------------------------
! conversion from gaussian grid (agg) to spectral coefficients (as)
! input gaussian grid field agg
! output as contains spectral coefficients
!-----------------------------------------------------------------------
  SUBROUTINE GGTOSP_B(agg, aggb, asb)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: agg(:, :)
    REAL*8 :: aggb(:, :)
! Return value
    REAL*8 :: as(nsh, 2)
    REAL*8 :: asb(nsh, 2)
! Local data
    INTEGER :: i, k, k1, k2, m, mi, mr, nlon1
    INTEGER :: ifail
    REAL :: trigd
! Make a local copy of agg so it is not destroyed by c06fpf
!    allocate(agg_copy(nlat,nlon))
! fourier transform
!    allocate(tmp(nlat,nlon))
    INTEGER :: ad_to
    INTEGER :: ad_from
    INTEGER :: ad_to0
    nlon1 = nlon + 1
    k2 = nshm(0)
    k = k2 + 1
    CALL PUSHINTEGER4(k - 1)
    DO m=1,nm
      CALL PUSHINTEGER4(mr)
      mr = m + 1
      CALL PUSHINTEGER4(mi)
      mi = nlon1 - m
      k1 = k2 + 1
      k2 = k2 + nshm(m)
      ad_from = k1
      k = k2 + 1
      CALL PUSHINTEGER4(k - 1)
      CALL PUSHINTEGER4(ad_from)
    END DO
    agg_copyb = 0.0_8
    DO m=nm,1,-1
      CALL POPINTEGER4(ad_from)
      CALL POPINTEGER4(ad_to0)
      DO k=ad_to0,ad_from,-1
        DO i=nlat,1,-1
          agg_copyb(i, mi) = agg_copyb(i, mi) + pw(i, k)*asb(k, 2)
          agg_copyb(i, mr) = agg_copyb(i, mr) + pw(i, k)*asb(k, 1)
        END DO
      END DO
      CALL POPINTEGER4(mi)
      CALL POPINTEGER4(mr)
    END DO
    CALL POPINTEGER4(ad_to)
    DO k=ad_to,1,-1
      DO i=nlat,1,-1
        agg_copyb(i, 1) = agg_copyb(i, 1) + pw(i, k)*asb(k, 1)
      END DO
    END DO
    CALL C06FPF_B(nlat, nlon, agg_copy, agg_copyb, 'r', trigd, tmp, tmpb&
&           , ifail)
    aggb = 0.0_8
    aggb(:, :) = agg_copyb(:, :)
  END SUBROUTINE GGTOSP_B
!-----------------------------------------------------------------------
! conversion from gaussian grid (agg) to spectral coefficients (as)
! input gaussian grid field agg
! output as contains spectral coefficients
!-----------------------------------------------------------------------
  FUNCTION GGTOSP(agg) RESULT (AS)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: agg(:, :)
! Return value
    REAL*8 :: as(nsh, 2)
! Local data
    INTEGER :: i, k, k1, k2, m, mi, mr, nlon1
    INTEGER :: ifail
    REAL :: trigd
! Make a local copy of agg so it is not destroyed by c06fpf
!    allocate(agg_copy(nlat,nlon))
    agg_copy(:, :) = agg(:, :)
! fourier transform
    ifail = 0
!    allocate(tmp(nlat,nlon))
    CALL C06FPF(nlat, nlon, agg_copy, 'r', trigd, tmp, ifail)
! legendre transform
    DO i=1,2
      DO k=1,nsh
        as(k, i) = 0.0d0
      END DO
    END DO
    nlon1 = nlon + 1
    k2 = nshm(0)
    DO k=1,k2
      DO i=1,nlat
        as(k, 1) = as(k, 1) + agg_copy(i, 1)*pw(i, k)
      END DO
    END DO
    DO m=1,nm
      mr = m + 1
      mi = nlon1 - m
      k1 = k2 + 1
      k2 = k2 + nshm(m)
      DO k=k1,k2
        DO i=1,nlat
          as(k, 1) = as(k, 1) + agg_copy(i, mr)*pw(i, k)
          as(k, 2) = as(k, 2) + agg_copy(i, mi)*pw(i, k)
        END DO
      END DO
    END DO
  END FUNCTION GGTOSP
!  Differentiation of ddl in reverse (adjoint) mode:
!   gradient     of useful results: as dadl
!   with respect to varying inputs: as
!-----------------------------------------------------------------------
! zonal derivative in spectral space
! input spectral field as
! output spectral field dadl which is as differentiated wrt lambda
!-----------------------------------------------------------------------
  SUBROUTINE DDL_B(as, asb, dadlb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: as(nsh, 2)
    REAL*8 :: asb(nsh, 2)
    REAL*8 :: dadl(nsh, 2)
    REAL*8 :: dadlb(nsh, 2)
    INTEGER :: k
    DO k=nsh,1,-1
      asb(k, 1) = asb(k, 1) + rm(k)*dadlb(k, 2)
      dadlb(k, 2) = 0.0_8
      asb(k, 2) = asb(k, 2) - rm(k)*dadlb(k, 1)
      dadlb(k, 1) = 0.0_8
    END DO
  END SUBROUTINE DDL_B
!-----------------------------------------------------------------------
! zonal derivative in spectral space
! input spectral field as
! output spectral field dadl which is as differentiated wrt lambda
!-----------------------------------------------------------------------
  FUNCTION DDL(as) RESULT (DADL)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: as(nsh, 2)
    REAL*8 :: dadl(nsh, 2)
    INTEGER :: k
    DO k=1,nsh
      dadl(k, 1) = -(rm(k)*as(k, 2))
      dadl(k, 2) = rm(k)*as(k, 1)
    END DO
    RETURN
  END FUNCTION DDL
END MODULE TAPENADE_B

!  Differentiation of c06fpf in reverse (adjoint) mode:
!   gradient     of useful results: x work
!   with respect to varying inputs: x work
SUBROUTINE C06FPF_B(m, n, x, xb, init, trig, work, workb, ifail)
  IMPLICIT NONE
!VD$R NOVECTOR
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     .. Parameters ..
  CHARACTER(len=6) :: srname
  PARAMETER (srname='C06FPF')
!     .. Scalar Arguments ..
  INTEGER :: ifail, m, n
  CHARACTER(len=1) :: init
!     .. Array Arguments ..
  DOUBLE PRECISION :: trig(2*n), work(m*n), x(m*n)
  DOUBLE PRECISION :: workb(m*n), xb(m*n)
!     .. Local Scalars ..
  INTEGER :: ierror, nq, nrec
!     .. Local Arrays ..
  INTEGER :: q(30)
  CHARACTER(len=80) :: rec(1)
  EXTERNAL P01ABF
!     .. External Functions ..
  INTEGER :: P01ABF
!     .. External Subroutines ..
  EXTERNAL C06FPQ, C06FPX
  EXTERNAL C06FPX_B
!     .. Executable Statements ..
  CALL C06FPQ(m, n, init, trig, q, nq, ierror)
  IF (ierror .EQ. 0) CALL C06FPX_B(x, xb, work, workb, m, n, q, nq, trig&
&                           )
!
99999 FORMAT(' ** M must be at least 1: M = ',i16)
99998 FORMAT(' ** N must be at least 1: N = ',i16)
99997 FORMAT(' ** ',a1,' is an invalid value of INIT')
99996 FORMAT(' ** INIT = ',a1,', but TRIG array never initialized')
99995 FORMAT(' ** INIT = ',a1,', but N and TRIG array incompatible')
END SUBROUTINE C06FPF_B

!  Differentiation of c06fpx in reverse (adjoint) mode:
!   gradient     of useful results: a b
!   with respect to varying inputs: a b
SUBROUTINE C06FPX_B(a, ab, b, bb, m, n, q, nq, trig)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!
!     Real to Hermitian Fast Fourier Transform Kernel Driver
!
!     Mixed-radix, self-sorting, decimation in time
!
!     .. Scalar Arguments ..
  INTEGER :: m, n, nq
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:m*n-1), b(0:m*n-1), trig(0:2*n-1)
  DOUBLE PRECISION :: ab(0:m*n-1), bb(0:m*n-1)
  INTEGER :: q(nq)
!     .. Local Scalars ..
  DOUBLE PRECISION :: factor
  INTEGER :: i, p, qi, r
  LOGICAL :: ina
!     .. External Subroutines ..
  EXTERNAL C06FPR, C06FPS, C06FPT, C06FPU, C06FPV, C06FPW
  EXTERNAL C06FPR_B, C06FPS_B, C06FPT_B, C06FPU_B, C06FPV_B, C06FPW_B
!     .. Intrinsic Functions ..
  INTRINSIC SQRT, DBLE
  INTEGER :: arg1
  INTEGER :: branch
!     .. Executable Statements ..
  ina = .true.
  p = n
  r = 1
  IF (n .NE. 1) THEN
    DO i=nq,1,-1
      qi = q(i)
      CALL PUSHINTEGER4(p)
      p = p/qi
      IF (ina) THEN
        IF (qi .EQ. 2) THEN
          CALL PUSHINTEGER4(arg1)
          arg1 = m*p
          CALL PUSHCONTROL4B(0)
        ELSE IF (qi .EQ. 3) THEN
          CALL PUSHINTEGER4(arg1)
          arg1 = m*p
          CALL PUSHCONTROL4B(1)
        ELSE IF (qi .EQ. 4) THEN
          CALL PUSHINTEGER4(arg1)
          arg1 = m*p
          CALL PUSHCONTROL4B(2)
        ELSE IF (qi .EQ. 5) THEN
          CALL PUSHINTEGER4(arg1)
          arg1 = m*p
          CALL PUSHCONTROL4B(3)
        ELSE IF (qi .EQ. 6) THEN
          CALL PUSHINTEGER4(arg1)
          arg1 = m*p
          CALL PUSHCONTROL4B(4)
        ELSE
          CALL PUSHINTEGER4(arg1)
          arg1 = m*p
          CALL PUSHCONTROL4B(5)
        END IF
      ELSE IF (qi .EQ. 2) THEN
        CALL PUSHINTEGER4(arg1)
        arg1 = m*p
        CALL PUSHCONTROL4B(6)
      ELSE IF (qi .EQ. 3) THEN
        CALL PUSHINTEGER4(arg1)
        arg1 = m*p
        CALL PUSHCONTROL4B(7)
      ELSE IF (qi .EQ. 4) THEN
        CALL PUSHINTEGER4(arg1)
        arg1 = m*p
        CALL PUSHCONTROL4B(8)
      ELSE IF (qi .EQ. 5) THEN
        CALL PUSHINTEGER4(arg1)
        arg1 = m*p
        CALL PUSHCONTROL4B(9)
      ELSE IF (qi .EQ. 6) THEN
        CALL PUSHINTEGER4(arg1)
        arg1 = m*p
        CALL PUSHCONTROL4B(10)
      ELSE
        CALL PUSHINTEGER4(arg1)
        arg1 = m*p
        CALL PUSHCONTROL4B(11)
      END IF
      ina = .NOT.ina
      CALL PUSHINTEGER4(r)
      r = r*qi
    END DO
!
    factor = 1.0d0/SQRT(DBLE(n))
    IF (ina) THEN
      DO i=m*n-1,0,-1
        ab(i) = factor*ab(i)
      END DO
    ELSE
      DO i=m*n-1,0,-1
        bb(i) = bb(i) + factor*ab(i)
        ab(i) = 0.D0
      END DO
    END IF
    DO i=1,nq,1
      qi = q(i)
      CALL POPINTEGER4(r)
      CALL POPCONTROL4B(branch)
      IF (branch .LT. 6) THEN
        IF (branch .LT. 3) THEN
          IF (branch .EQ. 0) THEN
            CALL C06FPW_B(a, ab, b, bb, arg1, r, trig((p-1)*qi*r), trig(&
&                   n+(p-1)*qi*r))
            CALL POPINTEGER4(arg1)
          ELSE IF (branch .EQ. 1) THEN
            CALL C06FPV_B(a, ab, b, bb, arg1, r, trig((p-1)*qi*r), trig(&
&                   n+(p-1)*qi*r))
            CALL POPINTEGER4(arg1)
          ELSE
            CALL C06FPU_B(a, ab, b, bb, arg1, r, trig((p-1)*qi*r), trig(&
&                   n+(p-1)*qi*r))
            CALL POPINTEGER4(arg1)
          END IF
        ELSE IF (branch .EQ. 3) THEN
          CALL C06FPT_B(a, ab, b, bb, arg1, r, trig((p-1)*qi*r), trig(n+&
&                 (p-1)*qi*r))
          CALL POPINTEGER4(arg1)
        ELSE IF (branch .EQ. 4) THEN
          CALL C06FPS_B(a, ab, b, bb, arg1, r, trig((p-1)*qi*r), trig(n+&
&                 (p-1)*qi*r))
          CALL POPINTEGER4(arg1)
        ELSE
          CALL C06FPR_B(a, ab, b, bb, arg1, qi, r, trig((p-1)*qi*r), &
&                 trig(n+(p-1)*qi*r))
          CALL POPINTEGER4(arg1)
        END IF
      ELSE IF (branch .LT. 9) THEN
        IF (branch .EQ. 6) THEN
          CALL C06FPW_B(b, bb, a, ab, arg1, r, trig((p-1)*qi*r), trig(n+&
&                 (p-1)*qi*r))
          CALL POPINTEGER4(arg1)
        ELSE IF (branch .EQ. 7) THEN
          CALL C06FPV_B(b, bb, a, ab, arg1, r, trig((p-1)*qi*r), trig(n+&
&                 (p-1)*qi*r))
          CALL POPINTEGER4(arg1)
        ELSE
          CALL C06FPU_B(b, bb, a, ab, arg1, r, trig((p-1)*qi*r), trig(n+&
&                 (p-1)*qi*r))
          CALL POPINTEGER4(arg1)
        END IF
      ELSE IF (branch .EQ. 9) THEN
        CALL C06FPT_B(b, bb, a, ab, arg1, r, trig((p-1)*qi*r), trig(n+(p&
&               -1)*qi*r))
        CALL POPINTEGER4(arg1)
      ELSE IF (branch .EQ. 10) THEN
        CALL C06FPS_B(b, bb, a, ab, arg1, r, trig((p-1)*qi*r), trig(n+(p&
&               -1)*qi*r))
        CALL POPINTEGER4(arg1)
      ELSE
        CALL C06FPR_B(b, bb, a, ab, arg1, qi, r, trig((p-1)*qi*r), trig(&
&               n+(p-1)*qi*r))
        CALL POPINTEGER4(arg1)
      END IF
      CALL POPINTEGER4(p)
    END DO
  END IF
END SUBROUTINE C06FPX_B

!  Differentiation of c06fpr in reverse (adjoint) mode:
!   gradient     of useful results: a b
!   with respect to varying inputs: a b
SUBROUTINE C06FPR_B(a, ab, b, bb, p, q, r, cosine, sine)
  IMPLICIT NONE
!     MARK 15 RE-ISSUE. NAG COPYRIGHT 1991.
!
!     Real to Hermitian fast Fourier transform kernel
!     Odd factors greater than 6
!
!     Self-sorting, decimation in time
!
!     .. Scalar Arguments ..
  INTEGER :: p, q, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:q-1, 0:r-1), b(0:p-1, 0:r-1, 0:q-1), &
& cosine(0:r-1, q-1), sine(0:r-1, q-1)
  DOUBLE PRECISION :: ab(0:p-1, 0:q-1, 0:r-1), bb(0:p-1, 0:r-1, 0:q-1)
!     .. Local Scalars ..
  DOUBLE PRECISION :: ai, ar, temp1, temp2, temp3, temp4
  DOUBLE PRECISION :: aib, arb, temp1b, temp2b, temp3b, temp4b
  INTEGER :: i, indx, j, k, kp, l, q2, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
  DOUBLE PRECISION :: tmp
  DOUBLE PRECISION :: tmpb
  DOUBLE PRECISION :: tmp0
  DOUBLE PRECISION :: tmp1
  DOUBLE PRECISION :: tmpb0
  DOUBLE PRECISION :: tmpb1
  DOUBLE PRECISION :: tmp2
  DOUBLE PRECISION :: tmp3
  DOUBLE PRECISION :: tmpb2
  DOUBLE PRECISION :: tmpb3
  DOUBLE PRECISION :: tmp4
  DOUBLE PRECISION :: tmpb4
  DOUBLE PRECISION :: tmp5
  DOUBLE PRECISION :: tmp6
  DOUBLE PRECISION :: tmpb5
  DOUBLE PRECISION :: tmpb6
  DOUBLE PRECISION :: tmp7
  DOUBLE PRECISION :: tmp8
  DOUBLE PRECISION :: tmpb7
  DOUBLE PRECISION :: tmpb8
  INTEGER :: branch
!     .. Executable Statements ..
!
  q2 = (q-1)/2
  IF (p .GE. r/2) THEN
    DO l=1,q2
      DO j=1,q2
        CALL PUSHINTEGER4(indx)
        indx = MOD(j*l, q)
      END DO
    END DO
!
!        Code for general K --
!
    DO k=1,(r-1)/2
      DO l=1,q2
        DO j=1,q2
          CALL PUSHINTEGER4(indx)
          indx = MOD(j*l, q)
        END DO
      END DO
    END DO
!
!        Code for K=R/2 if R is even --
!
    IF (MOD(r, 2) .EQ. 0) THEN
      r2 = r/2
      IF (MOD(q2, 2) .EQ. 1) THEN
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      DO l=0,q2-1
        DO j=1,q2
          CALL PUSHINTEGER4(indx)
          indx = MOD(j*(l+q2+1), q)
        END DO
      END DO
      DO j=q2,1,-1
        DO i=p-1,0,-1
          ab(i, j, r2) = ab(i, j, r2) + bb(i, r2, q2)
        END DO
      END DO
      DO i=p-1,0,-1
        ab(i, 0, r2) = ab(i, 0, r2) + bb(i, r2, q2)
        bb(i, r2, q2) = 0.D0
      END DO
      DO l=q2-1,0,-1
        DO j=q2,1,-1
          DO i=p-1,0,-1
            ab(i, q-j, r2) = ab(i, q-j, r2) + sine(0, indx)*bb(i, r2, q-&
&             l-1)
            ab(i, j, r2) = ab(i, j, r2) + cosine(0, indx)*bb(i, r2, l)
          END DO
          CALL POPINTEGER4(indx)
        END DO
        DO i=p-1,0,-1
          bb(i, r2, q-l-1) = 0.D0
          ab(i, 0, r2) = ab(i, 0, r2) + bb(i, r2, l)
          bb(i, r2, l) = 0.D0
        END DO
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        DO i=p-1,0,-1
          temp1b = -ab(i, q2+1, r2)
          temp2b = -ab(i, q2+1, r2)
          ab(i, q2+1, r2) = 0.D0
          temp2b = temp2b + ab(i, q2, r2)
          temp1b = temp1b - ab(i, q2, r2)
          ab(i, q2, r2) = 0.D0
          ab(i, q2+1, r2) = ab(i, q2+1, r2) + temp2b
          ab(i, q2, r2) = ab(i, q2, r2) + temp1b
        END DO
      END IF
      DO j=q2-MOD(q2-2, 2)-1,1,-2
        DO i=p-1,0,-1
          temp3b = ab(i, q-j-1, r2)
          temp4b = ab(i, q-j-1, r2)
          ab(i, q-j-1, r2) = 0.D0
          temp3b = temp3b + ab(i, j+1, r2)
          temp4b = temp4b - ab(i, j+1, r2)
          ab(i, j+1, r2) = 0.D0
          ab(i, q-j-1, r2) = ab(i, q-j-1, r2) + temp4b
          ab(i, j+1, r2) = ab(i, j+1, r2) + temp3b
          temp1b = -ab(i, q-j, r2)
          temp2b = -ab(i, q-j, r2)
          ab(i, q-j, r2) = 0.D0
          temp2b = temp2b + ab(i, j, r2)
          temp1b = temp1b - ab(i, j, r2)
          ab(i, j, r2) = 0.D0
          ab(i, q-j, r2) = ab(i, q-j, r2) + temp2b
          ab(i, j, r2) = ab(i, j, r2) + temp1b
        END DO
      END DO
    END IF
    DO k=(r-1)/2,1,-1
      kp = r - k
      DO l=q2,1,-1
        DO i=p-1,0,-1
          temp2b = -bb(i, k, q-l)
          temp3b = -bb(i, k, q-l)
          bb(i, k, q-l) = 0.D0
          temp2b = temp2b + bb(i, kp, q-l-1)
          temp3b = temp3b - bb(i, kp, q-l-1)
          bb(i, kp, q-l-1) = 0.D0
          tmpb2 = bb(i, kp, l-1)
          bb(i, kp, l-1) = 0.D0
          bb(i, k, q-l) = bb(i, k, q-l) + tmpb2
          tmpb3 = bb(i, k, l)
          temp1b = tmpb3 + tmpb2
          bb(i, k, l) = 0.D0
          bb(i, k, q-l) = bb(i, k, q-l) - tmpb3
          bb(i, kp, l-1) = bb(i, kp, l-1) + temp3b
          bb(i, kp, q-l-1) = bb(i, kp, q-l-1) + temp2b
          bb(i, k, l) = bb(i, k, l) + temp1b
        END DO
      END DO
      DO j=q2,1,-1
        DO i=p-1,0,-1
          ab(i, j, kp) = ab(i, j, kp) + bb(i, kp, q-1)
          ab(i, j, k) = ab(i, j, k) + bb(i, k, 0)
        END DO
      END DO
      DO i=p-1,0,-1
        ab(i, 0, kp) = ab(i, 0, kp) + bb(i, kp, q-1)
        bb(i, kp, q-1) = 0.D0
        ab(i, 0, k) = ab(i, 0, k) + bb(i, k, 0)
        bb(i, k, 0) = 0.D0
      END DO
      DO l=q2,1,-1
        DO j=q2,1,-1
          DO i=p-1,0,-1
            ab(i, q-j, kp) = ab(i, q-j, kp) + sine(0, indx)*bb(i, k, q-l&
&             )
            ab(i, q-j, k) = ab(i, q-j, k) - sine(0, indx)*bb(i, kp, l-1)
            ab(i, j, kp) = ab(i, j, kp) + cosine(0, indx)*bb(i, kp, q-l-&
&             1)
            ab(i, j, k) = ab(i, j, k) + cosine(0, indx)*bb(i, k, l)
          END DO
          CALL POPINTEGER4(indx)
        END DO
        DO i=p-1,0,-1
          bb(i, k, q-l) = 0.D0
          bb(i, kp, l-1) = 0.D0
          ab(i, 0, kp) = ab(i, 0, kp) + bb(i, kp, q-l-1)
          bb(i, kp, q-l-1) = 0.D0
          ab(i, 0, k) = ab(i, 0, k) + bb(i, k, l)
          bb(i, k, l) = 0.D0
        END DO
      END DO
      DO j=q2,1,-1
        DO i=p-1,0,-1
          temp2b = ab(i, q-j, kp)
          ab(i, q-j, kp) = -ab(i, q-j, kp)
          temp1b = ab(i, q-j, k)
          ab(i, q-j, k) = -ab(i, q-j, k)
          tmpb0 = ab(i, j, kp)
          ab(i, j, kp) = 0.D0
          temp2b = temp2b + tmpb0
          ab(i, q-j, kp) = ab(i, q-j, kp) + tmpb0
          tmpb1 = ab(i, j, k)
          ab(i, j, k) = 0.D0
          temp1b = temp1b + tmpb1
          ab(i, q-j, k) = ab(i, q-j, k) + tmpb1
          ab(i, j, kp) = ab(i, j, kp) + temp2b
          ab(i, j, k) = ab(i, j, k) + temp1b
        END DO
      END DO
      DO j=q-1,1,-1
        DO i=p-1,0,-1
          aib = cosine(k, j)*ab(i, j, kp)
          arb = sine(k, j)*ab(i, j, kp)
          ab(i, j, kp) = 0.D0
          arb = arb + cosine(k, j)*ab(i, j, k)
          aib = aib - sine(k, j)*ab(i, j, k)
          ab(i, j, k) = 0.D0
          ab(i, j, kp) = ab(i, j, kp) + aib
          ab(i, j, k) = ab(i, j, k) + arb
        END DO
      END DO
    END DO
    DO j=q2,1,-1
      DO i=p-1,0,-1
        ab(i, j, 0) = ab(i, j, 0) + bb(i, 0, 0)
      END DO
    END DO
    DO i=p-1,0,-1
      ab(i, 0, 0) = ab(i, 0, 0) + bb(i, 0, 0)
      bb(i, 0, 0) = 0.D0
    END DO
    DO l=q2,1,-1
      DO j=q2,1,-1
        DO i=p-1,0,-1
          ab(i, q-j, 0) = ab(i, q-j, 0) + sine(0, indx)*bb(i, 0, q-l)
          ab(i, j, 0) = ab(i, j, 0) + cosine(0, indx)*bb(i, 0, l)
        END DO
        CALL POPINTEGER4(indx)
      END DO
      DO i=p-1,0,-1
        bb(i, 0, q-l) = 0.D0
        ab(i, 0, 0) = ab(i, 0, 0) + bb(i, 0, l)
        bb(i, 0, l) = 0.D0
      END DO
    END DO
    DO j=q2,1,-1
      DO i=p-1,0,-1
        temp1b = ab(i, q-j, 0)
        ab(i, q-j, 0) = -ab(i, q-j, 0)
        tmpb = ab(i, j, 0)
        ab(i, j, 0) = 0.D0
        temp1b = temp1b + tmpb
        ab(i, q-j, 0) = ab(i, q-j, 0) + tmpb
        ab(i, j, 0) = ab(i, j, 0) + temp1b
      END DO
    END DO
  ELSE
!
!
    DO i=0,p-1
      DO l=1,q2
        DO j=1,q2
          CALL PUSHINTEGER4(indx)
          indx = MOD(j*l, q)
        END DO
      END DO
      DO l=1,q2
        DO j=1,q2
          CALL PUSHINTEGER4(indx)
          indx = MOD(j*l, q)
        END DO
      END DO
!
!           Code for K=R/2 if R is even --
!
      IF (MOD(r, 2) .EQ. 0) THEN
        CALL PUSHINTEGER4(r2)
        r2 = r/2
        IF (MOD(q2, 2) .EQ. 1) THEN
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        DO l=0,q2-1
          DO j=1,q2
            CALL PUSHINTEGER4(indx)
            indx = MOD(j*(l+q2+1), q)
          END DO
        END DO
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
    END DO
    DO i=p-1,0,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO j=q2,1,-1
          ab(i, j, r2) = ab(i, j, r2) + bb(i, r2, q2)
        END DO
        ab(i, 0, r2) = ab(i, 0, r2) + bb(i, r2, q2)
        bb(i, r2, q2) = 0.D0
        DO l=q2-1,0,-1
          DO j=q2,1,-1
            ab(i, q-j, r2) = ab(i, q-j, r2) + sine(0, indx)*bb(i, r2, q-&
&             l-1)
            ab(i, j, r2) = ab(i, j, r2) + cosine(0, indx)*bb(i, r2, l)
            CALL POPINTEGER4(indx)
          END DO
          bb(i, r2, q-l-1) = 0.D0
          ab(i, 0, r2) = ab(i, 0, r2) + bb(i, r2, l)
          bb(i, r2, l) = 0.D0
        END DO
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          temp1b = -ab(i, q2+1, r2)
          temp2b = -ab(i, q2+1, r2)
          ab(i, q2+1, r2) = 0.D0
          temp2b = temp2b + ab(i, q2, r2)
          temp1b = temp1b - ab(i, q2, r2)
          ab(i, q2, r2) = 0.D0
          ab(i, q2+1, r2) = ab(i, q2+1, r2) + temp2b
          ab(i, q2, r2) = ab(i, q2, r2) + temp1b
        END IF
        DO j=q2-MOD(q2-2, 2)-1,1,-2
          temp3b = ab(i, q-j-1, r2)
          temp4b = ab(i, q-j-1, r2)
          ab(i, q-j-1, r2) = 0.D0
          temp3b = temp3b + ab(i, j+1, r2)
          temp4b = temp4b - ab(i, j+1, r2)
          ab(i, j+1, r2) = 0.D0
          ab(i, q-j-1, r2) = ab(i, q-j-1, r2) + temp4b
          ab(i, j+1, r2) = ab(i, j+1, r2) + temp3b
          temp1b = -ab(i, q-j, r2)
          temp2b = -ab(i, q-j, r2)
          ab(i, q-j, r2) = 0.D0
          temp2b = temp2b + ab(i, j, r2)
          temp1b = temp1b - ab(i, j, r2)
          ab(i, j, r2) = 0.D0
          ab(i, q-j, r2) = ab(i, q-j, r2) + temp2b
          ab(i, j, r2) = ab(i, j, r2) + temp1b
        END DO
        CALL POPINTEGER4(r2)
      END IF
      DO l=q2,1,-1
        DO k=(r-1)/2,1,-1
          temp2b = -bb(i, k, q-l)
          temp3b = -bb(i, k, q-l)
          bb(i, k, q-l) = 0.D0
          temp2b = temp2b + bb(i, r-k, q-l-1)
          temp3b = temp3b - bb(i, r-k, q-l-1)
          bb(i, r-k, q-l-1) = 0.D0
          tmpb7 = bb(i, r-k, l-1)
          bb(i, r-k, l-1) = 0.D0
          bb(i, k, q-l) = bb(i, k, q-l) + tmpb7
          tmpb8 = bb(i, k, l)
          temp1b = tmpb8 + tmpb7
          bb(i, k, l) = 0.D0
          bb(i, k, q-l) = bb(i, k, q-l) - tmpb8
          bb(i, r-k, l-1) = bb(i, r-k, l-1) + temp3b
          bb(i, r-k, q-l-1) = bb(i, r-k, q-l-1) + temp2b
          bb(i, k, l) = bb(i, k, l) + temp1b
        END DO
      END DO
      DO j=q2,1,-1
        DO k=(r-1)/2,1,-1
          ab(i, j, r-k) = ab(i, j, r-k) + bb(i, r-k, q-1)
          ab(i, j, k) = ab(i, j, k) + bb(i, k, 0)
        END DO
      END DO
      DO k=(r-1)/2,1,-1
        ab(i, 0, r-k) = ab(i, 0, r-k) + bb(i, r-k, q-1)
        bb(i, r-k, q-1) = 0.D0
        ab(i, 0, k) = ab(i, 0, k) + bb(i, k, 0)
        bb(i, k, 0) = 0.D0
      END DO
      DO l=q2,1,-1
        DO j=q2,1,-1
          DO k=(r-1)/2,1,-1
            ab(i, q-j, r-k) = ab(i, q-j, r-k) + sine(0, indx)*bb(i, k, q&
&             -l)
            ab(i, q-j, k) = ab(i, q-j, k) - sine(0, indx)*bb(i, r-k, l-1&
&             )
            ab(i, j, r-k) = ab(i, j, r-k) + cosine(0, indx)*bb(i, r-k, q&
&             -l-1)
            ab(i, j, k) = ab(i, j, k) + cosine(0, indx)*bb(i, k, l)
          END DO
          CALL POPINTEGER4(indx)
        END DO
        DO k=(r-1)/2,1,-1
          bb(i, k, q-l) = 0.D0
          bb(i, r-k, l-1) = 0.D0
          ab(i, 0, r-k) = ab(i, 0, r-k) + bb(i, r-k, q-l-1)
          bb(i, r-k, q-l-1) = 0.D0
          ab(i, 0, k) = ab(i, 0, k) + bb(i, k, l)
          bb(i, k, l) = 0.D0
        END DO
      END DO
      DO j=q2,1,-1
        DO k=(r-1)/2,1,-1
          temp2b = ab(i, q-j, r-k)
          ab(i, q-j, r-k) = -ab(i, q-j, r-k)
          temp1b = ab(i, q-j, k)
          ab(i, q-j, k) = -ab(i, q-j, k)
          tmpb5 = ab(i, j, r-k)
          ab(i, j, r-k) = 0.D0
          temp2b = temp2b + tmpb5
          ab(i, q-j, r-k) = ab(i, q-j, r-k) + tmpb5
          tmpb6 = ab(i, j, k)
          ab(i, j, k) = 0.D0
          temp1b = temp1b + tmpb6
          ab(i, q-j, k) = ab(i, q-j, k) + tmpb6
          ab(i, j, r-k) = ab(i, j, r-k) + temp2b
          ab(i, j, k) = ab(i, j, k) + temp1b
        END DO
      END DO
      DO j=q-1,1,-1
        DO k=(r-1)/2,1,-1
          aib = cosine(k, j)*ab(i, j, r-k)
          arb = sine(k, j)*ab(i, j, r-k)
          ab(i, j, r-k) = 0.D0
          arb = arb + cosine(k, j)*ab(i, j, k)
          aib = aib - sine(k, j)*ab(i, j, k)
          ab(i, j, k) = 0.D0
          ab(i, j, r-k) = ab(i, j, r-k) + aib
          ab(i, j, k) = ab(i, j, k) + arb
        END DO
      END DO
      DO j=q2,1,-1
        ab(i, j, 0) = ab(i, j, 0) + bb(i, 0, 0)
      END DO
      ab(i, 0, 0) = ab(i, 0, 0) + bb(i, 0, 0)
      bb(i, 0, 0) = 0.D0
      DO l=q2,1,-1
        DO j=q2,1,-1
          ab(i, q-j, 0) = ab(i, q-j, 0) + sine(0, indx)*bb(i, 0, q-l)
          ab(i, j, 0) = ab(i, j, 0) + cosine(0, indx)*bb(i, 0, l)
          CALL POPINTEGER4(indx)
        END DO
        bb(i, 0, q-l) = 0.D0
        ab(i, 0, 0) = ab(i, 0, 0) + bb(i, 0, l)
        bb(i, 0, l) = 0.D0
      END DO
      DO j=q2,1,-1
        temp1b = ab(i, q-j, 0)
        ab(i, q-j, 0) = -ab(i, q-j, 0)
        tmpb4 = ab(i, j, 0)
        ab(i, j, 0) = 0.D0
        temp1b = temp1b + tmpb4
        ab(i, q-j, 0) = ab(i, q-j, 0) + tmpb4
        ab(i, j, 0) = ab(i, j, 0) + temp1b
      END DO
    END DO
  END IF
END SUBROUTINE C06FPR_B

!  Differentiation of c06fps in reverse (adjoint) mode:
!   gradient     of useful results: a b
!   with respect to varying inputs: a b
SUBROUTINE C06FPS_B(a, ab, b, bb, p, r, cosine, sine)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     MARK 14 REVISED. IER-694 (DEC 1989).
!
!     Radix six real to Hermitian fast Fourier transform kernel
!
!     Self-sorting, decimation in time
!
!     .. Parameters ..
  DOUBLE PRECISION :: sin60
  PARAMETER (sin60=0.866025403784438646763723170752936d0)
!     .. Scalar Arguments ..
  INTEGER :: p, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:5, 0:r-1), b(0:p-1, 0:r-1, 0:5), cosine&
& (0:r-1, 5), sine(0:r-1, 5)
  DOUBLE PRECISION :: ab(0:p-1, 0:5, 0:r-1), bb(0:p-1, 0:r-1, 0:5)
!     .. Local Scalars ..
  DOUBLE PRECISION :: c2k, c3k, c4k, c5k, ck, s2k, s3k, s4k, s5k, sk, t1&
& , t1i, t1r, t2, t2i, t2r, t3, t3i, t3r, t4, t5, t6, u0, u0i, u0r, u1i&
& , u1r, u2i, u2r, ui, ur, v0, v0i, v0r, v1i, v1r, v2i, v2r, vi, vr, x1p&
& , x2p, x3p, x4p, x5p, y1p, y2p, y3p, y4p, y5p
  DOUBLE PRECISION :: t1b, t1ib, t1rb, t2b, t2ib, t2rb, t3b, t3ib, t3rb&
& , t4b, t5b, t6b, u0b, u0ib, u0rb, u1ib, u1rb, u2ib, u2rb, uib, urb, &
& v0b, v0ib, v0rb, v1ib, v1rb, v2ib, v2rb, vib, vrb, x1pb, x2pb, x3pb, &
& x4pb, x5pb, y1pb, y2pb, y3pb, y4pb, y5pb
  INTEGER :: i, k, kp, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
  INTEGER :: branch
!
!     Code for general K --
!
  IF (p .LE. (r-1)/2) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
!
!     Code for K=R/2 when R is even --
!
  IF (MOD(r, 2) .EQ. 0) THEN
    r2 = r/2
    DO i=p-1,0,-1
      t5b = bb(i, r2, 5)
      t3b = -bb(i, r2, 5)
      bb(i, r2, 5) = 0.D0
      ab(i, 3, r2) = ab(i, 3, r2) + bb(i, r2, 4)
      t4b = -bb(i, r2, 4)
      bb(i, r2, 4) = 0.D0
      t5b = t5b + bb(i, r2, 3)
      t3b = t3b + bb(i, r2, 3)
      bb(i, r2, 3) = 0.D0
      t2b = bb(i, r2, 2)
      t6b = -bb(i, r2, 2)
      bb(i, r2, 2) = 0.D0
      ab(i, 0, r2) = ab(i, 0, r2) + bb(i, r2, 1)
      t1b = -bb(i, r2, 1)
      bb(i, r2, 1) = 0.D0
      t2b = t2b + bb(i, r2, 0)
      t6b = t6b + bb(i, r2, 0)
      bb(i, r2, 0) = 0.D0
      ab(i, 1, r2) = ab(i, 1, r2) + sin60*t6b
      ab(i, 5, r2) = ab(i, 5, r2) - sin60*t6b
      ab(i, 3, r2) = ab(i, 3, r2) - t5b
      t4b = t4b - 0.5d0*t5b
      ab(i, 1, r2) = ab(i, 1, r2) + t4b
      ab(i, 5, r2) = ab(i, 5, r2) + t4b
      ab(i, 2, r2) = ab(i, 2, r2) + sin60*t3b
      ab(i, 4, r2) = ab(i, 4, r2) + sin60*t3b
      ab(i, 0, r2) = ab(i, 0, r2) + t2b
      t1b = t1b + 0.5d0*t2b
      ab(i, 2, r2) = ab(i, 2, r2) + t1b
      ab(i, 4, r2) = ab(i, 4, r2) - t1b
    END DO
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    DO i=p-1,0,-1
      DO k=(r-1)/2,1,-1
        u0ib = bb(i, r-k, 5)
        v0ib = bb(i, r-k, 5)
        bb(i, r-k, 5) = 0.D0
        v2ib = bb(i, k, 5)
        u2ib = -bb(i, k, 5)
        bb(i, k, 5) = 0.D0
        u1ib = bb(i, r-k, 4)
        v1ib = -bb(i, r-k, 4)
        bb(i, r-k, 4) = 0.D0
        u1ib = u1ib - bb(i, k, 4)
        v1ib = v1ib - bb(i, k, 4)
        bb(i, k, 4) = 0.D0
        u2ib = u2ib + bb(i, r-k, 3)
        v2ib = v2ib + bb(i, r-k, 3)
        bb(i, r-k, 3) = 0.D0
        v0ib = v0ib + bb(i, k, 3)
        u0ib = u0ib - bb(i, k, 3)
        bb(i, k, 3) = 0.D0
        u0rb = bb(i, r-k, 2)
        v0rb = -bb(i, r-k, 2)
        bb(i, r-k, 2) = 0.D0
        u2rb = bb(i, k, 2)
        v2rb = bb(i, k, 2)
        bb(i, k, 2) = 0.D0
        u1rb = bb(i, r-k, 1)
        v1rb = bb(i, r-k, 1)
        bb(i, r-k, 1) = 0.D0
        u1rb = u1rb + bb(i, k, 1)
        v1rb = v1rb - bb(i, k, 1)
        bb(i, k, 1) = 0.D0
        u2rb = u2rb + bb(i, r-k, 0)
        v2rb = v2rb - bb(i, r-k, 0)
        bb(i, r-k, 0) = 0.D0
        u0rb = u0rb + bb(i, k, 0)
        v0rb = v0rb + bb(i, k, 0)
        bb(i, k, 0) = 0.D0
        t2ib = v1ib + v2ib
        t3rb = v2ib - v1ib
        t2rb = v1rb + v2rb
        t3ib = v1rb - v2rb
        y3pb = t2ib + v0ib
        t1ib = v0ib - 0.5d0*t2ib
        x3pb = t2rb + v0rb
        t1rb = v0rb - 0.5d0*t2rb
        y5pb = t1ib + sin60*t3ib
        y1pb = t1ib - sin60*t3ib
        x5pb = t1rb + sin60*t3rb
        x1pb = t1rb - sin60*t3rb
        t2ib = u1ib + u2ib
        t3rb = u2ib - u1ib
        t2rb = u1rb + u2rb
        t3ib = u1rb - u2rb
        ab(i, 0, r-k) = ab(i, 0, r-k) + u0ib
        t1ib = u0ib - 0.5d0*t2ib
        ab(i, 0, k) = ab(i, 0, k) + u0rb
        t1rb = u0rb - 0.5d0*t2rb
        y2pb = t1ib + sin60*t3ib
        y4pb = t1ib - sin60*t3ib
        x2pb = t1rb + sin60*t3rb
        x4pb = t1rb - sin60*t3rb
        ab(i, 0, r-k) = ab(i, 0, r-k) + t2ib
        ab(i, 0, k) = ab(i, 0, k) + t2rb
        ab(i, 5, r-k) = ab(i, 5, r-k) + cosine(k, 5)*y5pb
        ab(i, 5, k) = ab(i, 5, k) + cosine(k, 5)*x5pb + sine(k, 5)*y5pb
        ab(i, 5, r-k) = ab(i, 5, r-k) - sine(k, 5)*x5pb
        ab(i, 4, r-k) = ab(i, 4, r-k) + cosine(k, 4)*y4pb
        ab(i, 4, k) = ab(i, 4, k) + cosine(k, 4)*x4pb + sine(k, 4)*y4pb
        ab(i, 4, r-k) = ab(i, 4, r-k) - sine(k, 4)*x4pb
        ab(i, 3, r-k) = ab(i, 3, r-k) + cosine(k, 3)*y3pb
        ab(i, 3, k) = ab(i, 3, k) + cosine(k, 3)*x3pb + sine(k, 3)*y3pb
        ab(i, 3, r-k) = ab(i, 3, r-k) - sine(k, 3)*x3pb
        ab(i, 2, r-k) = ab(i, 2, r-k) + cosine(k, 2)*y2pb
        ab(i, 2, k) = ab(i, 2, k) + cosine(k, 2)*x2pb + sine(k, 2)*y2pb
        ab(i, 2, r-k) = ab(i, 2, r-k) - sine(k, 2)*x2pb
        ab(i, 1, r-k) = ab(i, 1, r-k) + cosine(k, 1)*y1pb
        ab(i, 1, k) = ab(i, 1, k) + cosine(k, 1)*x1pb + sine(k, 1)*y1pb
        ab(i, 1, r-k) = ab(i, 1, r-k) - sine(k, 1)*x1pb
      END DO
    END DO
  ELSE
    DO k=(r-1)/2,1,-1
      s3k = sine(k, 3)
      c3k = cosine(k, 3)
      kp = r - k
      s4k = sine(k, 4)
      c4k = cosine(k, 4)
      s5k = sine(k, 5)
      sk = sine(k, 1)
      s2k = sine(k, 2)
      ck = cosine(k, 1)
      c5k = cosine(k, 5)
      c2k = cosine(k, 2)
      DO i=p-1,0,-1
        u0ib = bb(i, kp, 5)
        v0ib = bb(i, kp, 5)
        bb(i, kp, 5) = 0.D0
        v2ib = bb(i, k, 5)
        u2ib = -bb(i, k, 5)
        bb(i, k, 5) = 0.D0
        u1ib = bb(i, kp, 4)
        v1ib = -bb(i, kp, 4)
        bb(i, kp, 4) = 0.D0
        u1ib = u1ib - bb(i, k, 4)
        v1ib = v1ib - bb(i, k, 4)
        bb(i, k, 4) = 0.D0
        u2ib = u2ib + bb(i, kp, 3)
        v2ib = v2ib + bb(i, kp, 3)
        bb(i, kp, 3) = 0.D0
        v0ib = v0ib + bb(i, k, 3)
        u0ib = u0ib - bb(i, k, 3)
        bb(i, k, 3) = 0.D0
        u0rb = bb(i, kp, 2)
        v0rb = -bb(i, kp, 2)
        bb(i, kp, 2) = 0.D0
        u2rb = bb(i, k, 2)
        v2rb = bb(i, k, 2)
        bb(i, k, 2) = 0.D0
        u1rb = bb(i, kp, 1)
        v1rb = bb(i, kp, 1)
        bb(i, kp, 1) = 0.D0
        u1rb = u1rb + bb(i, k, 1)
        v1rb = v1rb - bb(i, k, 1)
        bb(i, k, 1) = 0.D0
        u2rb = u2rb + bb(i, kp, 0)
        v2rb = v2rb - bb(i, kp, 0)
        bb(i, kp, 0) = 0.D0
        u0rb = u0rb + bb(i, k, 0)
        v0rb = v0rb + bb(i, k, 0)
        bb(i, k, 0) = 0.D0
        t2ib = v1ib + v2ib
        t3rb = v2ib - v1ib
        t2rb = v1rb + v2rb
        t3ib = v1rb - v2rb
        y3pb = t2ib + v0ib
        t1ib = v0ib - 0.5d0*t2ib
        x3pb = t2rb + v0rb
        t1rb = v0rb - 0.5d0*t2rb
        y5pb = t1ib + sin60*t3ib
        y1pb = t1ib - sin60*t3ib
        x5pb = t1rb + sin60*t3rb
        x1pb = t1rb - sin60*t3rb
        t2ib = u1ib + u2ib
        t3rb = u2ib - u1ib
        t2rb = u1rb + u2rb
        t3ib = u1rb - u2rb
        ab(i, 0, kp) = ab(i, 0, kp) + u0ib
        t1ib = u0ib - 0.5d0*t2ib
        ab(i, 0, k) = ab(i, 0, k) + u0rb
        t1rb = u0rb - 0.5d0*t2rb
        y2pb = t1ib + sin60*t3ib
        y4pb = t1ib - sin60*t3ib
        x2pb = t1rb + sin60*t3rb
        x4pb = t1rb - sin60*t3rb
        ab(i, 0, kp) = ab(i, 0, kp) + t2ib
        ab(i, 0, k) = ab(i, 0, k) + t2rb
        ab(i, 5, kp) = ab(i, 5, kp) + c5k*y5pb
        ab(i, 5, k) = ab(i, 5, k) + c5k*x5pb + s5k*y5pb
        ab(i, 5, kp) = ab(i, 5, kp) - s5k*x5pb
        ab(i, 4, kp) = ab(i, 4, kp) + c4k*y4pb
        ab(i, 4, k) = ab(i, 4, k) + c4k*x4pb + s4k*y4pb
        ab(i, 4, kp) = ab(i, 4, kp) - s4k*x4pb
        ab(i, 3, kp) = ab(i, 3, kp) + c3k*y3pb
        ab(i, 3, k) = ab(i, 3, k) + c3k*x3pb + s3k*y3pb
        ab(i, 3, kp) = ab(i, 3, kp) - s3k*x3pb
        ab(i, 2, kp) = ab(i, 2, kp) + c2k*y2pb
        ab(i, 2, k) = ab(i, 2, k) + c2k*x2pb + s2k*y2pb
        ab(i, 2, kp) = ab(i, 2, kp) - s2k*x2pb
        ab(i, 1, kp) = ab(i, 1, kp) + ck*y1pb
        ab(i, 1, k) = ab(i, 1, k) + ck*x1pb + sk*y1pb
        ab(i, 1, kp) = ab(i, 1, kp) - sk*x1pb
      END DO
    END DO
  END IF
  DO i=p-1,0,-1
    uib = bb(i, 0, 5)
    vib = -bb(i, 0, 5)
    bb(i, 0, 5) = 0.D0
    uib = uib - bb(i, 0, 4)
    vib = vib - bb(i, 0, 4)
    bb(i, 0, 4) = 0.D0
    u0b = bb(i, 0, 3)
    v0b = -bb(i, 0, 3)
    bb(i, 0, 3) = 0.D0
    urb = bb(i, 0, 2)
    vrb = bb(i, 0, 2)
    bb(i, 0, 2) = 0.D0
    urb = urb + bb(i, 0, 1)
    vrb = vrb - bb(i, 0, 1)
    bb(i, 0, 1) = 0.D0
    u0b = u0b + bb(i, 0, 0)
    v0b = v0b + bb(i, 0, 0)
    bb(i, 0, 0) = 0.D0
    ab(i, 3, 0) = ab(i, 3, 0) + v0b
    t1b = v0b - 0.5d0*vrb
    ab(i, 5, 0) = ab(i, 5, 0) - sin60*vib
    ab(i, 1, 0) = ab(i, 1, 0) + sin60*vib
    ab(i, 3, 0) = ab(i, 3, 0) + vrb
    ab(i, 5, 0) = ab(i, 5, 0) + t1b
    ab(i, 1, 0) = ab(i, 1, 0) + t1b
    ab(i, 0, 0) = ab(i, 0, 0) + u0b
    t1b = u0b - 0.5d0*urb
    ab(i, 2, 0) = ab(i, 2, 0) - sin60*uib
    ab(i, 4, 0) = ab(i, 4, 0) + sin60*uib
    ab(i, 0, 0) = ab(i, 0, 0) + urb
    ab(i, 2, 0) = ab(i, 2, 0) + t1b
    ab(i, 4, 0) = ab(i, 4, 0) + t1b
  END DO
END SUBROUTINE C06FPS_B

!  Differentiation of c06fpt in reverse (adjoint) mode:
!   gradient     of useful results: a b
!   with respect to varying inputs: a b
SUBROUTINE C06FPT_B(a, ab, b, bb, p, r, cosine, sine)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     MARK 14 REVISED. IER-695 (DEC 1989).
!
!     Radix five real to Hermitian fast Fourier transform kernel
!
!     Self-sorting, decimation in time
!
!     .. Parameters ..
  DOUBLE PRECISION :: r54, sin72, s36s72
  PARAMETER (r54=0.559016994374947424102293417182819d0, sin72=&
&   0.951056516295153572116439333379382d0, s36s72=&
&   0.618033988749894848204586834365638d0)
!     .. Scalar Arguments ..
  INTEGER :: p, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:4, 0:r-1), b(0:p-1, 0:r-1, 0:4), cosine&
& (0:r-1, 4), sine(0:r-1, 4)
  DOUBLE PRECISION :: ab(0:p-1, 0:4, 0:r-1), bb(0:p-1, 0:r-1, 0:4)
!     .. Local Scalars ..
  DOUBLE PRECISION :: c2k, c3k, c4k, ck, s2k, s3k, s4k, sk, t1, t10i, &
& t10r, t11i, t11r, t1i, t1r, t2, t2i, t2r, t3, t3i, t3r, t4, t4i, t4r, &
& t5, t5i, t5r, t6, t6i, t6r, t7, t7i, t7r, t8i, t8r, t9i, t9r, x1p, x2p&
& , x3p, x4p, y1p, y2p, y3p, y4p
  DOUBLE PRECISION :: t1b, t10ib, t10rb, t11ib, t11rb, t1ib, t1rb, t2b, &
& t2ib, t2rb, t3b, t3ib, t3rb, t4b, t4ib, t4rb, t5b, t5ib, t5rb, t6b, &
& t6ib, t6rb, t7b, t7ib, t7rb, t8ib, t8rb, t9ib, t9rb, x1pb, x2pb, x3pb&
& , x4pb, y1pb, y2pb, y3pb, y4pb
  INTEGER :: i, k, kp, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
!
!     Code for general K --
!
  IF (p .LE. (r-1)/2) THEN
    DO i=p-1,0,-1
      DO k=(r-1)/2,1,-1
        ab(i, 0, r-k) = ab(i, 0, r-k) + bb(i, r-k, 4)
        t5ib = bb(i, r-k, 4)
        bb(i, r-k, 4) = 0.D0
        t8ib = -bb(i, k, 4)
        t10rb = -bb(i, k, 4)
        bb(i, k, 4) = 0.D0
        t8ib = t8ib + bb(i, r-k, 3)
        t10rb = t10rb - bb(i, r-k, 3)
        bb(i, r-k, 3) = 0.D0
        t9ib = -bb(i, k, 3)
        t11rb = -bb(i, k, 3)
        bb(i, k, 3) = 0.D0
        t9ib = t9ib + bb(i, r-k, 2)
        t11rb = t11rb - bb(i, r-k, 2)
        bb(i, r-k, 2) = 0.D0
        t9rb = bb(i, k, 2)
        t11ib = bb(i, k, 2)
        bb(i, k, 2) = 0.D0
        t9rb = t9rb + bb(i, r-k, 1)
        t11ib = t11ib - bb(i, r-k, 1)
        bb(i, r-k, 1) = 0.D0
        t8rb = bb(i, k, 1)
        t10ib = bb(i, k, 1)
        bb(i, k, 1) = 0.D0
        t8rb = t8rb + bb(i, r-k, 0)
        t10ib = t10ib - bb(i, r-k, 0)
        bb(i, r-k, 0) = 0.D0
        ab(i, 0, k) = ab(i, 0, k) + bb(i, k, 0)
        t3ib = t10ib + s36s72*t11ib
        t4ib = s36s72*t10ib - t11ib
        t3rb = t10rb + s36s72*t11rb
        t4rb = s36s72*t10rb - t11rb
        t7ib = t8ib + t9ib
        t6ib = t8ib - t9ib
        t7rb = t8rb + t9rb
        t5rb = bb(i, k, 0) - 0.25d0*t7rb
        bb(i, k, 0) = 0.D0
        t6rb = t8rb - t9rb
        ab(i, 0, r-k) = ab(i, 0, r-k) + t7ib
        t5ib = t5ib - 0.25d0*t7ib
        ab(i, 0, k) = ab(i, 0, k) + t7rb
        t1ib = t5ib + r54*t6ib
        t2ib = t5ib - r54*t6ib
        t1rb = t5rb + r54*t6rb
        t2rb = t5rb - r54*t6rb
        y2pb = t2ib + sin72*t4ib
        y3pb = t2ib - sin72*t4ib
        x2pb = t2rb + sin72*t4rb
        x3pb = t2rb - sin72*t4rb
        y1pb = t1ib + sin72*t3ib
        y4pb = t1ib - sin72*t3ib
        x1pb = t1rb + sin72*t3rb
        x4pb = t1rb - sin72*t3rb
        ab(i, 4, r-k) = ab(i, 4, r-k) + cosine(k, 4)*y4pb
        ab(i, 4, k) = ab(i, 4, k) + cosine(k, 4)*x4pb + sine(k, 4)*y4pb
        ab(i, 4, r-k) = ab(i, 4, r-k) - sine(k, 4)*x4pb
        ab(i, 3, r-k) = ab(i, 3, r-k) + cosine(k, 3)*y3pb
        ab(i, 3, k) = ab(i, 3, k) + cosine(k, 3)*x3pb + sine(k, 3)*y3pb
        ab(i, 3, r-k) = ab(i, 3, r-k) - sine(k, 3)*x3pb
        ab(i, 2, r-k) = ab(i, 2, r-k) + cosine(k, 2)*y2pb
        ab(i, 2, k) = ab(i, 2, k) + cosine(k, 2)*x2pb + sine(k, 2)*y2pb
        ab(i, 2, r-k) = ab(i, 2, r-k) - sine(k, 2)*x2pb
        ab(i, 1, r-k) = ab(i, 1, r-k) + cosine(k, 1)*y1pb
        ab(i, 1, k) = ab(i, 1, k) + cosine(k, 1)*x1pb + sine(k, 1)*y1pb
        ab(i, 1, r-k) = ab(i, 1, r-k) - sine(k, 1)*x1pb
      END DO
    END DO
  ELSE
    DO k=(r-1)/2,1,-1
      s3k = sine(k, 3)
      c3k = cosine(k, 3)
      kp = r - k
      s4k = sine(k, 4)
      c4k = cosine(k, 4)
      sk = sine(k, 1)
      s2k = sine(k, 2)
      ck = cosine(k, 1)
      c2k = cosine(k, 2)
      DO i=p-1,0,-1
        ab(i, 0, kp) = ab(i, 0, kp) + bb(i, kp, 4)
        t5ib = bb(i, kp, 4)
        bb(i, kp, 4) = 0.D0
        t8ib = -bb(i, k, 4)
        t10rb = -bb(i, k, 4)
        bb(i, k, 4) = 0.D0
        t8ib = t8ib + bb(i, kp, 3)
        t10rb = t10rb - bb(i, kp, 3)
        bb(i, kp, 3) = 0.D0
        t9ib = -bb(i, k, 3)
        t11rb = -bb(i, k, 3)
        bb(i, k, 3) = 0.D0
        t9ib = t9ib + bb(i, kp, 2)
        t11rb = t11rb - bb(i, kp, 2)
        bb(i, kp, 2) = 0.D0
        t9rb = bb(i, k, 2)
        t11ib = bb(i, k, 2)
        bb(i, k, 2) = 0.D0
        t9rb = t9rb + bb(i, kp, 1)
        t11ib = t11ib - bb(i, kp, 1)
        bb(i, kp, 1) = 0.D0
        t8rb = bb(i, k, 1)
        t10ib = bb(i, k, 1)
        bb(i, k, 1) = 0.D0
        t8rb = t8rb + bb(i, kp, 0)
        t10ib = t10ib - bb(i, kp, 0)
        bb(i, kp, 0) = 0.D0
        ab(i, 0, k) = ab(i, 0, k) + bb(i, k, 0)
        t3ib = t10ib + s36s72*t11ib
        t4ib = s36s72*t10ib - t11ib
        t3rb = t10rb + s36s72*t11rb
        t4rb = s36s72*t10rb - t11rb
        t7ib = t8ib + t9ib
        t6ib = t8ib - t9ib
        t7rb = t8rb + t9rb
        t5rb = bb(i, k, 0) - 0.25d0*t7rb
        bb(i, k, 0) = 0.D0
        t6rb = t8rb - t9rb
        ab(i, 0, kp) = ab(i, 0, kp) + t7ib
        t5ib = t5ib - 0.25d0*t7ib
        ab(i, 0, k) = ab(i, 0, k) + t7rb
        t1ib = t5ib + r54*t6ib
        t2ib = t5ib - r54*t6ib
        t1rb = t5rb + r54*t6rb
        t2rb = t5rb - r54*t6rb
        y2pb = t2ib + sin72*t4ib
        y3pb = t2ib - sin72*t4ib
        x2pb = t2rb + sin72*t4rb
        x3pb = t2rb - sin72*t4rb
        y1pb = t1ib + sin72*t3ib
        y4pb = t1ib - sin72*t3ib
        x1pb = t1rb + sin72*t3rb
        x4pb = t1rb - sin72*t3rb
        ab(i, 4, kp) = ab(i, 4, kp) + c4k*y4pb
        ab(i, 4, k) = ab(i, 4, k) + c4k*x4pb + s4k*y4pb
        ab(i, 4, kp) = ab(i, 4, kp) - s4k*x4pb
        ab(i, 3, kp) = ab(i, 3, kp) + c3k*y3pb
        ab(i, 3, k) = ab(i, 3, k) + c3k*x3pb + s3k*y3pb
        ab(i, 3, kp) = ab(i, 3, kp) - s3k*x3pb
        ab(i, 2, kp) = ab(i, 2, kp) + c2k*y2pb
        ab(i, 2, k) = ab(i, 2, k) + c2k*x2pb + s2k*y2pb
        ab(i, 2, kp) = ab(i, 2, kp) - s2k*x2pb
        ab(i, 1, kp) = ab(i, 1, kp) + ck*y1pb
        ab(i, 1, k) = ab(i, 1, k) + ck*x1pb + sk*y1pb
        ab(i, 1, kp) = ab(i, 1, kp) - sk*x1pb
      END DO
    END DO
  END IF
  DO i=p-1,0,-1
    t3b = -bb(i, 0, 4)
    t4b = -(s36s72*bb(i, 0, 4))
    bb(i, 0, 4) = 0.D0
    t4b = t4b + bb(i, 0, 3)
    t3b = t3b - s36s72*bb(i, 0, 3)
    bb(i, 0, 3) = 0.D0
    t7b = bb(i, 0, 2)
    t6b = -bb(i, 0, 2)
    bb(i, 0, 2) = 0.D0
    t7b = t7b + bb(i, 0, 1)
    t6b = t6b + bb(i, 0, 1)
    bb(i, 0, 1) = 0.D0
    ab(i, 0, 0) = ab(i, 0, 0) + t7b + bb(i, 0, 0)
    t5b = bb(i, 0, 0) - 0.25d0*t7b
    bb(i, 0, 0) = 0.D0
    t1b = t5b + r54*t6b
    t2b = t5b - r54*t6b
    ab(i, 2, 0) = ab(i, 2, 0) + sin72*t4b
    ab(i, 3, 0) = ab(i, 3, 0) - sin72*t4b
    ab(i, 1, 0) = ab(i, 1, 0) + sin72*t3b
    ab(i, 4, 0) = ab(i, 4, 0) - sin72*t3b
    ab(i, 2, 0) = ab(i, 2, 0) + t2b
    ab(i, 3, 0) = ab(i, 3, 0) + t2b
    ab(i, 1, 0) = ab(i, 1, 0) + t1b
    ab(i, 4, 0) = ab(i, 4, 0) + t1b
  END DO
END SUBROUTINE C06FPT_B

!  Differentiation of c06fpu in reverse (adjoint) mode:
!   gradient     of useful results: a b
!   with respect to varying inputs: a b
SUBROUTINE C06FPU_B(a, ab, b, bb, p, r, cosine, sine)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     MARK 14 REVISED. IER-696 (DEC 1989).
!
!     Radix four real to Hermitian fast Fourier transform kernel
!
!     Self-sorting, decimation in time
!
!     .. Parameters ..
  DOUBLE PRECISION :: root2i
  PARAMETER (root2i=0.707106781186547524400844362104849d0)
!     .. Scalar Arguments ..
  INTEGER :: p, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:3, 0:r-1), b(0:p-1, 0:r-1, 0:3), cosine&
& (0:r-1, 3), sine(0:r-1, 3)
  DOUBLE PRECISION :: ab(0:p-1, 0:3, 0:r-1), bb(0:p-1, 0:r-1, 0:3)
!     .. Local Scalars ..
  DOUBLE PRECISION :: c2k, c3k, ck, s2k, s3k, sk, t1, t1i, t1r, t2, t2i&
& , t2r, t3i, t3r, t4i, t4r, x1p, x2p, x3p, y1p, y2p, y3p
  DOUBLE PRECISION :: t1b, t1ib, t1rb, t2b, t2ib, t2rb, t3ib, t3rb, t4ib&
& , t4rb, x1pb, x2pb, x3pb, y1pb, y2pb, y3pb
  INTEGER :: i, k, kp, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
  INTEGER :: branch
!
!     Code for general K --
!
  IF (p .LT. (r-1)/2) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
!
!     Code for K=R/2 when R is even --
!
  IF (MOD(r, 2) .EQ. 0) THEN
    r2 = r/2
    DO i=p-1,0,-1
      ab(i, 2, r2) = ab(i, 2, r2) - bb(i, r2, 3)
      t2b = -bb(i, r2, 3)
      bb(i, r2, 3) = 0.D0
      ab(i, 2, r2) = ab(i, 2, r2) + bb(i, r2, 2)
      t2b = t2b - bb(i, r2, 2)
      bb(i, r2, 2) = 0.D0
      ab(i, 0, r2) = ab(i, 0, r2) + bb(i, r2, 1)
      t1b = -bb(i, r2, 1)
      bb(i, r2, 1) = 0.D0
      ab(i, 0, r2) = ab(i, 0, r2) + bb(i, r2, 0)
      t1b = t1b + bb(i, r2, 0)
      bb(i, r2, 0) = 0.D0
      ab(i, 1, r2) = ab(i, 1, r2) + root2i*t2b
      ab(i, 3, r2) = ab(i, 3, r2) + root2i*t2b
      ab(i, 1, r2) = ab(i, 1, r2) + root2i*t1b
      ab(i, 3, r2) = ab(i, 3, r2) - root2i*t1b
    END DO
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    DO i=p-1,0,-1
      DO k=(r-1)/2,1,-1
        t1ib = bb(i, r-k, 3)
        t2ib = bb(i, r-k, 3)
        bb(i, r-k, 3) = 0.D0
        t3ib = -bb(i, k, 3)
        t4rb = -bb(i, k, 3)
        bb(i, k, 3) = 0.D0
        t3ib = t3ib + bb(i, r-k, 2)
        t4rb = t4rb - bb(i, r-k, 2)
        bb(i, r-k, 2) = 0.D0
        t2ib = t2ib + bb(i, k, 2)
        t1ib = t1ib - bb(i, k, 2)
        bb(i, k, 2) = 0.D0
        t1rb = bb(i, r-k, 1)
        t2rb = -bb(i, r-k, 1)
        bb(i, r-k, 1) = 0.D0
        t3rb = bb(i, k, 1)
        t4ib = bb(i, k, 1)
        bb(i, k, 1) = 0.D0
        t3rb = t3rb + bb(i, r-k, 0)
        t4ib = t4ib - bb(i, r-k, 0)
        bb(i, r-k, 0) = 0.D0
        t1rb = t1rb + bb(i, k, 0)
        t2rb = t2rb + bb(i, k, 0)
        bb(i, k, 0) = 0.D0
        y1pb = t2ib + t4ib
        y3pb = t2ib - t4ib
        x1pb = t2rb + t4rb
        x3pb = t2rb - t4rb
        ab(i, 0, r-k) = ab(i, 0, r-k) + t3ib
        y2pb = t1ib - t3ib
        ab(i, 0, k) = ab(i, 0, k) + t3rb
        x2pb = t1rb - t3rb
        ab(i, 0, r-k) = ab(i, 0, r-k) + t1ib
        ab(i, 0, k) = ab(i, 0, k) + t1rb
        ab(i, 3, r-k) = ab(i, 3, r-k) + cosine(k, 3)*y3pb
        ab(i, 3, k) = ab(i, 3, k) + cosine(k, 3)*x3pb + sine(k, 3)*y3pb
        ab(i, 3, r-k) = ab(i, 3, r-k) - sine(k, 3)*x3pb
        ab(i, 2, r-k) = ab(i, 2, r-k) + cosine(k, 2)*y2pb
        ab(i, 2, k) = ab(i, 2, k) + cosine(k, 2)*x2pb + sine(k, 2)*y2pb
        ab(i, 2, r-k) = ab(i, 2, r-k) - sine(k, 2)*x2pb
        ab(i, 1, r-k) = ab(i, 1, r-k) + cosine(k, 1)*y1pb
        ab(i, 1, k) = ab(i, 1, k) + cosine(k, 1)*x1pb + sine(k, 1)*y1pb
        ab(i, 1, r-k) = ab(i, 1, r-k) - sine(k, 1)*x1pb
      END DO
    END DO
  ELSE
    DO k=(r-1)/2,1,-1
      s3k = sine(k, 3)
      c3k = cosine(k, 3)
      kp = r - k
      sk = sine(k, 1)
      s2k = sine(k, 2)
      ck = cosine(k, 1)
      c2k = cosine(k, 2)
      DO i=p-1,0,-1
        t1ib = bb(i, kp, 3)
        t2ib = bb(i, kp, 3)
        bb(i, kp, 3) = 0.D0
        t3ib = -bb(i, k, 3)
        t4rb = -bb(i, k, 3)
        bb(i, k, 3) = 0.D0
        t3ib = t3ib + bb(i, kp, 2)
        t4rb = t4rb - bb(i, kp, 2)
        bb(i, kp, 2) = 0.D0
        t2ib = t2ib + bb(i, k, 2)
        t1ib = t1ib - bb(i, k, 2)
        bb(i, k, 2) = 0.D0
        t1rb = bb(i, kp, 1)
        t2rb = -bb(i, kp, 1)
        bb(i, kp, 1) = 0.D0
        t3rb = bb(i, k, 1)
        t4ib = bb(i, k, 1)
        bb(i, k, 1) = 0.D0
        t3rb = t3rb + bb(i, kp, 0)
        t4ib = t4ib - bb(i, kp, 0)
        bb(i, kp, 0) = 0.D0
        t1rb = t1rb + bb(i, k, 0)
        t2rb = t2rb + bb(i, k, 0)
        bb(i, k, 0) = 0.D0
        y1pb = t2ib + t4ib
        y3pb = t2ib - t4ib
        x1pb = t2rb + t4rb
        x3pb = t2rb - t4rb
        ab(i, 0, kp) = ab(i, 0, kp) + t3ib
        y2pb = t1ib - t3ib
        ab(i, 0, k) = ab(i, 0, k) + t3rb
        x2pb = t1rb - t3rb
        ab(i, 0, kp) = ab(i, 0, kp) + t1ib
        ab(i, 0, k) = ab(i, 0, k) + t1rb
        ab(i, 3, kp) = ab(i, 3, kp) + c3k*y3pb
        ab(i, 3, k) = ab(i, 3, k) + c3k*x3pb + s3k*y3pb
        ab(i, 3, kp) = ab(i, 3, kp) - s3k*x3pb
        ab(i, 2, kp) = ab(i, 2, kp) + c2k*y2pb
        ab(i, 2, k) = ab(i, 2, k) + c2k*x2pb + s2k*y2pb
        ab(i, 2, kp) = ab(i, 2, kp) - s2k*x2pb
        ab(i, 1, kp) = ab(i, 1, kp) + ck*y1pb
        ab(i, 1, k) = ab(i, 1, k) + ck*x1pb + sk*y1pb
        ab(i, 1, kp) = ab(i, 1, kp) - sk*x1pb
      END DO
    END DO
  END IF
  DO i=p-1,0,-1
    ab(i, 3, 0) = ab(i, 3, 0) + bb(i, 0, 3)
    ab(i, 1, 0) = ab(i, 1, 0) - bb(i, 0, 3)
    bb(i, 0, 3) = 0.D0
    t1b = bb(i, 0, 2)
    t2b = -bb(i, 0, 2)
    bb(i, 0, 2) = 0.D0
    ab(i, 0, 0) = ab(i, 0, 0) + bb(i, 0, 1)
    ab(i, 2, 0) = ab(i, 2, 0) - bb(i, 0, 1)
    bb(i, 0, 1) = 0.D0
    t1b = t1b + bb(i, 0, 0)
    t2b = t2b + bb(i, 0, 0)
    bb(i, 0, 0) = 0.D0
    ab(i, 1, 0) = ab(i, 1, 0) + t2b
    ab(i, 3, 0) = ab(i, 3, 0) + t2b
    ab(i, 0, 0) = ab(i, 0, 0) + t1b
    ab(i, 2, 0) = ab(i, 2, 0) + t1b
  END DO
END SUBROUTINE C06FPU_B

!  Differentiation of c06fpv in reverse (adjoint) mode:
!   gradient     of useful results: a b
!   with respect to varying inputs: a b
SUBROUTINE C06FPV_B(a, ab, b, bb, p, r, cosine, sine)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     MARK 14 REVISED. IER-697 (DEC 1989).
!
!     Radix three Real to Hermitian fast Fourier transform kernel
!
!     Self-sorting, decimation in time
!
!     .. Parameters ..
  DOUBLE PRECISION :: sin60
  PARAMETER (sin60=0.866025403784438646763723170752936d0)
!     .. Scalar Arguments ..
  INTEGER :: p, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:2, 0:r-1), b(0:p-1, 0:r-1, 0:2), cosine&
& (0:r-1, 2), sine(0:r-1, 2)
  DOUBLE PRECISION :: ab(0:p-1, 0:2, 0:r-1), bb(0:p-1, 0:r-1, 0:2)
!     .. Local Scalars ..
  DOUBLE PRECISION :: c2k, ck, s2k, sk, t1, t1i, t1r, t2i, t2r, t3i, t3r&
& , x1p, x2p, y1p, y2p
  DOUBLE PRECISION :: t1b, t1ib, t1rb, t2ib, t2rb, t3ib, t3rb, x1pb, &
& x2pb, y1pb, y2pb
  INTEGER :: i, k, kp, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
!
!     Code for general K
!
  IF (p .LE. (r-1)/2) THEN
    DO i=p-1,0,-1
      DO k=(r-1)/2,1,-1
        ab(i, 0, r-k) = ab(i, 0, r-k) + bb(i, r-k, 2)
        t1ib = bb(i, r-k, 2)
        bb(i, r-k, 2) = 0.D0
        t2ib = -bb(i, k, 2)
        t3rb = -bb(i, k, 2)
        bb(i, k, 2) = 0.D0
        t2ib = t2ib + bb(i, r-k, 1)
        t3rb = t3rb - bb(i, r-k, 1)
        bb(i, r-k, 1) = 0.D0
        t2rb = bb(i, k, 1)
        t3ib = bb(i, k, 1)
        bb(i, k, 1) = 0.D0
        t2rb = t2rb + bb(i, r-k, 0)
        t3ib = t3ib - bb(i, r-k, 0)
        bb(i, r-k, 0) = 0.D0
        ab(i, 0, k) = ab(i, 0, k) + bb(i, k, 0)
        t1rb = bb(i, k, 0) - 0.5d0*t2rb
        bb(i, k, 0) = 0.D0
        x1pb = t1rb + sin60*t3rb
        x2pb = t1rb - sin60*t3rb
        ab(i, 0, r-k) = ab(i, 0, r-k) + t2ib
        t1ib = t1ib - 0.5d0*t2ib
        y1pb = t1ib + sin60*t3ib
        y2pb = t1ib - sin60*t3ib
        ab(i, 0, k) = ab(i, 0, k) + t2rb
        ab(i, 2, r-k) = ab(i, 2, r-k) + cosine(k, 2)*y2pb
        ab(i, 2, k) = ab(i, 2, k) + cosine(k, 2)*x2pb + sine(k, 2)*y2pb
        ab(i, 2, r-k) = ab(i, 2, r-k) - sine(k, 2)*x2pb
        ab(i, 1, r-k) = ab(i, 1, r-k) + cosine(k, 1)*y1pb
        ab(i, 1, k) = ab(i, 1, k) + cosine(k, 1)*x1pb + sine(k, 1)*y1pb
        ab(i, 1, r-k) = ab(i, 1, r-k) - sine(k, 1)*x1pb
      END DO
    END DO
  ELSE
    DO k=(r-1)/2,1,-1
      kp = r - k
      sk = sine(k, 1)
      s2k = sine(k, 2)
      ck = cosine(k, 1)
      c2k = cosine(k, 2)
      DO i=p-1,0,-1
        ab(i, 0, kp) = ab(i, 0, kp) + bb(i, kp, 2)
        t1ib = bb(i, kp, 2)
        bb(i, kp, 2) = 0.D0
        t2ib = -bb(i, k, 2)
        t3rb = -bb(i, k, 2)
        bb(i, k, 2) = 0.D0
        t2ib = t2ib + bb(i, kp, 1)
        t3rb = t3rb - bb(i, kp, 1)
        bb(i, kp, 1) = 0.D0
        t2rb = bb(i, k, 1)
        t3ib = bb(i, k, 1)
        bb(i, k, 1) = 0.D0
        t2rb = t2rb + bb(i, kp, 0)
        t3ib = t3ib - bb(i, kp, 0)
        bb(i, kp, 0) = 0.D0
        ab(i, 0, k) = ab(i, 0, k) + bb(i, k, 0)
        t1rb = bb(i, k, 0) - 0.5d0*t2rb
        bb(i, k, 0) = 0.D0
        x1pb = t1rb + sin60*t3rb
        x2pb = t1rb - sin60*t3rb
        ab(i, 0, kp) = ab(i, 0, kp) + t2ib
        t1ib = t1ib - 0.5d0*t2ib
        y1pb = t1ib + sin60*t3ib
        y2pb = t1ib - sin60*t3ib
        ab(i, 0, k) = ab(i, 0, k) + t2rb
        ab(i, 2, kp) = ab(i, 2, kp) + c2k*y2pb
        ab(i, 2, k) = ab(i, 2, k) + c2k*x2pb + s2k*y2pb
        ab(i, 2, kp) = ab(i, 2, kp) - s2k*x2pb
        ab(i, 1, kp) = ab(i, 1, kp) + ck*y1pb
        ab(i, 1, k) = ab(i, 1, k) + ck*x1pb + sk*y1pb
        ab(i, 1, kp) = ab(i, 1, kp) - sk*x1pb
      END DO
    END DO
  END IF
  DO i=p-1,0,-1
    ab(i, 1, 0) = ab(i, 1, 0) - sin60*bb(i, 0, 2)
    ab(i, 2, 0) = ab(i, 2, 0) + sin60*bb(i, 0, 2)
    bb(i, 0, 2) = 0.D0
    ab(i, 0, 0) = ab(i, 0, 0) + bb(i, 0, 1)
    t1b = -(0.5d0*bb(i, 0, 1))
    bb(i, 0, 1) = 0.D0
    ab(i, 0, 0) = ab(i, 0, 0) + bb(i, 0, 0)
    t1b = t1b + bb(i, 0, 0)
    bb(i, 0, 0) = 0.D0
    ab(i, 1, 0) = ab(i, 1, 0) + t1b
    ab(i, 2, 0) = ab(i, 2, 0) + t1b
  END DO
END SUBROUTINE C06FPV_B

!  Differentiation of c06fpw in reverse (adjoint) mode:
!   gradient     of useful results: a b
!   with respect to varying inputs: a b
SUBROUTINE C06FPW_B(a, ab, b, bb, p, r, cosine, sine)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     MARK 14 REVISED. IER-698 (DEC 1989).
!
!     Radix two Real to Hermitian fast Fourier transform kernel
!
!     Self-sorting, decimation in time
!
!     .. Scalar Arguments ..
  INTEGER :: p, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:1, 0:r-1), b(0:p-1, 0:r-1, 0:1), cosine&
& (0:r-1), sine(0:r-1)
  DOUBLE PRECISION :: ab(0:p-1, 0:1, 0:r-1), bb(0:p-1, 0:r-1, 0:1)
!     .. Local Scalars ..
  DOUBLE PRECISION :: ck, sk, x1, y1
  DOUBLE PRECISION :: x1b, y1b
  INTEGER :: i, k, kp, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
!
!     Code for general K
!
  IF (p .LT. (r-1)/2) THEN
    DO i=p-1,0,-1
      DO k=(r-1)/2,1,-1
        ab(i, 0, r-k) = ab(i, 0, r-k) + bb(i, r-k, 1)
        y1b = bb(i, r-k, 1)
        bb(i, r-k, 1) = 0.D0
        y1b = y1b + bb(i, k, 1)
        ab(i, 0, r-k) = ab(i, 0, r-k) - bb(i, k, 1)
        bb(i, k, 1) = 0.D0
        ab(i, 0, k) = ab(i, 0, k) + bb(i, r-k, 0)
        x1b = -bb(i, r-k, 0)
        bb(i, r-k, 0) = 0.D0
        ab(i, 0, k) = ab(i, 0, k) + bb(i, k, 0)
        x1b = x1b + bb(i, k, 0)
        bb(i, k, 0) = 0.D0
        ab(i, 1, r-k) = ab(i, 1, r-k) + cosine(k)*y1b
        ab(i, 1, k) = ab(i, 1, k) + cosine(k)*x1b + sine(k)*y1b
        ab(i, 1, r-k) = ab(i, 1, r-k) - sine(k)*x1b
      END DO
    END DO
  ELSE
    DO k=(r-1)/2,1,-1
      kp = r - k
      sk = sine(k)
      ck = cosine(k)
      DO i=p-1,0,-1
        ab(i, 0, kp) = ab(i, 0, kp) + bb(i, kp, 1)
        y1b = bb(i, kp, 1)
        bb(i, kp, 1) = 0.D0
        y1b = y1b + bb(i, k, 1)
        ab(i, 0, kp) = ab(i, 0, kp) - bb(i, k, 1)
        bb(i, k, 1) = 0.D0
        ab(i, 0, k) = ab(i, 0, k) + bb(i, kp, 0)
        x1b = -bb(i, kp, 0)
        bb(i, kp, 0) = 0.D0
        ab(i, 0, k) = ab(i, 0, k) + bb(i, k, 0)
        x1b = x1b + bb(i, k, 0)
        bb(i, k, 0) = 0.D0
        ab(i, 1, kp) = ab(i, 1, kp) + ck*y1b
        ab(i, 1, k) = ab(i, 1, k) + ck*x1b + sk*y1b
        ab(i, 1, kp) = ab(i, 1, kp) - sk*x1b
      END DO
    END DO
  END IF
  DO i=p-1,0,-1
    ab(i, 0, 0) = ab(i, 0, 0) + bb(i, 0, 1)
    ab(i, 1, 0) = ab(i, 1, 0) - bb(i, 0, 1)
    bb(i, 0, 1) = 0.D0
    ab(i, 0, 0) = ab(i, 0, 0) + bb(i, 0, 0)
    ab(i, 1, 0) = ab(i, 1, 0) + bb(i, 0, 0)
    bb(i, 0, 0) = 0.D0
  END DO
END SUBROUTINE C06FPW_B

!  Differentiation of c06fqf in reverse (adjoint) mode:
!   gradient     of useful results: x work
!   with respect to varying inputs: x work
SUBROUTINE C06FQF_B(m, n, x, xb, init, trig, work, workb, ifail)
  IMPLICIT NONE
!VD$R NOVECTOR
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     .. Parameters ..
  CHARACTER(len=6) :: srname
  PARAMETER (srname='C06FQF')
!     .. Scalar Arguments ..
  INTEGER :: ifail, m, n
  CHARACTER(len=1) :: init
!     .. Array Arguments ..
  DOUBLE PRECISION :: trig(2*n), work(m*n), x(m*n)
  DOUBLE PRECISION :: workb(m*n), xb(m*n)
!     .. Local Scalars ..
  INTEGER :: ierror, nq, nrec
!     .. Local Arrays ..
  INTEGER :: q(30)
  CHARACTER(len=80) :: rec(1)
  EXTERNAL P01ABF
!     .. External Functions ..
  INTEGER :: P01ABF
!     .. External Subroutines ..
  EXTERNAL C06FPQ, C06FQX
  EXTERNAL C06FQX_B
!     .. Executable Statements ..
  CALL C06FPQ(m, n, init, trig, q, nq, ierror)
  IF (ierror .EQ. 0) CALL C06FQX_B(x, xb, work, workb, m, n, q, nq, trig&
&                           )
!
99999 FORMAT(' ** M must be at least 1: M = ',i16)
99998 FORMAT(' ** N must be at least 1: N = ',i16)
99997 FORMAT(' ** ',a1,' is an invalid value of INIT')
99996 FORMAT(' ** INIT = ',a1,', but TRIG array never initialized')
99995 FORMAT(' ** INIT = ',a1,', but N and TRIG array incompatible')
END SUBROUTINE C06FQF_B

!  Differentiation of c06fqx in reverse (adjoint) mode:
!   gradient     of useful results: a b
!   with respect to varying inputs: a b
SUBROUTINE C06FQX_B(a, ab, b, bb, m, n, q, nq, trig)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!
!     Hermitian to Real Fast Fourier Transform Kernel Driver
!
!     Self-sorting, decimation in frequency
!
!     .. Scalar Arguments ..
  INTEGER :: m, n, nq
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:m*n-1), b(0:m*n-1), trig(0:2*n-1)
  DOUBLE PRECISION :: ab(0:m*n-1), bb(0:m*n-1)
  INTEGER :: q(nq)
!     .. Local Scalars ..
  DOUBLE PRECISION :: factor
  INTEGER :: i, p, qi, r
  LOGICAL :: ina
!     .. External Subroutines ..
  EXTERNAL C06FQQ, C06FQR, C06FQS, C06FQT, C06FQU, C06FQV, C06FQW
  EXTERNAL C06FQQ_B, C06FQR_B, C06FQS_B, C06FQT_B, C06FQU_B, C06FQV_B, &
&     C06FQW_B
!     .. Intrinsic Functions ..
  INTRINSIC SQRT, DBLE
  INTEGER :: arg1
  INTEGER :: branch
!     .. Executable Statements ..
  ina = .true.
  p = 1
  r = n
  IF (n .NE. 1) THEN
    DO i=1,nq
      qi = q(i)
      CALL PUSHINTEGER4(r)
      r = r/qi
      IF (ina) THEN
        IF (qi .EQ. 2) THEN
          CALL PUSHINTEGER4(arg1)
          arg1 = m*p
          CALL PUSHCONTROL4B(0)
        ELSE IF (qi .EQ. 3) THEN
          CALL PUSHINTEGER4(arg1)
          arg1 = m*p
          CALL PUSHCONTROL4B(1)
        ELSE IF (qi .EQ. 4) THEN
          CALL PUSHINTEGER4(arg1)
          arg1 = m*p
          CALL PUSHCONTROL4B(2)
        ELSE IF (qi .EQ. 5) THEN
          CALL PUSHINTEGER4(arg1)
          arg1 = m*p
          CALL PUSHCONTROL4B(3)
        ELSE IF (qi .EQ. 6) THEN
          CALL PUSHINTEGER4(arg1)
          arg1 = m*p
          CALL PUSHCONTROL4B(4)
        ELSE
          CALL PUSHINTEGER4(arg1)
          arg1 = m*p
          CALL PUSHCONTROL4B(5)
        END IF
      ELSE IF (qi .EQ. 2) THEN
        CALL PUSHINTEGER4(arg1)
        arg1 = m*p
        CALL PUSHCONTROL4B(6)
      ELSE IF (qi .EQ. 3) THEN
        CALL PUSHINTEGER4(arg1)
        arg1 = m*p
        CALL PUSHCONTROL4B(7)
      ELSE IF (qi .EQ. 4) THEN
        CALL PUSHINTEGER4(arg1)
        arg1 = m*p
        CALL PUSHCONTROL4B(8)
      ELSE IF (qi .EQ. 5) THEN
        CALL PUSHINTEGER4(arg1)
        arg1 = m*p
        CALL PUSHCONTROL4B(9)
      ELSE IF (qi .EQ. 6) THEN
        CALL PUSHINTEGER4(arg1)
        arg1 = m*p
        CALL PUSHCONTROL4B(10)
      ELSE
        CALL PUSHINTEGER4(arg1)
        arg1 = m*p
        CALL PUSHCONTROL4B(11)
      END IF
      ina = .NOT.ina
      CALL PUSHINTEGER4(p)
      p = p*qi
    END DO
!
    factor = 2.0d0/SQRT(DBLE(n))
    IF (ina) THEN
      DO i=m*n-1,0,-1
        ab(i) = factor*ab(i)
      END DO
    ELSE
      DO i=m*n-1,0,-1
        bb(i) = bb(i) + factor*ab(i)
        ab(i) = 0.D0
      END DO
    END IF
    DO i=nq,1,-1
      qi = q(i)
      CALL POPINTEGER4(p)
      CALL POPCONTROL4B(branch)
      IF (branch .LT. 6) THEN
        IF (branch .LT. 3) THEN
          IF (branch .EQ. 0) THEN
            CALL C06FQW_B(a, ab, b, bb, arg1, r, trig((p-1)*qi*r), trig(&
&                   n+(p-1)*qi*r))
            CALL POPINTEGER4(arg1)
          ELSE IF (branch .EQ. 1) THEN
            CALL C06FQV_B(a, ab, b, bb, arg1, r, trig((p-1)*qi*r), trig(&
&                   n+(p-1)*qi*r))
            CALL POPINTEGER4(arg1)
          ELSE
            CALL C06FQU_B(a, ab, b, bb, arg1, r, trig((p-1)*qi*r), trig(&
&                   n+(p-1)*qi*r))
            CALL POPINTEGER4(arg1)
          END IF
        ELSE IF (branch .EQ. 3) THEN
          CALL C06FQT_B(a, ab, b, bb, arg1, r, trig((p-1)*qi*r), trig(n+&
&                 (p-1)*qi*r))
          CALL POPINTEGER4(arg1)
        ELSE IF (branch .EQ. 4) THEN
          CALL C06FQS_B(a, ab, b, bb, arg1, r, trig((p-1)*qi*r), trig(n+&
&                 (p-1)*qi*r))
          CALL POPINTEGER4(arg1)
        ELSE
          CALL C06FQR_B(a, ab, b, bb, arg1, qi, r, trig((p-1)*qi*r), &
&                 trig(n+(p-1)*qi*r))
          CALL POPINTEGER4(arg1)
        END IF
      ELSE IF (branch .LT. 9) THEN
        IF (branch .EQ. 6) THEN
          CALL C06FQW_B(b, bb, a, ab, arg1, r, trig((p-1)*qi*r), trig(n+&
&                 (p-1)*qi*r))
          CALL POPINTEGER4(arg1)
        ELSE IF (branch .EQ. 7) THEN
          CALL C06FQV_B(b, bb, a, ab, arg1, r, trig((p-1)*qi*r), trig(n+&
&                 (p-1)*qi*r))
          CALL POPINTEGER4(arg1)
        ELSE
          CALL C06FQU_B(b, bb, a, ab, arg1, r, trig((p-1)*qi*r), trig(n+&
&                 (p-1)*qi*r))
          CALL POPINTEGER4(arg1)
        END IF
      ELSE IF (branch .EQ. 9) THEN
        CALL C06FQT_B(b, bb, a, ab, arg1, r, trig((p-1)*qi*r), trig(n+(p&
&               -1)*qi*r))
        CALL POPINTEGER4(arg1)
      ELSE IF (branch .EQ. 10) THEN
        CALL C06FQS_B(b, bb, a, ab, arg1, r, trig((p-1)*qi*r), trig(n+(p&
&               -1)*qi*r))
        CALL POPINTEGER4(arg1)
      ELSE
        CALL C06FQR_B(b, bb, a, ab, arg1, qi, r, trig((p-1)*qi*r), trig(&
&               n+(p-1)*qi*r))
        CALL POPINTEGER4(arg1)
      END IF
      CALL POPINTEGER4(r)
    END DO
    CALL C06FQQ_B(a, ab, m, n)
  END IF
END SUBROUTINE C06FQX_B

!  Differentiation of c06fqq in reverse (adjoint) mode:
!   gradient     of useful results: a
!   with respect to varying inputs: a
SUBROUTINE C06FQQ_B(a, ab, m, n)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     .. Scalar Arguments ..
  INTEGER :: m, n
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:m-1, 0:n-1)
  DOUBLE PRECISION :: ab(0:m-1, 0:n-1)
!     .. Local Scalars ..
  INTEGER :: l
!     .. Intrinsic Functions ..
  INTRINSIC MOD
  IF (MOD(n, 2) .EQ. 0) THEN
    DO l=m-1,0,-1
      ab(l, n/2) = 0.5d0*ab(l, n/2)
    END DO
  END IF
  DO l=m-1,0,-1
    ab(l, 0) = 0.5d0*ab(l, 0)
  END DO
END SUBROUTINE C06FQQ_B

!  Differentiation of c06fqr in reverse (adjoint) mode:
!   gradient     of useful results: a b
!   with respect to varying inputs: a b
SUBROUTINE C06FQR_B(a, ab, b, bb, p, q, r, cosine, sine)
  IMPLICIT NONE
!     MARK 15 RE-ISSUE. NAG COPYRIGHT 1991.
!
!     Hermitian to real fast Fourier transform kernel
!     Odd factors greater than 6
!
!     Self-sorting, decimation in frequency
!
!     .. Scalar Arguments ..
  INTEGER :: p, q, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:r-1, 0:q-1), b(0:p-1, 0:q-1, 0:r-1), &
& cosine(0:r-1, q-1), sine(0:r-1, q-1)
  DOUBLE PRECISION :: ab(0:p-1, 0:r-1, 0:q-1), bb(0:p-1, 0:q-1, 0:r-1)
!     .. Local Scalars ..
  DOUBLE PRECISION :: bi, br, temp, temp1, tempi, tempr
  DOUBLE PRECISION :: bib, brb, tempb, temp1b, tempib, temprb
  INTEGER :: i, indx, j, k, kp, l, q2, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
  DOUBLE PRECISION :: tmp
  DOUBLE PRECISION :: tmpb
  DOUBLE PRECISION :: tmp0
  DOUBLE PRECISION :: tmp1
  DOUBLE PRECISION :: tmp2
  DOUBLE PRECISION :: tmpb0
  DOUBLE PRECISION :: tmpb1
  DOUBLE PRECISION :: tmpb2
  DOUBLE PRECISION :: tmp3
  DOUBLE PRECISION :: tmpb3
  DOUBLE PRECISION :: tmp4
  DOUBLE PRECISION :: tmp5
  DOUBLE PRECISION :: tmp6
  DOUBLE PRECISION :: tmpb4
  DOUBLE PRECISION :: tmpb5
  DOUBLE PRECISION :: tmpb6
  INTEGER :: branch
!     .. Executable Statements ..
!
  q2 = (q-1)/2
  IF (p .GE. r/2) THEN
!
!        Code for K=0 --
!
    DO l=1,q2
      DO j=1,q2
        CALL PUSHINTEGER4(indx)
        indx = MOD(j*l, q)
      END DO
    END DO
!
!        Code for general K --
!
    DO k=1,(r-1)/2
      DO l=1,q2
        DO j=1,q2
          CALL PUSHINTEGER4(indx)
          indx = MOD(j*l, q)
        END DO
      END DO
    END DO
!
!        Code for K=R/2 when R is even --
!
    IF (MOD(r, 2) .EQ. 0) THEN
      r2 = r/2
      DO l=1,q2
        DO j=0,q2-1
          CALL PUSHINTEGER4(indx)
          indx = MOD(l*(j+q2+1), q)
        END DO
      END DO
      IF (MOD(q2, 2) .EQ. 1) THEN
        DO i=p-1,0,-1
          temprb = bb(i, q2+1, r2)
          tempib = bb(i, q2+1, r2)
          bb(i, q2+1, r2) = 0.D0
          tempib = tempib + bb(i, q2, r2)
          temprb = temprb - bb(i, q2, r2)
          bb(i, q2, r2) = 0.D0
          bb(i, q2+1, r2) = bb(i, q2+1, r2) + tempib
          bb(i, q2, r2) = bb(i, q2, r2) + temprb
        END DO
      END IF
      DO j=q2-MOD(q2-2, 2)-1,1,-2
        DO i=p-1,0,-1
          temprb = -bb(i, q-j-1, r2)
          tempib = -bb(i, q-j-1, r2)
          bb(i, q-j-1, r2) = 0.D0
          temprb = temprb + bb(i, j+1, r2)
          tempib = tempib - bb(i, j+1, r2)
          bb(i, j+1, r2) = 0.D0
          bb(i, q-j-1, r2) = bb(i, q-j-1, r2) + tempib
          bb(i, j+1, r2) = bb(i, j+1, r2) + temprb
          temprb = bb(i, q-j, r2)
          tempib = bb(i, q-j, r2)
          bb(i, q-j, r2) = 0.D0
          tempib = tempib + bb(i, j, r2)
          temprb = temprb - bb(i, j, r2)
          bb(i, j, r2) = 0.D0
          bb(i, q-j, r2) = bb(i, q-j, r2) + tempib
          bb(i, j, r2) = bb(i, j, r2) + temprb
        END DO
      END DO
      DO j=q2-1,0,-1
        DO i=p-1,0,-1
          ab(i, r2, j) = ab(i, r2, j) + bb(i, 0, r2)
        END DO
      END DO
      DO i=p-1,0,-1
        ab(i, r2, q2) = ab(i, r2, q2) + bb(i, 0, r2)
        bb(i, 0, r2) = 0.D0
      END DO
      DO l=q2,1,-1
        DO j=q2-1,0,-1
          DO i=p-1,0,-1
            ab(i, r2, q-j-1) = ab(i, r2, q-j-1) + sine(0, indx)*bb(i, q-&
&             l, r2)
            ab(i, r2, j) = ab(i, r2, j) + cosine(0, indx)*bb(i, l, r2)
          END DO
          CALL POPINTEGER4(indx)
        END DO
      END DO
      DO l=q2,1,-1
        DO i=p-1,0,-1
          bb(i, q-l, r2) = 0.D0
          ab(i, r2, q2) = ab(i, r2, q2) + bb(i, l, r2)
          bb(i, l, r2) = 0.D0
        END DO
      END DO
    END IF
    DO k=(r-1)/2,1,-1
      kp = r - k
      DO j=q-1,1,-1
        DO i=p-1,0,-1
          bib = cosine(k, j)*bb(i, j, kp)
          brb = sine(k, j)*bb(i, j, kp)
          bb(i, j, kp) = 0.D0
          brb = brb + cosine(k, j)*bb(i, j, k)
          bib = bib - sine(k, j)*bb(i, j, k)
          bb(i, j, k) = 0.D0
          bb(i, j, kp) = bb(i, j, kp) + bib
          bb(i, j, k) = bb(i, j, k) + brb
        END DO
      END DO
      DO j=q2,1,-1
        DO i=p-1,0,-1
          tempib = bb(i, q-j, kp)
          temp1b = -bb(i, q-j, kp)
          bb(i, q-j, kp) = 0.D0
          tmpb0 = bb(i, q-j, k)
          bb(i, q-j, k) = 0.D0
          bb(i, q-j, kp) = bb(i, q-j, kp) + tmpb0
          bb(i, q-j, k) = bb(i, q-j, k) + temp1b
          tmpb2 = bb(i, j, kp)
          bb(i, j, kp) = 0.D0
          tempib = tempib + tmpb2
          bb(i, q-j, k) = bb(i, q-j, k) + tmpb2
          tmpb1 = bb(i, j, k)
          temprb = tmpb1 + tmpb0
          bb(i, j, k) = 0.D0
          bb(i, q-j, kp) = bb(i, q-j, kp) - tmpb1
          bb(i, j, kp) = bb(i, j, kp) + tempib
          bb(i, j, k) = bb(i, j, k) + temprb
        END DO
      END DO
      DO j=q2,1,-1
        DO i=p-1,0,-1
          ab(i, kp, q-j-1) = ab(i, kp, q-j-1) + bb(i, 0, kp)
          ab(i, k, j) = ab(i, k, j) + bb(i, 0, k)
        END DO
      END DO
      DO i=p-1,0,-1
        ab(i, kp, q-1) = ab(i, kp, q-1) + bb(i, 0, kp)
        bb(i, 0, kp) = 0.D0
        ab(i, k, 0) = ab(i, k, 0) + bb(i, 0, k)
        bb(i, 0, k) = 0.D0
      END DO
      DO l=q2,1,-1
        DO j=q2,1,-1
          DO i=p-1,0,-1
            ab(i, k, q-j) = ab(i, k, q-j) - sine(0, indx)*bb(i, q-l, kp)
            ab(i, kp, j-1) = ab(i, kp, j-1) + sine(0, indx)*bb(i, q-l, k&
&             )
            ab(i, kp, q-j-1) = ab(i, kp, q-j-1) + cosine(0, indx)*bb(i, &
&             l, kp)
            ab(i, k, j) = ab(i, k, j) + cosine(0, indx)*bb(i, l, k)
          END DO
          CALL POPINTEGER4(indx)
        END DO
        DO i=p-1,0,-1
          bb(i, q-l, kp) = 0.D0
          bb(i, q-l, k) = 0.D0
          ab(i, kp, q-1) = ab(i, kp, q-1) + bb(i, l, kp)
          bb(i, l, kp) = 0.D0
          ab(i, k, 0) = ab(i, k, 0) + bb(i, l, k)
          bb(i, l, k) = 0.D0
        END DO
      END DO
      DO j=q2,1,-1
        DO i=p-1,0,-1
          tempib = -ab(i, k, q-j)
          ab(i, k, q-j) = -ab(i, k, q-j)
          temprb = ab(i, kp, j-1)
          ab(i, kp, j-1) = -ab(i, kp, j-1)
          tempib = tempib + ab(i, kp, q-j-1)
          ab(i, k, q-j) = ab(i, k, q-j) - ab(i, kp, q-j-1)
          ab(i, kp, q-j-1) = 0.D0
          temprb = temprb + ab(i, k, j)
          ab(i, kp, j-1) = ab(i, kp, j-1) + ab(i, k, j)
          ab(i, k, j) = 0.D0
          ab(i, kp, q-j-1) = ab(i, kp, q-j-1) + tempib
          ab(i, k, j) = ab(i, k, j) + temprb
        END DO
      END DO
    END DO
    DO j=q2,1,-1
      DO i=p-1,0,-1
        tempb = bb(i, q-j, 0)
        bb(i, q-j, 0) = -bb(i, q-j, 0)
        tmpb = bb(i, j, 0)
        bb(i, j, 0) = tmpb
        bb(i, q-j, 0) = bb(i, q-j, 0) + tmpb
        bb(i, j, 0) = bb(i, j, 0) + tempb
      END DO
    END DO
    DO j=q2,1,-1
      DO i=p-1,0,-1
        ab(i, 0, j) = ab(i, 0, j) + bb(i, 0, 0)
      END DO
    END DO
    DO i=p-1,0,-1
      ab(i, 0, 0) = ab(i, 0, 0) + bb(i, 0, 0)
      bb(i, 0, 0) = 0.D0
    END DO
    DO l=q2,1,-1
      DO j=q2,1,-1
        DO i=p-1,0,-1
          ab(i, 0, q-j) = ab(i, 0, q-j) - sine(0, indx)*bb(i, q-l, 0)
          ab(i, 0, j) = ab(i, 0, j) + cosine(0, indx)*bb(i, l, 0)
        END DO
        CALL POPINTEGER4(indx)
      END DO
      DO i=p-1,0,-1
        bb(i, q-l, 0) = 0.D0
        ab(i, 0, 0) = ab(i, 0, 0) + bb(i, l, 0)
        bb(i, l, 0) = 0.D0
      END DO
    END DO
  ELSE
!
!
    DO i=0,p-1
!
!           Code for K=0 --
!
      DO l=1,q2
        DO j=1,q2
          CALL PUSHINTEGER4(indx)
          indx = MOD(j*l, q)
        END DO
      END DO
      DO l=1,q2
        DO j=1,q2
          CALL PUSHINTEGER4(indx)
          indx = MOD(j*l, q)
        END DO
      END DO
!
!           Code for K=R/2 when R is even --
!
      IF (MOD(r, 2) .EQ. 0) THEN
        CALL PUSHINTEGER4(r2)
        r2 = r/2
        DO l=1,q2
          DO j=0,q2-1
            CALL PUSHINTEGER4(indx)
            indx = MOD(l*(j+q2+1), q)
          END DO
        END DO
        IF (MOD(q2, 2) .EQ. 1) THEN
          CALL PUSHCONTROL2B(0)
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(2)
      END IF
    END DO
    DO i=p-1,0,-1
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        r2 = r/2
        temprb = bb(i, q2+1, r2)
        tempib = bb(i, q2+1, r2)
        bb(i, q2+1, r2) = 0.D0
        tempib = tempib + bb(i, q2, r2)
        temprb = temprb - bb(i, q2, r2)
        bb(i, q2, r2) = 0.D0
        bb(i, q2+1, r2) = bb(i, q2+1, r2) + tempib
        bb(i, q2, r2) = bb(i, q2, r2) + temprb
      ELSE IF (branch .NE. 1) THEN
        GOTO 100
      END IF
      DO j=q2-MOD(q2-2, 2)-1,1,-2
        temprb = -bb(i, q-j-1, r2)
        tempib = -bb(i, q-j-1, r2)
        bb(i, q-j-1, r2) = 0.D0
        temprb = temprb + bb(i, j+1, r2)
        tempib = tempib - bb(i, j+1, r2)
        bb(i, j+1, r2) = 0.D0
        bb(i, q-j-1, r2) = bb(i, q-j-1, r2) + tempib
        bb(i, j+1, r2) = bb(i, j+1, r2) + temprb
        temprb = bb(i, q-j, r2)
        tempib = bb(i, q-j, r2)
        bb(i, q-j, r2) = 0.D0
        tempib = tempib + bb(i, j, r2)
        temprb = temprb - bb(i, j, r2)
        bb(i, j, r2) = 0.D0
        bb(i, q-j, r2) = bb(i, q-j, r2) + tempib
        bb(i, j, r2) = bb(i, j, r2) + temprb
      END DO
      DO j=q2-1,0,-1
        ab(i, r2, j) = ab(i, r2, j) + bb(i, 0, r2)
      END DO
      ab(i, r2, q2) = ab(i, r2, q2) + bb(i, 0, r2)
      bb(i, 0, r2) = 0.D0
      DO l=q2,1,-1
        DO j=q2-1,0,-1
          ab(i, r2, q-j-1) = ab(i, r2, q-j-1) + sine(0, indx)*bb(i, q-l&
&           , r2)
          ab(i, r2, j) = ab(i, r2, j) + cosine(0, indx)*bb(i, l, r2)
          CALL POPINTEGER4(indx)
        END DO
      END DO
      DO l=q2,1,-1
        bb(i, q-l, r2) = 0.D0
        ab(i, r2, q2) = ab(i, r2, q2) + bb(i, l, r2)
        bb(i, l, r2) = 0.D0
      END DO
      CALL POPINTEGER4(r2)
 100  DO j=q-1,1,-1
        DO k=(r-1)/2,1,-1
          bib = cosine(k, j)*bb(i, j, r-k)
          brb = sine(k, j)*bb(i, j, r-k)
          bb(i, j, r-k) = 0.D0
          brb = brb + cosine(k, j)*bb(i, j, k)
          bib = bib - sine(k, j)*bb(i, j, k)
          bb(i, j, k) = 0.D0
          bb(i, j, r-k) = bb(i, j, r-k) + bib
          bb(i, j, k) = bb(i, j, k) + brb
        END DO
      END DO
      DO j=q2,1,-1
        DO k=(r-1)/2,1,-1
          tempib = bb(i, q-j, r-k)
          temp1b = -bb(i, q-j, r-k)
          bb(i, q-j, r-k) = 0.D0
          tmpb4 = bb(i, q-j, k)
          bb(i, q-j, k) = 0.D0
          bb(i, q-j, r-k) = bb(i, q-j, r-k) + tmpb4
          bb(i, q-j, k) = bb(i, q-j, k) + temp1b
          tmpb6 = bb(i, j, r-k)
          bb(i, j, r-k) = 0.D0
          tempib = tempib + tmpb6
          bb(i, q-j, k) = bb(i, q-j, k) + tmpb6
          tmpb5 = bb(i, j, k)
          temprb = tmpb5 + tmpb4
          bb(i, j, k) = 0.D0
          bb(i, q-j, r-k) = bb(i, q-j, r-k) - tmpb5
          bb(i, j, r-k) = bb(i, j, r-k) + tempib
          bb(i, j, k) = bb(i, j, k) + temprb
        END DO
      END DO
      DO j=q2,1,-1
        DO k=(r-1)/2,1,-1
          ab(i, r-k, q-j-1) = ab(i, r-k, q-j-1) + bb(i, 0, r-k)
          ab(i, k, j) = ab(i, k, j) + bb(i, 0, k)
        END DO
      END DO
      DO k=(r-1)/2,1,-1
        ab(i, r-k, q-1) = ab(i, r-k, q-1) + bb(i, 0, r-k)
        bb(i, 0, r-k) = 0.D0
        ab(i, k, 0) = ab(i, k, 0) + bb(i, 0, k)
        bb(i, 0, k) = 0.D0
      END DO
      DO l=q2,1,-1
        DO j=q2,1,-1
          DO k=(r-1)/2,1,-1
            ab(i, k, q-j) = ab(i, k, q-j) - sine(0, indx)*bb(i, q-l, r-k&
&             )
            ab(i, r-k, j-1) = ab(i, r-k, j-1) + sine(0, indx)*bb(i, q-l&
&             , k)
            ab(i, r-k, q-j-1) = ab(i, r-k, q-j-1) + cosine(0, indx)*bb(i&
&             , l, r-k)
            ab(i, k, j) = ab(i, k, j) + cosine(0, indx)*bb(i, l, k)
          END DO
          CALL POPINTEGER4(indx)
        END DO
        DO k=(r-1)/2,1,-1
          bb(i, q-l, r-k) = 0.D0
          bb(i, q-l, k) = 0.D0
          ab(i, r-k, q-1) = ab(i, r-k, q-1) + bb(i, l, r-k)
          bb(i, l, r-k) = 0.D0
          ab(i, k, 0) = ab(i, k, 0) + bb(i, l, k)
          bb(i, l, k) = 0.D0
        END DO
      END DO
      DO j=q2,1,-1
        DO k=(r-1)/2,1,-1
          tempib = -ab(i, k, q-j)
          ab(i, k, q-j) = -ab(i, k, q-j)
          temprb = ab(i, r-k, j-1)
          ab(i, r-k, j-1) = -ab(i, r-k, j-1)
          tempib = tempib + ab(i, r-k, q-j-1)
          ab(i, k, q-j) = ab(i, k, q-j) - ab(i, r-k, q-j-1)
          ab(i, r-k, q-j-1) = 0.D0
          temprb = temprb + ab(i, k, j)
          ab(i, r-k, j-1) = ab(i, r-k, j-1) + ab(i, k, j)
          ab(i, k, j) = 0.D0
          ab(i, r-k, q-j-1) = ab(i, r-k, q-j-1) + tempib
          ab(i, k, j) = ab(i, k, j) + temprb
        END DO
      END DO
      DO j=q2,1,-1
        tempb = bb(i, q-j, 0)
        bb(i, q-j, 0) = -bb(i, q-j, 0)
        tmpb3 = bb(i, j, 0)
        bb(i, j, 0) = tmpb3
        bb(i, q-j, 0) = bb(i, q-j, 0) + tmpb3
        bb(i, j, 0) = bb(i, j, 0) + tempb
      END DO
      DO j=q2,1,-1
        ab(i, 0, j) = ab(i, 0, j) + bb(i, 0, 0)
      END DO
      ab(i, 0, 0) = ab(i, 0, 0) + bb(i, 0, 0)
      bb(i, 0, 0) = 0.D0
      DO l=q2,1,-1
        DO j=q2,1,-1
          ab(i, 0, q-j) = ab(i, 0, q-j) - sine(0, indx)*bb(i, q-l, 0)
          ab(i, 0, j) = ab(i, 0, j) + cosine(0, indx)*bb(i, l, 0)
          CALL POPINTEGER4(indx)
        END DO
        bb(i, q-l, 0) = 0.D0
        ab(i, 0, 0) = ab(i, 0, 0) + bb(i, l, 0)
        bb(i, l, 0) = 0.D0
      END DO
    END DO
  END IF
END SUBROUTINE C06FQR_B

!  Differentiation of c06fqs in reverse (adjoint) mode:
!   gradient     of useful results: a b
!   with respect to varying inputs: a b
SUBROUTINE C06FQS_B(a, ab, b, bb, p, r, cosine, sine)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     MARK 14 REVISED. IER-699 (DEC 1989).
!
!     Radix six Hermitian to real fast Fourier transform kernel
!
!     Self-sorting, decimation in frequency
!
!     .. Parameters ..
  DOUBLE PRECISION :: sin60
  PARAMETER (sin60=0.866025403784438646763723170752936d0)
!     .. Scalar Arguments ..
  INTEGER :: p, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:r-1, 0:5), b(0:p-1, 0:5, 0:r-1), cosine&
& (0:r-1, 5), sine(0:r-1, 5)
  DOUBLE PRECISION :: ab(0:p-1, 0:r-1, 0:5), bb(0:p-1, 0:5, 0:r-1)
!     .. Local Scalars ..
  DOUBLE PRECISION :: c2k, c3k, c4k, c5k, ck, s2k, s3k, s4k, s5k, sk, t1&
& , t1i, t1r, t2, t2i, t2r, t3, t3i, t3r, t4, t5, t6, u0, u0i, u0r, u1, &
& u1i, u1r, u2, u2i, u2r, v0, v0i, v0r, v1, v1i, v1r, v2, v2i, v2r, x0p&
& , x1p, x2p, x3p, x4p, x5p, y0p, y1p, y2p, y3p, y4p, y5p
  DOUBLE PRECISION :: t1b, t1ib, t1rb, t2b, t2ib, t2rb, t3b, t3ib, t3rb&
& , t4b, t5b, t6b, u0b, u0ib, u0rb, u1b, u1ib, u1rb, u2b, u2ib, u2rb, &
& v0b, v0ib, v0rb, v1b, v1ib, v1rb, v2b, v2ib, v2rb, x0pb, x1pb, x2pb, &
& x3pb, x4pb, x5pb, y0pb, y1pb, y2pb, y3pb, y4pb, y5pb
  INTEGER :: i, k, kp, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
  INTEGER :: branch
!
!     Code for general K --
!
  IF (p .LE. (r-1)/2) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
!
!     Code for K=R/2 when R is even --
!
  IF (MOD(r, 2) .EQ. 0) THEN
    r2 = r/2
    DO i=p-1,0,-1
      t4b = bb(i, 5, r2)
      t5b = -bb(i, 5, r2)
      bb(i, 5, r2) = 0.D0
      t3b = bb(i, 4, r2)
      t6b = bb(i, 4, r2)
      bb(i, 4, r2) = 0.D0
      t2b = bb(i, 3, r2)
      ab(i, r2, 4) = ab(i, r2, 4) - bb(i, 3, r2)
      bb(i, 3, r2) = 0.D0
      t6b = t6b + bb(i, 2, r2)
      t3b = t3b - bb(i, 2, r2)
      bb(i, 2, r2) = 0.D0
      t4b = t4b + bb(i, 1, r2)
      t5b = t5b + bb(i, 1, r2)
      bb(i, 1, r2) = 0.D0
      ab(i, r2, 1) = ab(i, r2, 1) + bb(i, 0, r2)
      t1b = bb(i, 0, r2) - 0.5d0*t3b
      bb(i, 0, r2) = 0.D0
      ab(i, r2, 5) = ab(i, r2, 5) + sin60*t6b
      ab(i, r2, 3) = ab(i, r2, 3) - sin60*t6b
      ab(i, r2, 0) = ab(i, r2, 0) + sin60*t5b
      ab(i, r2, 2) = ab(i, r2, 2) - sin60*t5b
      ab(i, r2, 4) = ab(i, r2, 4) + t4b
      t2b = t2b + 0.5d0*t4b
      ab(i, r2, 1) = ab(i, r2, 1) + t3b
      ab(i, r2, 5) = ab(i, r2, 5) + t2b
      ab(i, r2, 3) = ab(i, r2, 3) + t2b
      ab(i, r2, 0) = ab(i, r2, 0) + t1b
      ab(i, r2, 2) = ab(i, r2, 2) + t1b
    END DO
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    DO i=p-1,0,-1
      DO k=(r-1)/2,1,-1
        y5pb = cosine(k, 5)*bb(i, 5, r-k)
        x5pb = sine(k, 5)*bb(i, 5, r-k)
        bb(i, 5, r-k) = 0.D0
        x5pb = x5pb + cosine(k, 5)*bb(i, 5, k)
        y5pb = y5pb - sine(k, 5)*bb(i, 5, k)
        bb(i, 5, k) = 0.D0
        y4pb = cosine(k, 4)*bb(i, 4, r-k)
        x4pb = sine(k, 4)*bb(i, 4, r-k)
        bb(i, 4, r-k) = 0.D0
        x4pb = x4pb + cosine(k, 4)*bb(i, 4, k)
        y4pb = y4pb - sine(k, 4)*bb(i, 4, k)
        bb(i, 4, k) = 0.D0
        y3pb = cosine(k, 3)*bb(i, 3, r-k)
        x3pb = sine(k, 3)*bb(i, 3, r-k)
        bb(i, 3, r-k) = 0.D0
        x3pb = x3pb + cosine(k, 3)*bb(i, 3, k)
        y3pb = y3pb - sine(k, 3)*bb(i, 3, k)
        bb(i, 3, k) = 0.D0
        y2pb = cosine(k, 2)*bb(i, 2, r-k)
        x2pb = sine(k, 2)*bb(i, 2, r-k)
        bb(i, 2, r-k) = 0.D0
        x2pb = x2pb + cosine(k, 2)*bb(i, 2, k)
        y2pb = y2pb - sine(k, 2)*bb(i, 2, k)
        bb(i, 2, k) = 0.D0
        y1pb = cosine(k, 1)*bb(i, 1, r-k)
        x1pb = sine(k, 1)*bb(i, 1, r-k)
        bb(i, 1, r-k) = 0.D0
        x1pb = x1pb + cosine(k, 1)*bb(i, 1, k)
        y1pb = y1pb - sine(k, 1)*bb(i, 1, k)
        bb(i, 1, k) = 0.D0
        y0pb = bb(i, 0, r-k)
        bb(i, 0, r-k) = 0.D0
        x0pb = bb(i, 0, k)
        bb(i, 0, k) = 0.D0
        u2ib = y2pb + y5pb
        v2ib = y2pb - y5pb
        u2rb = x2pb + x5pb
        v2rb = x2pb - x5pb
        u1ib = y1pb + y4pb
        v1ib = y4pb - y1pb
        u1rb = x1pb + x4pb
        v1rb = x4pb - x1pb
        u0ib = y0pb + y3pb
        v0ib = y0pb - y3pb
        u0rb = x0pb + x3pb
        v0rb = x0pb - x3pb
        t2ib = v1ib + v2ib
        t3rb = v2ib - v1ib
        t2rb = v1rb + v2rb
        t3ib = v1rb - v2rb
        t1ib = v0ib - 0.5d0*t2ib
        ab(i, k, 3) = ab(i, k, 3) - v0ib
        ab(i, r-k, 2) = ab(i, r-k, 2) + v0rb
        t1rb = v0rb - 0.5d0*t2rb
        ab(i, k, 5) = ab(i, k, 5) - sin60*t3ib
        ab(i, r-k, 4) = ab(i, r-k, 4) - sin60*t3ib
        ab(i, r-k, 0) = ab(i, r-k, 0) + sin60*t3rb
        ab(i, k, 1) = ab(i, k, 1) - sin60*t3rb
        ab(i, k, 3) = ab(i, k, 3) - t2ib
        ab(i, r-k, 2) = ab(i, r-k, 2) + t2rb
        ab(i, r-k, 4) = ab(i, r-k, 4) + t1ib
        ab(i, k, 5) = ab(i, k, 5) - t1ib
        ab(i, r-k, 0) = ab(i, r-k, 0) + t1rb
        ab(i, k, 1) = ab(i, k, 1) + t1rb
        t2ib = u1ib + u2ib
        t3rb = u2ib - u1ib
        t2rb = u1rb + u2rb
        t3ib = u1rb - u2rb
        ab(i, r-k, 5) = ab(i, r-k, 5) + u0ib
        t1ib = u0ib - 0.5d0*t2ib
        ab(i, k, 0) = ab(i, k, 0) + u0rb
        t1rb = u0rb - 0.5d0*t2rb
        ab(i, r-k, 3) = ab(i, r-k, 3) + sin60*t3ib
        ab(i, k, 4) = ab(i, k, 4) + sin60*t3ib
        ab(i, k, 2) = ab(i, k, 2) + sin60*t3rb
        ab(i, r-k, 1) = ab(i, r-k, 1) - sin60*t3rb
        ab(i, r-k, 5) = ab(i, r-k, 5) + t2ib
        ab(i, k, 0) = ab(i, k, 0) + t2rb
        ab(i, r-k, 3) = ab(i, r-k, 3) + t1ib
        ab(i, k, 4) = ab(i, k, 4) - t1ib
        ab(i, k, 2) = ab(i, k, 2) + t1rb
        ab(i, r-k, 1) = ab(i, r-k, 1) + t1rb
      END DO
    END DO
  ELSE
    DO k=(r-1)/2,1,-1
      s3k = sine(k, 3)
      c3k = cosine(k, 3)
      kp = r - k
      s4k = sine(k, 4)
      c4k = cosine(k, 4)
      s5k = sine(k, 5)
      sk = sine(k, 1)
      s2k = sine(k, 2)
      ck = cosine(k, 1)
      c5k = cosine(k, 5)
      c2k = cosine(k, 2)
      DO i=p-1,0,-1
        y5pb = c5k*bb(i, 5, kp)
        x5pb = s5k*bb(i, 5, kp)
        bb(i, 5, kp) = 0.D0
        x5pb = x5pb + c5k*bb(i, 5, k)
        y5pb = y5pb - s5k*bb(i, 5, k)
        bb(i, 5, k) = 0.D0
        y4pb = c4k*bb(i, 4, kp)
        x4pb = s4k*bb(i, 4, kp)
        bb(i, 4, kp) = 0.D0
        x4pb = x4pb + c4k*bb(i, 4, k)
        y4pb = y4pb - s4k*bb(i, 4, k)
        bb(i, 4, k) = 0.D0
        y3pb = c3k*bb(i, 3, kp)
        x3pb = s3k*bb(i, 3, kp)
        bb(i, 3, kp) = 0.D0
        x3pb = x3pb + c3k*bb(i, 3, k)
        y3pb = y3pb - s3k*bb(i, 3, k)
        bb(i, 3, k) = 0.D0
        y2pb = c2k*bb(i, 2, kp)
        x2pb = s2k*bb(i, 2, kp)
        bb(i, 2, kp) = 0.D0
        x2pb = x2pb + c2k*bb(i, 2, k)
        y2pb = y2pb - s2k*bb(i, 2, k)
        bb(i, 2, k) = 0.D0
        y1pb = ck*bb(i, 1, kp)
        x1pb = sk*bb(i, 1, kp)
        bb(i, 1, kp) = 0.D0
        x1pb = x1pb + ck*bb(i, 1, k)
        y1pb = y1pb - sk*bb(i, 1, k)
        bb(i, 1, k) = 0.D0
        y0pb = bb(i, 0, kp)
        bb(i, 0, kp) = 0.D0
        x0pb = bb(i, 0, k)
        bb(i, 0, k) = 0.D0
        u2ib = y2pb + y5pb
        v2ib = y2pb - y5pb
        u2rb = x2pb + x5pb
        v2rb = x2pb - x5pb
        u1ib = y1pb + y4pb
        v1ib = y4pb - y1pb
        u1rb = x1pb + x4pb
        v1rb = x4pb - x1pb
        u0ib = y0pb + y3pb
        v0ib = y0pb - y3pb
        u0rb = x0pb + x3pb
        v0rb = x0pb - x3pb
        t2ib = v1ib + v2ib
        t3rb = v2ib - v1ib
        t2rb = v1rb + v2rb
        t3ib = v1rb - v2rb
        t1ib = v0ib - 0.5d0*t2ib
        ab(i, k, 3) = ab(i, k, 3) - v0ib
        ab(i, kp, 2) = ab(i, kp, 2) + v0rb
        t1rb = v0rb - 0.5d0*t2rb
        ab(i, k, 5) = ab(i, k, 5) - sin60*t3ib
        ab(i, kp, 4) = ab(i, kp, 4) - sin60*t3ib
        ab(i, kp, 0) = ab(i, kp, 0) + sin60*t3rb
        ab(i, k, 1) = ab(i, k, 1) - sin60*t3rb
        ab(i, k, 3) = ab(i, k, 3) - t2ib
        ab(i, kp, 2) = ab(i, kp, 2) + t2rb
        ab(i, kp, 4) = ab(i, kp, 4) + t1ib
        ab(i, k, 5) = ab(i, k, 5) - t1ib
        ab(i, kp, 0) = ab(i, kp, 0) + t1rb
        ab(i, k, 1) = ab(i, k, 1) + t1rb
        t2ib = u1ib + u2ib
        t3rb = u2ib - u1ib
        t2rb = u1rb + u2rb
        t3ib = u1rb - u2rb
        ab(i, kp, 5) = ab(i, kp, 5) + u0ib
        t1ib = u0ib - 0.5d0*t2ib
        ab(i, k, 0) = ab(i, k, 0) + u0rb
        t1rb = u0rb - 0.5d0*t2rb
        ab(i, kp, 3) = ab(i, kp, 3) + sin60*t3ib
        ab(i, k, 4) = ab(i, k, 4) + sin60*t3ib
        ab(i, k, 2) = ab(i, k, 2) + sin60*t3rb
        ab(i, kp, 1) = ab(i, kp, 1) - sin60*t3rb
        ab(i, kp, 5) = ab(i, kp, 5) + t2ib
        ab(i, k, 0) = ab(i, k, 0) + t2rb
        ab(i, kp, 3) = ab(i, kp, 3) + t1ib
        ab(i, k, 4) = ab(i, k, 4) - t1ib
        ab(i, k, 2) = ab(i, k, 2) + t1rb
        ab(i, kp, 1) = ab(i, kp, 1) + t1rb
      END DO
    END DO
  END IF
  DO i=p-1,0,-1
    u2b = bb(i, 5, 0)
    v2b = -bb(i, 5, 0)
    bb(i, 5, 0) = 0.D0
    u1b = bb(i, 4, 0)
    v1b = bb(i, 4, 0)
    bb(i, 4, 0) = 0.D0
    u0b = bb(i, 3, 0)
    v0b = -bb(i, 3, 0)
    bb(i, 3, 0) = 0.D0
    u2b = u2b + bb(i, 2, 0)
    v2b = v2b + bb(i, 2, 0)
    bb(i, 2, 0) = 0.D0
    u1b = u1b + bb(i, 1, 0)
    v1b = v1b - bb(i, 1, 0)
    bb(i, 1, 0) = 0.D0
    u0b = u0b + bb(i, 0, 0)
    v0b = v0b + bb(i, 0, 0)
    bb(i, 0, 0) = 0.D0
    t2b = v1b + v2b
    t3b = v1b - v2b
    ab(i, 0, 3) = ab(i, 0, 3) + v0b
    t1b = v0b - 0.5d0*t2b
    ab(i, 0, 5) = ab(i, 0, 5) - sin60*t3b
    ab(i, 0, 3) = ab(i, 0, 3) + t2b
    ab(i, 0, 1) = ab(i, 0, 1) + t1b
    t2b = u1b + u2b
    t3b = u1b - u2b
    ab(i, 0, 0) = ab(i, 0, 0) + u0b
    t1b = u0b - 0.5d0*t2b
    ab(i, 0, 4) = ab(i, 0, 4) + sin60*t3b
    ab(i, 0, 0) = ab(i, 0, 0) + t2b
    ab(i, 0, 2) = ab(i, 0, 2) + t1b
  END DO
END SUBROUTINE C06FQS_B

!  Differentiation of c06fqt in reverse (adjoint) mode:
!   gradient     of useful results: a b
!   with respect to varying inputs: a b
SUBROUTINE C06FQT_B(a, ab, b, bb, p, r, cosine, sine)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     MARK 14 REVISED. IER-700 (DEC 1989).
!
!     Radix five Hermitian to real fast Fourier transform kernel
!
!     Self-sorting, decimation in frequency
!
!     .. Parameters ..
  DOUBLE PRECISION :: r54, sin36, sin72, s36s72
  PARAMETER (r54=0.559016994374947424102293417182819d0, sin36=&
&   0.587785252292473129168705954639073d0, sin72=&
&   0.951056516295153572116439333379382d0, s36s72=&
&   0.618033988749894848204586834365638d0)
!     .. Scalar Arguments ..
  INTEGER :: p, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:r-1, 0:4), b(0:p-1, 0:4, 0:r-1), cosine&
& (0:r-1, 4), sine(0:r-1, 4)
  DOUBLE PRECISION :: ab(0:p-1, 0:r-1, 0:4), bb(0:p-1, 0:4, 0:r-1)
!     .. Local Scalars ..
  DOUBLE PRECISION :: c2k, c3k, c4k, ck, s2k, s3k, s4k, sk, t1, t10, &
& t10i, t10r, t11, t11i, t11r, t1i, t1r, t2, t2i, t2r, t3, t3i, t3r, t4&
& , t4i, t4r, t5, t5i, t5r, t6, t6i, t6r, t7, t7i, t7r, t8, t8i, t8r, t9&
& , t9i, t9r, x0p, x1p, x2p, x3p, x4p, y0p, y1p, y2p, y3p, y4p
  DOUBLE PRECISION :: t1b, t10b, t10ib, t10rb, t11b, t11ib, t11rb, t1ib&
& , t1rb, t2b, t2ib, t2rb, t3b, t3ib, t3rb, t4b, t4ib, t4rb, t5b, t5ib, &
& t5rb, t6b, t6ib, t6rb, t7b, t7ib, t7rb, t8b, t8ib, t8rb, t9b, t9ib, &
& t9rb, x0pb, x1pb, x2pb, x3pb, x4pb, y0pb, y1pb, y2pb, y3pb, y4pb
  INTEGER :: i, k, kp, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
!
!     Code for general K --
!
  IF (p .LE. (r-1)/2) THEN
    DO i=p-1,0,-1
      DO k=(r-1)/2,1,-1
        y4pb = cosine(k, 4)*bb(i, 4, r-k)
        x4pb = sine(k, 4)*bb(i, 4, r-k)
        bb(i, 4, r-k) = 0.D0
        x4pb = x4pb + cosine(k, 4)*bb(i, 4, k)
        y4pb = y4pb - sine(k, 4)*bb(i, 4, k)
        bb(i, 4, k) = 0.D0
        y3pb = cosine(k, 3)*bb(i, 3, r-k)
        x3pb = sine(k, 3)*bb(i, 3, r-k)
        bb(i, 3, r-k) = 0.D0
        x3pb = x3pb + cosine(k, 3)*bb(i, 3, k)
        y3pb = y3pb - sine(k, 3)*bb(i, 3, k)
        bb(i, 3, k) = 0.D0
        y2pb = cosine(k, 2)*bb(i, 2, r-k)
        x2pb = sine(k, 2)*bb(i, 2, r-k)
        bb(i, 2, r-k) = 0.D0
        x2pb = x2pb + cosine(k, 2)*bb(i, 2, k)
        y2pb = y2pb - sine(k, 2)*bb(i, 2, k)
        bb(i, 2, k) = 0.D0
        y1pb = cosine(k, 1)*bb(i, 1, r-k)
        x1pb = sine(k, 1)*bb(i, 1, r-k)
        bb(i, 1, r-k) = 0.D0
        x1pb = x1pb + cosine(k, 1)*bb(i, 1, k)
        y1pb = y1pb - sine(k, 1)*bb(i, 1, k)
        bb(i, 1, k) = 0.D0
        y0pb = bb(i, 0, r-k)
        bb(i, 0, r-k) = 0.D0
        x0pb = bb(i, 0, k)
        bb(i, 0, k) = 0.D0
        t8ib = y1pb + y4pb
        t10rb = y4pb - y1pb
        t8rb = x1pb + x4pb
        t10ib = x1pb - x4pb
        t9ib = y2pb + y3pb
        t11rb = y3pb - y2pb
        t9rb = x2pb + x3pb
        t11ib = x2pb - x3pb
        ab(i, r-k, 4) = ab(i, r-k, 4) + y0pb
        ab(i, k, 0) = ab(i, k, 0) + x0pb
        t3ib = t10ib + s36s72*t11ib
        t4ib = s36s72*t10ib - t11ib
        t3rb = t10rb + s36s72*t11rb
        t4rb = s36s72*t10rb - t11rb
        t7ib = t8ib + t9ib
        t5ib = y0pb - 0.25d0*t7ib
        t6ib = t8ib - t9ib
        t7rb = t8rb + t9rb
        t5rb = x0pb - 0.25d0*t7rb
        t6rb = t8rb - t9rb
        ab(i, r-k, 4) = ab(i, r-k, 4) + t7ib
        ab(i, k, 0) = ab(i, k, 0) + t7rb
        t1ib = t5ib + r54*t6ib
        t2ib = t5ib - r54*t6ib
        t1rb = t5rb + r54*t6rb
        t2rb = t5rb - r54*t6rb
        ab(i, r-k, 2) = ab(i, r-k, 2) + sin72*t4ib
        ab(i, k, 3) = ab(i, k, 3) + sin72*t4ib
        ab(i, k, 2) = ab(i, k, 2) + sin72*t4rb
        ab(i, r-k, 1) = ab(i, r-k, 1) - sin72*t4rb
        ab(i, r-k, 3) = ab(i, r-k, 3) + sin72*t3ib
        ab(i, k, 4) = ab(i, k, 4) + sin72*t3ib
        ab(i, k, 1) = ab(i, k, 1) + sin72*t3rb
        ab(i, r-k, 0) = ab(i, r-k, 0) - sin72*t3rb
        ab(i, r-k, 2) = ab(i, r-k, 2) + t2ib
        ab(i, k, 3) = ab(i, k, 3) - t2ib
        ab(i, k, 2) = ab(i, k, 2) + t2rb
        ab(i, r-k, 1) = ab(i, r-k, 1) + t2rb
        ab(i, r-k, 3) = ab(i, r-k, 3) + t1ib
        ab(i, k, 4) = ab(i, k, 4) - t1ib
        ab(i, k, 1) = ab(i, k, 1) + t1rb
        ab(i, r-k, 0) = ab(i, r-k, 0) + t1rb
      END DO
    END DO
  ELSE
    DO k=(r-1)/2,1,-1
      s3k = sine(k, 3)
      c3k = cosine(k, 3)
      kp = r - k
      s4k = sine(k, 4)
      c4k = cosine(k, 4)
      sk = sine(k, 1)
      s2k = sine(k, 2)
      ck = cosine(k, 1)
      c2k = cosine(k, 2)
      DO i=p-1,0,-1
        y4pb = c4k*bb(i, 4, kp)
        x4pb = s4k*bb(i, 4, kp)
        bb(i, 4, kp) = 0.D0
        x4pb = x4pb + c4k*bb(i, 4, k)
        y4pb = y4pb - s4k*bb(i, 4, k)
        bb(i, 4, k) = 0.D0
        y3pb = c3k*bb(i, 3, kp)
        x3pb = s3k*bb(i, 3, kp)
        bb(i, 3, kp) = 0.D0
        x3pb = x3pb + c3k*bb(i, 3, k)
        y3pb = y3pb - s3k*bb(i, 3, k)
        bb(i, 3, k) = 0.D0
        y2pb = c2k*bb(i, 2, kp)
        x2pb = s2k*bb(i, 2, kp)
        bb(i, 2, kp) = 0.D0
        x2pb = x2pb + c2k*bb(i, 2, k)
        y2pb = y2pb - s2k*bb(i, 2, k)
        bb(i, 2, k) = 0.D0
        y1pb = ck*bb(i, 1, kp)
        x1pb = sk*bb(i, 1, kp)
        bb(i, 1, kp) = 0.D0
        x1pb = x1pb + ck*bb(i, 1, k)
        y1pb = y1pb - sk*bb(i, 1, k)
        bb(i, 1, k) = 0.D0
        y0pb = bb(i, 0, kp)
        bb(i, 0, kp) = 0.D0
        x0pb = bb(i, 0, k)
        bb(i, 0, k) = 0.D0
        t8ib = y1pb + y4pb
        t10rb = y4pb - y1pb
        t8rb = x1pb + x4pb
        t10ib = x1pb - x4pb
        t9ib = y2pb + y3pb
        t11rb = y3pb - y2pb
        t9rb = x2pb + x3pb
        t11ib = x2pb - x3pb
        ab(i, kp, 4) = ab(i, kp, 4) + y0pb
        ab(i, k, 0) = ab(i, k, 0) + x0pb
        t3ib = t10ib + s36s72*t11ib
        t4ib = s36s72*t10ib - t11ib
        t3rb = t10rb + s36s72*t11rb
        t4rb = s36s72*t10rb - t11rb
        t7ib = t8ib + t9ib
        t5ib = y0pb - 0.25d0*t7ib
        t6ib = t8ib - t9ib
        t7rb = t8rb + t9rb
        t5rb = x0pb - 0.25d0*t7rb
        t6rb = t8rb - t9rb
        ab(i, kp, 4) = ab(i, kp, 4) + t7ib
        ab(i, k, 0) = ab(i, k, 0) + t7rb
        t1ib = t5ib + r54*t6ib
        t2ib = t5ib - r54*t6ib
        t1rb = t5rb + r54*t6rb
        t2rb = t5rb - r54*t6rb
        ab(i, kp, 2) = ab(i, kp, 2) + sin72*t4ib
        ab(i, k, 3) = ab(i, k, 3) + sin72*t4ib
        ab(i, k, 2) = ab(i, k, 2) + sin72*t4rb
        ab(i, kp, 1) = ab(i, kp, 1) - sin72*t4rb
        ab(i, kp, 3) = ab(i, kp, 3) + sin72*t3ib
        ab(i, k, 4) = ab(i, k, 4) + sin72*t3ib
        ab(i, k, 1) = ab(i, k, 1) + sin72*t3rb
        ab(i, kp, 0) = ab(i, kp, 0) - sin72*t3rb
        ab(i, kp, 2) = ab(i, kp, 2) + t2ib
        ab(i, k, 3) = ab(i, k, 3) - t2ib
        ab(i, k, 2) = ab(i, k, 2) + t2rb
        ab(i, kp, 1) = ab(i, kp, 1) + t2rb
        ab(i, kp, 3) = ab(i, kp, 3) + t1ib
        ab(i, k, 4) = ab(i, k, 4) - t1ib
        ab(i, k, 1) = ab(i, k, 1) + t1rb
        ab(i, kp, 0) = ab(i, kp, 0) + t1rb
      END DO
    END DO
  END IF
  DO i=p-1,0,-1
    t8b = bb(i, 4, 0)
    t10b = -bb(i, 4, 0)
    bb(i, 4, 0) = 0.D0
    t9b = bb(i, 3, 0)
    t11b = -bb(i, 3, 0)
    bb(i, 3, 0) = 0.D0
    t9b = t9b + bb(i, 2, 0)
    t11b = t11b + bb(i, 2, 0)
    bb(i, 2, 0) = 0.D0
    t8b = t8b + bb(i, 1, 0)
    t10b = t10b + bb(i, 1, 0)
    bb(i, 1, 0) = 0.D0
    t3b = t10b + s36s72*t11b
    t4b = s36s72*t10b - t11b
    t7b = t8b + t9b
    ab(i, 0, 0) = ab(i, 0, 0) + t7b + bb(i, 0, 0)
    t5b = bb(i, 0, 0) - 0.25d0*t7b
    bb(i, 0, 0) = 0.D0
    t6b = t8b - t9b
    t1b = t5b + r54*t6b
    t2b = t5b - r54*t6b
    ab(i, 0, 3) = ab(i, 0, 3) + sin72*t4b
    ab(i, 0, 4) = ab(i, 0, 4) + sin72*t3b
    ab(i, 0, 2) = ab(i, 0, 2) + t2b
    ab(i, 0, 1) = ab(i, 0, 1) + t1b
  END DO
END SUBROUTINE C06FQT_B

!  Differentiation of c06fqu in reverse (adjoint) mode:
!   gradient     of useful results: a b
!   with respect to varying inputs: a b
SUBROUTINE C06FQU_B(a, ab, b, bb, p, r, cosine, sine)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     MARK 14 REVISED. IER-701 (DEC 1989).
!
!     Radix four Hermitian to real fast Fourier transform kernel
!
!     Self-sorting, decimation in frequency
!
!     .. Parameters ..
  DOUBLE PRECISION :: root2i
  PARAMETER (root2i=0.707106781186547524400844362104849d0)
!     .. Scalar Arguments ..
  INTEGER :: p, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:r-1, 0:3), b(0:p-1, 0:3, 0:r-1), cosine&
& (0:r-1, 3), sine(0:r-1, 3)
  DOUBLE PRECISION :: ab(0:p-1, 0:r-1, 0:3), bb(0:p-1, 0:3, 0:r-1)
!     .. Local Scalars ..
  DOUBLE PRECISION :: c2k, c3k, ck, s2k, s3k, sk, t1, t1i, t1r, t2, t2i&
& , t2r, t3, t3i, t3r, t4, t4i, t4r, x0p, x1p, x2p, x3p, y0p, y1p, y2p, &
& y3p
  DOUBLE PRECISION :: t1b, t1ib, t1rb, t2b, t2ib, t2rb, t3b, t3ib, t3rb&
& , t4b, t4ib, t4rb, x0pb, x1pb, x2pb, x3pb, y0pb, y1pb, y2pb, y3pb
  INTEGER :: i, k, kp, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
  INTEGER :: branch
!
!     Code for general K --
!
  IF (p .LT. (r-1)/2) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
!
!     Code for K=R/2 when R is even --
!
  IF (MOD(r, 2) .EQ. 0) THEN
    r2 = r/2
    DO i=p-1,0,-1
      t3b = -(root2i*bb(i, 3, r2))
      t4b = root2i*bb(i, 3, r2)
      bb(i, 3, r2) = 0.D0
      t3b = t3b + root2i*bb(i, 1, r2)
      t4b = t4b + root2i*bb(i, 1, r2)
      bb(i, 1, r2) = 0.D0
      ab(i, r2, 3) = ab(i, r2, 3) + t4b
      ab(i, r2, 2) = ab(i, r2, 2) + t4b
      ab(i, r2, 0) = ab(i, r2, 0) + t3b
      ab(i, r2, 1) = ab(i, r2, 1) - t3b
      ab(i, r2, 3) = ab(i, r2, 3) + bb(i, 2, r2)
      ab(i, r2, 2) = ab(i, r2, 2) - bb(i, 2, r2)
      bb(i, 2, r2) = 0.D0
      ab(i, r2, 0) = ab(i, r2, 0) + bb(i, 0, r2)
      ab(i, r2, 1) = ab(i, r2, 1) + bb(i, 0, r2)
      bb(i, 0, r2) = 0.D0
    END DO
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    DO i=p-1,0,-1
      DO k=(r-1)/2,1,-1
        y3pb = cosine(k, 3)*bb(i, 3, r-k)
        x3pb = sine(k, 3)*bb(i, 3, r-k)
        bb(i, 3, r-k) = 0.D0
        x3pb = x3pb + cosine(k, 3)*bb(i, 3, k)
        y3pb = y3pb - sine(k, 3)*bb(i, 3, k)
        bb(i, 3, k) = 0.D0
        y2pb = cosine(k, 2)*bb(i, 2, r-k)
        x2pb = sine(k, 2)*bb(i, 2, r-k)
        bb(i, 2, r-k) = 0.D0
        x2pb = x2pb + cosine(k, 2)*bb(i, 2, k)
        y2pb = y2pb - sine(k, 2)*bb(i, 2, k)
        bb(i, 2, k) = 0.D0
        y1pb = cosine(k, 1)*bb(i, 1, r-k)
        x1pb = sine(k, 1)*bb(i, 1, r-k)
        bb(i, 1, r-k) = 0.D0
        x1pb = x1pb + cosine(k, 1)*bb(i, 1, k)
        y1pb = y1pb - sine(k, 1)*bb(i, 1, k)
        bb(i, 1, k) = 0.D0
        y0pb = bb(i, 0, r-k)
        bb(i, 0, r-k) = 0.D0
        x0pb = bb(i, 0, k)
        bb(i, 0, k) = 0.D0
        t3ib = y1pb + y3pb
        t4rb = y3pb - y1pb
        t3rb = x1pb + x3pb
        t4ib = x1pb - x3pb
        t1ib = y0pb + y2pb
        t2ib = y0pb - y2pb
        t1rb = x0pb + x2pb
        t2rb = x0pb - x2pb
        ab(i, r-k, 2) = ab(i, r-k, 2) + t4ib
        ab(i, k, 3) = ab(i, k, 3) + t4ib
        ab(i, k, 1) = ab(i, k, 1) + t4rb
        ab(i, r-k, 0) = ab(i, r-k, 0) - t4rb
        ab(i, r-k, 3) = ab(i, r-k, 3) + t3ib
        ab(i, k, 2) = ab(i, k, 2) + t3ib
        ab(i, k, 0) = ab(i, k, 0) + t3rb
        ab(i, r-k, 1) = ab(i, r-k, 1) - t3rb
        ab(i, r-k, 2) = ab(i, r-k, 2) + t2ib
        ab(i, k, 3) = ab(i, k, 3) - t2ib
        ab(i, k, 1) = ab(i, k, 1) + t2rb
        ab(i, r-k, 0) = ab(i, r-k, 0) + t2rb
        ab(i, r-k, 3) = ab(i, r-k, 3) + t1ib
        ab(i, k, 2) = ab(i, k, 2) - t1ib
        ab(i, k, 0) = ab(i, k, 0) + t1rb
        ab(i, r-k, 1) = ab(i, r-k, 1) + t1rb
      END DO
    END DO
  ELSE
    DO k=(r-1)/2,1,-1
      s3k = sine(k, 3)
      c3k = cosine(k, 3)
      kp = r - k
      sk = sine(k, 1)
      s2k = sine(k, 2)
      ck = cosine(k, 1)
      c2k = cosine(k, 2)
      DO i=p-1,0,-1
        y3pb = c3k*bb(i, 3, kp)
        x3pb = s3k*bb(i, 3, kp)
        bb(i, 3, kp) = 0.D0
        x3pb = x3pb + c3k*bb(i, 3, k)
        y3pb = y3pb - s3k*bb(i, 3, k)
        bb(i, 3, k) = 0.D0
        y2pb = c2k*bb(i, 2, kp)
        x2pb = s2k*bb(i, 2, kp)
        bb(i, 2, kp) = 0.D0
        x2pb = x2pb + c2k*bb(i, 2, k)
        y2pb = y2pb - s2k*bb(i, 2, k)
        bb(i, 2, k) = 0.D0
        y1pb = ck*bb(i, 1, kp)
        x1pb = sk*bb(i, 1, kp)
        bb(i, 1, kp) = 0.D0
        x1pb = x1pb + ck*bb(i, 1, k)
        y1pb = y1pb - sk*bb(i, 1, k)
        bb(i, 1, k) = 0.D0
        y0pb = bb(i, 0, kp)
        bb(i, 0, kp) = 0.D0
        x0pb = bb(i, 0, k)
        bb(i, 0, k) = 0.D0
        t3ib = y1pb + y3pb
        t4rb = y3pb - y1pb
        t3rb = x1pb + x3pb
        t4ib = x1pb - x3pb
        t1ib = y0pb + y2pb
        t2ib = y0pb - y2pb
        t1rb = x0pb + x2pb
        t2rb = x0pb - x2pb
        ab(i, kp, 2) = ab(i, kp, 2) + t4ib
        ab(i, k, 3) = ab(i, k, 3) + t4ib
        ab(i, k, 1) = ab(i, k, 1) + t4rb
        ab(i, kp, 0) = ab(i, kp, 0) - t4rb
        ab(i, kp, 3) = ab(i, kp, 3) + t3ib
        ab(i, k, 2) = ab(i, k, 2) + t3ib
        ab(i, k, 0) = ab(i, k, 0) + t3rb
        ab(i, kp, 1) = ab(i, kp, 1) - t3rb
        ab(i, kp, 2) = ab(i, kp, 2) + t2ib
        ab(i, k, 3) = ab(i, k, 3) - t2ib
        ab(i, k, 1) = ab(i, k, 1) + t2rb
        ab(i, kp, 0) = ab(i, kp, 0) + t2rb
        ab(i, kp, 3) = ab(i, kp, 3) + t1ib
        ab(i, k, 2) = ab(i, k, 2) - t1ib
        ab(i, k, 0) = ab(i, k, 0) + t1rb
        ab(i, kp, 1) = ab(i, kp, 1) + t1rb
      END DO
    END DO
  END IF
  DO i=p-1,0,-1
    t3b = bb(i, 3, 0)
    t4b = -bb(i, 3, 0)
    bb(i, 3, 0) = 0.D0
    t1b = bb(i, 2, 0)
    t2b = -bb(i, 2, 0)
    bb(i, 2, 0) = 0.D0
    t3b = t3b + bb(i, 1, 0)
    t4b = t4b + bb(i, 1, 0)
    bb(i, 1, 0) = 0.D0
    t1b = t1b + bb(i, 0, 0)
    t2b = t2b + bb(i, 0, 0)
    bb(i, 0, 0) = 0.D0
    ab(i, 0, 3) = ab(i, 0, 3) + t4b
    ab(i, 0, 0) = ab(i, 0, 0) + t3b
    ab(i, 0, 2) = ab(i, 0, 2) - t3b
    ab(i, 0, 1) = ab(i, 0, 1) + t2b
    ab(i, 0, 0) = ab(i, 0, 0) + t1b
    ab(i, 0, 2) = ab(i, 0, 2) + t1b
  END DO
END SUBROUTINE C06FQU_B

!  Differentiation of c06fqv in reverse (adjoint) mode:
!   gradient     of useful results: a b
!   with respect to varying inputs: a b
SUBROUTINE C06FQV_B(a, ab, b, bb, p, r, cosine, sine)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     MARK 14 REVISED. IER-702 (DEC 1989).
!
!     Radix three Hermitian to real Fourier transform kernel
!
!     Self-sorting, decimation in frequency
!
!     .. Parameters ..
  DOUBLE PRECISION :: sin60
  PARAMETER (sin60=0.866025403784438646763723170752936d0)
!     .. Scalar Arguments ..
  INTEGER :: p, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:r-1, 0:2), b(0:p-1, 0:2, 0:r-1), cosine&
& (0:r-1, 2), sine(0:r-1, 2)
  DOUBLE PRECISION :: ab(0:p-1, 0:r-1, 0:2), bb(0:p-1, 0:2, 0:r-1)
!     .. Local Scalars ..
  DOUBLE PRECISION :: c2k, ck, s2k, sk, t1, t1i, t1r, t2, t2i, t2r, t3, &
& t3i, t3r, x0p, x1p, x2p, y0p, y1p, y2p
  DOUBLE PRECISION :: t1b, t1ib, t1rb, t2b, t2ib, t2rb, t3b, t3ib, t3rb&
& , x0pb, x1pb, x2pb, y0pb, y1pb, y2pb
  INTEGER :: i, k, kp, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
!
!     Code for general K
!
  IF (p .LE. (r-1)/2) THEN
    DO i=p-1,0,-1
      DO k=(r-1)/2,1,-1
        x2pb = sine(k, 2)*bb(i, 2, r-k)
        y2pb = cosine(k, 2)*bb(i, 2, r-k)
        bb(i, 2, r-k) = 0.D0
        x2pb = x2pb + cosine(k, 2)*bb(i, 2, k)
        y2pb = y2pb - sine(k, 2)*bb(i, 2, k)
        bb(i, 2, k) = 0.D0
        x1pb = sine(k, 1)*bb(i, 1, r-k)
        y1pb = cosine(k, 1)*bb(i, 1, r-k)
        bb(i, 1, r-k) = 0.D0
        x1pb = x1pb + cosine(k, 1)*bb(i, 1, k)
        y1pb = y1pb - sine(k, 1)*bb(i, 1, k)
        bb(i, 1, k) = 0.D0
        y0pb = bb(i, 0, r-k)
        bb(i, 0, r-k) = 0.D0
        x0pb = bb(i, 0, k)
        bb(i, 0, k) = 0.D0
        t2ib = y1pb + y2pb
        t3rb = y2pb - y1pb
        t2rb = x1pb + x2pb
        t3ib = x1pb - x2pb
        ab(i, r-k, 2) = ab(i, r-k, 2) + y0pb
        t1ib = y0pb - 0.5d0*t2ib
        ab(i, k, 0) = ab(i, k, 0) + x0pb
        t1rb = x0pb - 0.5d0*t2rb
        ab(i, r-k, 1) = ab(i, r-k, 1) + sin60*t3ib
        ab(i, k, 2) = ab(i, k, 2) + sin60*t3ib
        ab(i, k, 1) = ab(i, k, 1) + sin60*t3rb
        ab(i, r-k, 0) = ab(i, r-k, 0) - sin60*t3rb
        ab(i, r-k, 2) = ab(i, r-k, 2) + t2ib
        ab(i, k, 0) = ab(i, k, 0) + t2rb
        ab(i, r-k, 1) = ab(i, r-k, 1) + t1ib
        ab(i, k, 2) = ab(i, k, 2) - t1ib
        ab(i, k, 1) = ab(i, k, 1) + t1rb
        ab(i, r-k, 0) = ab(i, r-k, 0) + t1rb
      END DO
    END DO
  ELSE
    DO k=(r-1)/2,1,-1
      kp = r - k
      sk = sine(k, 1)
      s2k = sine(k, 2)
      ck = cosine(k, 1)
      c2k = cosine(k, 2)
      DO i=p-1,0,-1
        x2pb = s2k*bb(i, 2, kp)
        y2pb = c2k*bb(i, 2, kp)
        bb(i, 2, kp) = 0.D0
        x2pb = x2pb + c2k*bb(i, 2, k)
        y2pb = y2pb - s2k*bb(i, 2, k)
        bb(i, 2, k) = 0.D0
        x1pb = sk*bb(i, 1, kp)
        y1pb = ck*bb(i, 1, kp)
        bb(i, 1, kp) = 0.D0
        x1pb = x1pb + ck*bb(i, 1, k)
        y1pb = y1pb - sk*bb(i, 1, k)
        bb(i, 1, k) = 0.D0
        y0pb = bb(i, 0, kp)
        bb(i, 0, kp) = 0.D0
        x0pb = bb(i, 0, k)
        bb(i, 0, k) = 0.D0
        t2ib = y1pb + y2pb
        t3rb = y2pb - y1pb
        t2rb = x1pb + x2pb
        t3ib = x1pb - x2pb
        ab(i, kp, 2) = ab(i, kp, 2) + y0pb
        t1ib = y0pb - 0.5d0*t2ib
        ab(i, k, 0) = ab(i, k, 0) + x0pb
        t1rb = x0pb - 0.5d0*t2rb
        ab(i, kp, 1) = ab(i, kp, 1) + sin60*t3ib
        ab(i, k, 2) = ab(i, k, 2) + sin60*t3ib
        ab(i, k, 1) = ab(i, k, 1) + sin60*t3rb
        ab(i, kp, 0) = ab(i, kp, 0) - sin60*t3rb
        ab(i, kp, 2) = ab(i, kp, 2) + t2ib
        ab(i, k, 0) = ab(i, k, 0) + t2rb
        ab(i, kp, 1) = ab(i, kp, 1) + t1ib
        ab(i, k, 2) = ab(i, k, 2) - t1ib
        ab(i, k, 1) = ab(i, k, 1) + t1rb
        ab(i, kp, 0) = ab(i, kp, 0) + t1rb
      END DO
    END DO
  END IF
  DO i=p-1,0,-1
    t2b = bb(i, 2, 0)
    t3b = -bb(i, 2, 0)
    bb(i, 2, 0) = 0.D0
    t2b = t2b + bb(i, 1, 0)
    t3b = t3b + bb(i, 1, 0)
    bb(i, 1, 0) = 0.D0
    ab(i, 0, 0) = ab(i, 0, 0) + bb(i, 0, 0)
    t1b = bb(i, 0, 0) - 0.5d0*t2b
    bb(i, 0, 0) = 0.D0
    ab(i, 0, 2) = ab(i, 0, 2) + sin60*t3b
    ab(i, 0, 0) = ab(i, 0, 0) + t2b
    ab(i, 0, 1) = ab(i, 0, 1) + t1b
  END DO
END SUBROUTINE C06FQV_B

!  Differentiation of c06fqw in reverse (adjoint) mode:
!   gradient     of useful results: a b
!   with respect to varying inputs: a b
SUBROUTINE C06FQW_B(a, ab, b, bb, p, r, cosine, sine)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     MARK 14 REVISED. IER-703 (DEC 1989).
!
!     Radix two Hermitian to real Fourier transform kernel
!
!     Self-sorting, decimation in frequency
!
!     .. Scalar Arguments ..
  INTEGER :: p, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:r-1, 0:1), b(0:p-1, 0:1, 0:r-1), cosine&
& (0:r-1), sine(0:r-1)
  DOUBLE PRECISION :: ab(0:p-1, 0:r-1, 0:1), bb(0:p-1, 0:1, 0:r-1)
!     .. Local Scalars ..
  DOUBLE PRECISION :: ck, sk, x1hat, y1hat
  DOUBLE PRECISION :: x1hatb, y1hatb
  INTEGER :: i, k, kp, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
!
!     Code for general K --
!
  IF (p .LT. (r-1)/2) THEN
    DO i=p-1,0,-1
      DO k=(r-1)/2,1,-1
        y1hatb = cosine(k)*bb(i, 1, r-k)
        x1hatb = sine(k)*bb(i, 1, r-k)
        bb(i, 1, r-k) = 0.D0
        x1hatb = x1hatb + cosine(k)*bb(i, 1, k)
        y1hatb = y1hatb - sine(k)*bb(i, 1, k)
        bb(i, 1, k) = 0.D0
        ab(i, r-k, 1) = ab(i, r-k, 1) + bb(i, 0, r-k)
        ab(i, k, 1) = ab(i, k, 1) - bb(i, 0, r-k)
        bb(i, 0, r-k) = 0.D0
        ab(i, k, 0) = ab(i, k, 0) + bb(i, 0, k)
        ab(i, r-k, 0) = ab(i, r-k, 0) + bb(i, 0, k)
        bb(i, 0, k) = 0.D0
        ab(i, r-k, 1) = ab(i, r-k, 1) + y1hatb
        ab(i, k, 1) = ab(i, k, 1) + y1hatb
        ab(i, k, 0) = ab(i, k, 0) + x1hatb
        ab(i, r-k, 0) = ab(i, r-k, 0) - x1hatb
      END DO
    END DO
  ELSE
    DO k=(r-1)/2,1,-1
      kp = r - k
      sk = sine(k)
      ck = cosine(k)
      DO i=p-1,0,-1
        y1hatb = ck*bb(i, 1, kp)
        x1hatb = sk*bb(i, 1, kp)
        bb(i, 1, kp) = 0.D0
        x1hatb = x1hatb + ck*bb(i, 1, k)
        y1hatb = y1hatb - sk*bb(i, 1, k)
        bb(i, 1, k) = 0.D0
        ab(i, kp, 1) = ab(i, kp, 1) + bb(i, 0, kp)
        ab(i, k, 1) = ab(i, k, 1) - bb(i, 0, kp)
        bb(i, 0, kp) = 0.D0
        ab(i, k, 0) = ab(i, k, 0) + bb(i, 0, k)
        ab(i, kp, 0) = ab(i, kp, 0) + bb(i, 0, k)
        bb(i, 0, k) = 0.D0
        ab(i, kp, 1) = ab(i, kp, 1) + y1hatb
        ab(i, k, 1) = ab(i, k, 1) + y1hatb
        ab(i, k, 0) = ab(i, k, 0) + x1hatb
        ab(i, kp, 0) = ab(i, kp, 0) - x1hatb
      END DO
    END DO
  END IF
  DO i=p-1,0,-1
    ab(i, 0, 0) = ab(i, 0, 0) + bb(i, 1, 0)
    ab(i, 0, 1) = ab(i, 0, 1) - bb(i, 1, 0)
    bb(i, 1, 0) = 0.D0
    ab(i, 0, 0) = ab(i, 0, 0) + bb(i, 0, 0)
    ab(i, 0, 1) = ab(i, 0, 1) + bb(i, 0, 0)
    bb(i, 0, 0) = 0.D0
  END DO
END SUBROUTINE C06FQW_B

