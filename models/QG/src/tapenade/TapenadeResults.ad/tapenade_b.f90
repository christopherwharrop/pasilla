!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:54
!
MODULE TAPENADE_B
  IMPLICIT NONE
! value of pi
  REAL*8, PARAMETER :: pi=4d0*ATAN(1d0)
! The truncation is of type T(riangular) nm
  INTEGER, PARAMETER :: nm=21
! Number of longitude points of the Gaussian grid
  INTEGER, PARAMETER :: nlon=64
! Number of latitude  points of the Gaussian grid
  INTEGER, PARAMETER :: nlat=32
! Number of vorticity levels in the vertical (should be set to 3)
  INTEGER, PARAMETER :: nvl=3
! Number of temperature levels in the vertical (equal to nvl-1)
  INTEGER, PARAMETER :: ntl=2
! Half of nsh2
  INTEGER, PARAMETER :: nsh=(nm+1)*(nm+2)/2
  INTEGER, PARAMETER :: nsh2=2*nsh
! Model time step
  INTEGER, PARAMETER :: time_step=1200
  REAL*8, PARAMETER :: nsteps_per_day=24.0d0*3600.0d0/REAL(time_step)
! dimensionless time step
  REAL*8, PARAMETER :: dtt=1d0/nsteps_per_day*pi*4d0
! Model state
! Stream function at the nvl levels
  REAL*8 :: psi(nsh2, nvl)
  REAL*8 :: psib(nsh2, nvl)
! Thickness at the ntl levels
  REAL*8 :: psit(nsh2, ntl)
  REAL*8 :: psitb(nsh2, ntl)
! Potential vorticity
  REAL*8 :: qprime(nsh2, nvl)
  REAL*8 :: qprimeb(nsh2, nvl)
! Model Forcing
! Constant potential vorticity forcing at the nvl levels
  REAL*8, PARAMETER :: for(nsh2, nvl)
! Spectral Coefficients
! Contains numbers 22 down to 1 for index 0 to 21
  INTEGER, PARAMETER :: nshm(0:nm)
! Contains total wavenumber n of each spherical harmonic of the corresponding index
  INTEGER, PARAMETER :: ll(nsh)
  INTEGER :: lat
! Legendre polynomials defined at Gausian latitudes
  REAL*8, PARAMETER :: pp(lat, nsh)
! Mu derivative of Legendre polynomials
  REAL*8, PARAMETER :: pd(lat, nsh)
! Weights for Legendre integrals
  REAL*8, PARAMETER :: pw(lat, nsh)
! contains zonal wavenumber m of each spherical harmonic of the corresponding index for zonal derivative operator
  REAL*8, PARAMETER :: rm(:)
! Laplace/Helmholtz direct and inverse operators
! Laplace and Helmholtz operator for Q-PSI inversion
  REAL*8, PARAMETER :: rinhel(nsh2, 0:5)
! Dissipation coefficients for each spherical harmonic
  REAL*8, PARAMETER :: diss(nsh2, 2)
!   diss(k,1) : Hyperviscosity at the three levels (tdif sets timescale)
!   diss(k,2) : Ekman friction at lower level (tdis sets timescale)
! One over Rossby rad. of def. squared of 200-500 thickness
  REAL*8, PARAMETER :: rl1
! One over Rossby rad. of def. squared of 500-800 thickness
  REAL*8, PARAMETER :: rl2
! Nondimensional relaxation coefficient of 200-500 thickness
  REAL*8, PARAMETER :: relt1
! Nondimensional relaxation coefficient of 500-800 thickness
  REAL*8, PARAMETER :: relt2
! Orography
! Gauss points in radians
  REAL*8, PARAMETER :: phi(nlat)
! Sine of phi
  REAL*8, PARAMETER :: sinfi(nlat)
! Cosine of phi
  REAL*8, PARAMETER :: cosfi(nlat)
! If .true. then orography and land-sea mask dependent friction at the lower level plus Ekman friction, else only Ekman friction
  LOGICAL, PARAMETER :: lgdiss
! Derivative of orog wrt lambda
  REAL*8, PARAMETER :: dorodl(nlat, nlon)
! Derivative of orag wrt sin(fi)
  REAL*8, PARAMETER :: dorodm(nlat, nlon)
! Landsea-mask/orography dependent friction
  REAL*8, PARAMETER :: rdiss(nlat, nlon)
! Landsea-mask/orography dependent friction
  REAL*8, PARAMETER :: ddisdx(nlat, nlon)
! Landsea-mask/orography dependent friction
  REAL*8, PARAMETER :: ddisdy(nlat, nlon)
! Copy of input gaussian grid field
  REAL*8 :: agg_copy(nlat, nlon)
  REAL*8 :: agg_copyb(nlat, nlon)
! Work space used by the nag version of the fft    
  REAL*8 :: tmp(nlat, nlon)
  REAL*8 :: tmpb(nlat, nlon)

CONTAINS
!  Differentiation of adv_nsteps in reverse (adjoint) mode:
!   gradient     of useful results: qprime
!   with respect to varying inputs: psi tmp qprime psit
!   RW status of diff variables: psi:out agg_copy:(loc) tmp:out
!                qprime:in-out psit:out
!-----------------------------------------------------------------------
! performs a fourth order runge kutta time step at truncation nm
! with time step dt
! dqdt calculates the time derivative
! input  qprime at current time
! output qprime at current time plus dt
!-----------------------------------------------------------------------
  SUBROUTINE ADV_NSTEPS_B(nsteps)
    IMPLICIT NONE
    INTEGER :: nsteps
    INTEGER :: step, k, l, nvar
    REAL*8 :: dt2, dt6
    REAL*8 :: y(nsh2, nvl), dydt(nsh2, nvl), yt(nsh2, nvl)
    REAL*8 :: yb(nsh2, nvl), dydtb(nsh2, nvl), ytb(nsh2, nvl)
    REAL*8 :: dyt(nsh2, nvl), dym(nsh2, nvl)
    REAL*8 :: dytb(nsh2, nvl), dymb(nsh2, nvl)
    REAL*8 :: tempb
    nvar = (nm+2)*nm
    dt2 = dtt*0.5d0
    dt6 = dtt/6d0
! Advance the model forward in time n steps
    y = FMTOFS(qprime)
    CALL PUSHREAL8ARRAY(psit, nsh2*ntl)
    CALL PUSHREAL8ARRAY(qprime, nsh2*nvl)
    CALL PUSHREAL8ARRAY(tmp, nlat*nlon)
    CALL PUSHREAL8ARRAY(psi, nsh2*nvl)
    CALL DQDT(y, dydt)
    DO l=1,nvl
      DO k=1,nvar
        yt(k, l) = y(k, l) + dt2*dydt(k, l)
      END DO
    END DO
    CALL PUSHREAL8ARRAY(psit, nsh2*ntl)
    CALL PUSHREAL8ARRAY(tmp, nlat*nlon)
    CALL PUSHREAL8ARRAY(psi, nsh2*nvl)
    CALL DQDT(yt, dyt)
    DO l=1,nvl
      DO k=1,nvar
        CALL PUSHREAL8(yt(k, l))
        yt(k, l) = y(k, l) + dt2*dyt(k, l)
      END DO
    END DO
    CALL PUSHREAL8ARRAY(psit, nsh2*ntl)
    CALL PUSHREAL8ARRAY(tmp, nlat*nlon)
    CALL PUSHREAL8ARRAY(psi, nsh2*nvl)
    CALL DQDT(yt, dym)
    DO l=1,nvl
      DO k=1,nvar
        CALL PUSHREAL8(yt(k, l))
        yt(k, l) = y(k, l) + dtt*dym(k, l)
        dym(k, l) = dyt(k, l) + dym(k, l)
      END DO
    END DO
    CALL PUSHREAL8ARRAY(psit, nsh2*ntl)
    CALL PUSHREAL8ARRAY(tmp, nlat*nlon)
    CALL PUSHREAL8ARRAY(psi, nsh2*nvl)
    CALL DQDT(yt, dyt)
    DO l=1,nvl
      DO k=1,nvar
        CALL PUSHREAL8(y(k, l))
        y(k, l) = y(k, l) + dt6*(dydt(k, l)+dyt(k, l)+2.*dym(k, l))
      END DO
    END DO
    yb = 0.0_8
    CALL FSTOFM_B(y, yb, nm, qprimeb)
    dymb = 0.0_8
    dytb = 0.0_8
    dydtb = 0.0_8
    DO l=nvl,1,-1
      DO k=nvar,1,-1
        CALL POPREAL8(y(k, l))
        tempb = dt6*yb(k, l)
        dydtb(k, l) = dydtb(k, l) + tempb
        dytb(k, l) = dytb(k, l) + tempb
        dymb(k, l) = dymb(k, l) + 2.*tempb
      END DO
    END DO
    CALL POPREAL8ARRAY(psi, nsh2*nvl)
    CALL POPREAL8ARRAY(tmp, nlat*nlon)
    CALL POPREAL8ARRAY(psit, nsh2*ntl)
    ytb = 0.0_8
    psitb = 0.0_8
    tmpb = 0.0_8
    psib = 0.0_8
    CALL DQDT_B(yt, ytb, dyt, dytb)
    dytb = 0.0_8
    DO l=nvl,1,-1
      DO k=nvar,1,-1
        dytb(k, l) = dytb(k, l) + dymb(k, l)
        CALL POPREAL8(yt(k, l))
        yb(k, l) = yb(k, l) + ytb(k, l)
        dymb(k, l) = dymb(k, l) + dtt*ytb(k, l)
        ytb(k, l) = 0.0_8
      END DO
    END DO
    CALL POPREAL8ARRAY(psi, nsh2*nvl)
    CALL POPREAL8ARRAY(tmp, nlat*nlon)
    CALL POPREAL8ARRAY(psit, nsh2*ntl)
    CALL DQDT_B(yt, ytb, dym, dymb)
    DO l=nvl,1,-1
      DO k=nvar,1,-1
        CALL POPREAL8(yt(k, l))
        yb(k, l) = yb(k, l) + ytb(k, l)
        dytb(k, l) = dytb(k, l) + dt2*ytb(k, l)
        ytb(k, l) = 0.0_8
      END DO
    END DO
    CALL POPREAL8ARRAY(psi, nsh2*nvl)
    CALL POPREAL8ARRAY(tmp, nlat*nlon)
    CALL POPREAL8ARRAY(psit, nsh2*ntl)
    CALL DQDT_B(yt, ytb, dyt, dytb)
    DO l=nvl,1,-1
      DO k=nvar,1,-1
        yb(k, l) = yb(k, l) + ytb(k, l)
        dydtb(k, l) = dydtb(k, l) + dt2*ytb(k, l)
        ytb(k, l) = 0.0_8
      END DO
    END DO
    CALL POPREAL8ARRAY(psi, nsh2*nvl)
    CALL POPREAL8ARRAY(tmp, nlat*nlon)
    CALL POPREAL8ARRAY(qprime, nsh2*nvl)
    CALL POPREAL8ARRAY(psit, nsh2*ntl)
    CALL DQDT_B(y, yb, dydt, dydtb)
    CALL FMTOFS_B(qprime, qprimeb, yb)
  END SUBROUTINE ADV_NSTEPS_B
!-----------------------------------------------------------------------
! performs a fourth order runge kutta time step at truncation nm
! with time step dt
! dqdt calculates the time derivative
! input  qprime at current time
! output qprime at current time plus dt
!-----------------------------------------------------------------------
  SUBROUTINE ADV_NSTEPS(nsteps)
    IMPLICIT NONE
    INTEGER :: nsteps
    INTEGER :: step, k, l, nvar
    REAL*8 :: dt2, dt6
    REAL*8 :: y(nsh2, nvl), dydt(nsh2, nvl), yt(nsh2, nvl)
    REAL*8 :: dyt(nsh2, nvl), dym(nsh2, nvl)
    nvar = (nm+2)*nm
    dt2 = dtt*0.5d0
    dt6 = dtt/6d0
! Advance the model forward in time n steps
    y = FMTOFS(qprime)
    CALL DQDT(y, dydt)
    DO l=1,nvl
      DO k=1,nvar
        yt(k, l) = y(k, l) + dt2*dydt(k, l)
      END DO
    END DO
    CALL DQDT(yt, dyt)
    DO l=1,nvl
      DO k=1,nvar
        yt(k, l) = y(k, l) + dt2*dyt(k, l)
      END DO
    END DO
    CALL DQDT(yt, dym)
    DO l=1,nvl
      DO k=1,nvar
        yt(k, l) = y(k, l) + dtt*dym(k, l)
        dym(k, l) = dyt(k, l) + dym(k, l)
      END DO
    END DO
    CALL DQDT(yt, dyt)
    DO l=1,nvl
      DO k=1,nvar
        y(k, l) = y(k, l) + dt6*(dydt(k, l)+dyt(k, l)+2.*dym(k, l))
      END DO
    END DO
    qprime = FSTOFM(y, nm)
! Make stream function consistent with potential vorticity
    CALL QTOPSI(qprime, psi, psit)
  END SUBROUTINE ADV_NSTEPS
!  Differentiation of dqdt in reverse (adjoint) mode:
!   gradient     of useful results: psi tmp psit y dydt
!   with respect to varying inputs: psi tmp psit y
!-----------------------------------------------------------------------
! computation of time derivative of the potential vorticity field
! input  y potential vorticity in french format
! output dydt time derivative of y in french format
! values of qprime,  psi and psit are changed
!-----------------------------------------------------------------------
  SUBROUTINE DQDT_B(y, yb, dydt, dydtb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    REAL*8 :: yb(:, :)
    REAL*8 :: dydt(:, :)
    REAL*8 :: dydtb(:, :)
! time derivative of qprime
    REAL*8 :: dqprdt(nsh2, nvl)
    REAL*8 :: dqprdtb(nsh2, nvl)
    CALL PUSHREAL8ARRAY(qprime, 506*3)
    qprime = FSTOFM(y, nm)
    CALL PUSHREAL8ARRAY(psit, 506*2)
    CALL PUSHREAL8ARRAY(psi, 506*3)
    CALL QTOPSI(qprime, psi, psit)
! qprime --> psi and psit
! psi, psit, qprime, for, diss --> dqprdt
    CALL PUSHREAL8ARRAY(tmp, nlat*nlon)
    dqprdt = DDT(psi, psit, qprime, for)
    CALL FMTOFS_B(dqprdt, dqprdtb, dydtb)
    CALL POPREAL8ARRAY(tmp, nlat*nlon)
    CALL DDT_B(psi, psib, psit, psitb, qprime, qprimeb, for, dqprdtb)
    CALL POPREAL8ARRAY(psi, 506*3)
    CALL POPREAL8ARRAY(psit, 506*2)
    CALL QTOPSI_B(qprime, qprimeb, psi, psib, psit, psitb)
    CALL POPREAL8ARRAY(qprime, 506*3)
    CALL FSTOFM_B(y, yb, nm, qprimeb)
  END SUBROUTINE DQDT_B
!-----------------------------------------------------------------------
! computation of time derivative of the potential vorticity field
! input  y potential vorticity in french format
! output dydt time derivative of y in french format
! values of qprime,  psi and psit are changed
!-----------------------------------------------------------------------
  SUBROUTINE DQDT(y, dydt)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    REAL*8, INTENT(OUT) :: dydt(:, :)
! time derivative of qprime
    REAL*8 :: dqprdt(nsh2, nvl)
    qprime = FSTOFM(y, nm)
    CALL QTOPSI(qprime, psi, psit)
! qprime --> psi and psit
! psi, psit, qprime, for, diss --> dqprdt
    dqprdt = DDT(psi, psit, qprime, for)
    dydt = FMTOFS(dqprdt)
    RETURN
  END SUBROUTINE DQDT
!  Differentiation of ddt in reverse (adjoint) mode:
!   gradient     of useful results: tmp psi dqprdt psit
!   with respect to varying inputs: tmp psi qprime psit
!----------------------------------------------------------------------
! ddt
!
! computation of time derivative of the potential vorticity fields
!
! input qprime,  psi,  psit
! output dqprdt
!----------------------------------------------------------------------
  SUBROUTINE DDT_B(psi, psib, psit, psitb, qprime, qprimeb, for, dqprdtb&
& )
    IMPLICIT NONE
! stream function at the nvl levels
    REAL*8, INTENT(IN) :: psi(nsh2, nvl)
    REAL*8 :: psib(nsh2, nvl)
! thickness at the ntl levels
    REAL*8, INTENT(IN) :: psit(nsh2, ntl)
    REAL*8 :: psitb(nsh2, ntl)
! potential vorticity
    REAL*8, INTENT(IN) :: qprime(nsh2, nvl)
    REAL*8 :: qprimeb(nsh2, nvl)
! constant potential vorticity forcing at the nvl levels
    REAL*8, INTENT(IN) :: for(nsh2, nvl)
    REAL*8 :: dqprdt(nsh2, nvl)
    REAL*8 :: dqprdtb(nsh2, nvl)
    INTEGER :: k, l, i, j
    REAL*8 :: dum1, dum2
    REAL*8 :: dum1b, dum2b
    REAL*8, DIMENSION(nsh2) :: res
    REAL*8, DIMENSION(nsh2) :: resb
    REAL*8, DIMENSION(nsh2) :: res0
    REAL*8, DIMENSION(nsh2) :: resb0
! advection of potential vorticity at upper level
    CALL PUSHREAL8ARRAY(tmp, nlat*nlon)
    res = JACOB(psi(:, 1), qprime(:, 1))
! advection of potential vorticity at middle level
    CALL PUSHREAL8ARRAY(tmp, nlat*nlon)
    res0 = JACOB(psi(:, 2), qprime(:, 2))
! advection of potential vorticity and dissipation at lower level
    qprimeb = 0.0_8
    DO l=3,1,-1
      DO k=nsh2,1,-1
        qprimeb(k, l) = qprimeb(k, l) + diss(k, 1)*dqprdtb(k, l)
      END DO
    END DO
    DO k=nsh2,1,-1
      dum2b = dqprdtb(k, 2) - dqprdtb(k, 3)
      dum1b = dqprdtb(k, 1) - dqprdtb(k, 2)
      psitb(k, 2) = psitb(k, 2) + relt2*dum2b
      psitb(k, 1) = psitb(k, 1) + relt1*dum1b
    END DO
    CALL JACOBD_B(psi(:, 3), psib(:, 3), qprime(:, 3), qprimeb(:, 3), &
&           dqprdtb(:, 3))
    dqprdtb(:, 3) = 0.0_8
    resb0 = dqprdtb(:, 2)
    dqprdtb(:, 2) = 0.0_8
    CALL POPREAL8ARRAY(tmp, nlat*nlon)
    CALL JACOB_B(psi(:, 2), psib(:, 2), qprime(:, 2), qprimeb(:, 2), &
&          resb0)
    resb = dqprdtb(:, 1)
    CALL POPREAL8ARRAY(tmp, nlat*nlon)
    CALL JACOB_B(psi(:, 1), psib(:, 1), qprime(:, 1), qprimeb(:, 1), &
&          resb)
  END SUBROUTINE DDT_B
!----------------------------------------------------------------------
! ddt
!
! computation of time derivative of the potential vorticity fields
!
! input qprime,  psi,  psit
! output dqprdt
!----------------------------------------------------------------------
  FUNCTION DDT(psi, psit, qprime, for) RESULT (DQPRDT)
    IMPLICIT NONE
! stream function at the nvl levels
    REAL*8, INTENT(IN) :: psi(nsh2, nvl)
! thickness at the ntl levels
    REAL*8, INTENT(IN) :: psit(nsh2, ntl)
! potential vorticity
    REAL*8, INTENT(IN) :: qprime(nsh2, nvl)
! constant potential vorticity forcing at the nvl levels
    REAL*8, INTENT(IN) :: for(nsh2, nvl)
    REAL*8 :: dqprdt(nsh2, nvl)
    INTEGER :: k, l, i, j
    REAL*8 :: dum1, dum2
! advection of potential vorticity at upper level
    dqprdt(:, 1) = JACOB(psi(:, 1), qprime(:, 1))
! advection of potential vorticity at middle level
    dqprdt(:, 2) = JACOB(psi(:, 2), qprime(:, 2))
! advection of potential vorticity and dissipation at lower level
    dqprdt(:, 3) = JACOBD(psi(:, 3), qprime(:, 3))
! relaxation of temperature and forcing
    DO k=1,nsh2
      dum1 = relt1*psit(k, 1)
      dum2 = relt2*psit(k, 2)
      dqprdt(k, 1) = dqprdt(k, 1) + dum1 + for(k, 1)
      dqprdt(k, 2) = dqprdt(k, 2) - dum1 + dum2 + for(k, 2)
      dqprdt(k, 3) = dqprdt(k, 3) - dum2 + for(k, 3)
    END DO
! explicit horizontal diffusion
    DO l=1,3
      DO k=1,nsh2
        dqprdt(k, l) = dqprdt(k, l) + diss(k, 1)*qprime(k, l)
      END DO
    END DO
    RETURN
  END FUNCTION DDT
!  Differentiation of jacob in reverse (adjoint) mode:
!   gradient     of useful results: tmp sjacob psiloc pvor
!   with respect to varying inputs: tmp psiloc pvor
!----------------------------------------------------------------------
! advection of potential vorticity
! input psiloc,  pvor
! output sjacob
!----------------------------------------------------------------------
  SUBROUTINE JACOB_B(psiloc, psilocb, pvor, pvorb, sjacobb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: psiloc(nsh2)
    REAL*8 :: psilocb(nsh2)
    REAL*8, INTENT(IN) :: pvor(nsh2)
    REAL*8 :: pvorb(nsh2)
    REAL*8 :: sjacob(nsh2)
    REAL*8 :: sjacobb(nsh2)
    INTEGER :: i, j, k
    REAL*8 :: vv(nsh2)
    REAL*8 :: vvb(nsh2)
    REAL*8 :: dpsidl(nlat, nlon), dpsidm(nlat, nlon), dvordl(nlat, nlon)
    REAL*8 :: dpsidlb(nlat, nlon), dpsidmb(nlat, nlon), dvordlb(nlat, &
&   nlon)
    REAL*8 :: dvordm(nlat, nlon), gjacob(nlat, nlon), dpsidls(nsh2)
    REAL*8 :: dvordmb(nlat, nlon), gjacobb(nlat, nlon), dpsidlsb(nsh2)
! space derivatives of potential vorticity
    vv = DDL(pvor)
    dvordl = SPTOGG_PP(vv)
    dvordm = SPTOGG_PD(pvor)
! space derivatives of streamfunction
    dpsidls = DDL(psiloc)
    dpsidl = SPTOGG_PP(dpsidls)
    dpsidm = SPTOGG_PD(psiloc)
    dpsidlsb = 0.0_8
    DO k=nsh2,1,-1
      dpsidlsb(k) = dpsidlsb(k) - sjacobb(k)
    END DO
    CALL GGTOSP_B(gjacob, gjacobb, sjacobb)
    dpsidlb = 0.0_8
    dpsidmb = 0.0_8
    dvordlb = 0.0_8
    dvordmb = 0.0_8
    DO j=nlon,1,-1
      DO i=nlat,1,-1
        dpsidmb(i, j) = dpsidmb(i, j) + dvordl(i, j)*gjacobb(i, j)
        dvordlb(i, j) = dvordlb(i, j) + dpsidm(i, j)*gjacobb(i, j)
        dpsidlb(i, j) = dpsidlb(i, j) - dvordm(i, j)*gjacobb(i, j)
        dvordmb(i, j) = dvordmb(i, j) - dpsidl(i, j)*gjacobb(i, j)
        gjacobb(i, j) = 0.0_8
      END DO
    END DO
    CALL SPTOGG_PD_B(psiloc, psilocb, dpsidmb)
    CALL SPTOGG_PP_B(dpsidls, dpsidlsb, dpsidlb)
    CALL DDL_B(psiloc, psilocb, dpsidlsb)
    CALL SPTOGG_PD_B(pvor, pvorb, dvordmb)
    vvb = 0.0_8
    CALL SPTOGG_PP_B(vv, vvb, dvordlb)
    CALL DDL_B(pvor, pvorb, vvb)
  END SUBROUTINE JACOB_B
!----------------------------------------------------------------------
! advection of potential vorticity
! input psiloc,  pvor
! output sjacob
!----------------------------------------------------------------------
  FUNCTION JACOB(psiloc, pvor) RESULT (SJACOB)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: psiloc(nsh2)
    REAL*8, INTENT(IN) :: pvor(nsh2)
    REAL*8 :: sjacob(nsh2)
    INTEGER :: i, j, k
    REAL*8 :: vv(nsh2)
    REAL*8 :: dpsidl(nlat, nlon), dpsidm(nlat, nlon), dvordl(nlat, nlon)
    REAL*8 :: dvordm(nlat, nlon), gjacob(nlat, nlon), dpsidls(nsh2)
! space derivatives of potential vorticity
    vv = DDL(pvor)
    dvordl = SPTOGG_PP(vv)
    dvordm = SPTOGG_PD(pvor)
! space derivatives of streamfunction
    dpsidls = DDL(psiloc)
    dpsidl = SPTOGG_PP(dpsidls)
    dpsidm = SPTOGG_PD(psiloc)
! jacobian term
    DO j=1,nlon
      DO i=1,nlat
        gjacob(i, j) = dpsidm(i, j)*dvordl(i, j) - dpsidl(i, j)*dvordm(i&
&         , j)
      END DO
    END DO
    sjacob = GGTOSP(gjacob)
! planetary vorticity advection
    DO k=1,nsh2
      sjacob(k) = sjacob(k) - dpsidls(k)
    END DO
    RETURN
  END FUNCTION JACOB
!  Differentiation of jacobd in reverse (adjoint) mode:
!   gradient     of useful results: tmp sjacob psiloc pvor
!   with respect to varying inputs: tmp psiloc pvor
!----------------------------------------------------------------------
! advection of potential vorticity and dissipation on gaussian grid
! input psiloc,  pvor
! output sjacob
!----------------------------------------------------------------------
  SUBROUTINE JACOBD_B(psiloc, psilocb, pvor, pvorb, sjacobb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: psiloc(nsh2)
    REAL*8 :: psilocb(nsh2)
    REAL*8, INTENT(IN) :: pvor(nsh2)
    REAL*8 :: pvorb(nsh2)
    REAL*8 :: sjacob(nsh2)
    REAL*8 :: sjacobb(nsh2)
    INTEGER :: i, j, k
    REAL*8 :: dpsidl(nlat, nlon), dpsidm(nlat, nlon), dvordl(nlat, nlon)
    REAL*8 :: dpsidlb(nlat, nlon), dpsidmb(nlat, nlon), dvordlb(nlat, &
&   nlon)
    REAL*8 :: dvordm(nlat, nlon), gjacob(nlat, nlon), vv(nsh2)
    REAL*8 :: dvordmb(nlat, nlon), gjacobb(nlat, nlon), vvb(nsh2)
    REAL*8 :: azeta(nlat, nlon), dpsidls(nsh2)
    REAL*8 :: azetab(nlat, nlon), dpsidlsb(nsh2)
    INTEGER :: branch
! space derivatives of potential vorticity 
    vv = DDL(pvor)
    dvordl = SPTOGG_PP(vv)
    dvordm = SPTOGG_PD(pvor)
! space derivatives of streamfunction
    dpsidls = DDL(psiloc)
    dpsidl = SPTOGG_PP(dpsidls)
    dpsidm = SPTOGG_PD(psiloc)
! dissipation 
    IF (lgdiss) THEN
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    dpsidlsb = 0.0_8
    DO k=nsh2,1,-1
      dpsidlsb(k) = dpsidlsb(k) - sjacobb(k)
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO k=nsh2,1,-1
        psilocb(k) = psilocb(k) + diss(k, 2)*sjacobb(k)
      END DO
      CALL GGTOSP_B(gjacob, gjacobb, sjacobb)
      dpsidlb = 0.0_8
      dpsidmb = 0.0_8
      vvb = 0.0_8
    ELSE
      CALL GGTOSP_B(gjacob, gjacobb, sjacobb)
      dpsidlb = 0.0_8
      dpsidmb = 0.0_8
      azetab = 0.0_8
      DO j=nlon,1,-1
        DO i=nlat,1,-1
          dpsidmb(i, j) = dpsidmb(i, j) - ddisdy(i, j)*gjacobb(i, j)
          azetab(i, j) = azetab(i, j) + rdiss(i, j)*gjacobb(i, j)
          dpsidlb(i, j) = dpsidlb(i, j) - ddisdx(i, j)*gjacobb(i, j)
        END DO
      END DO
      vvb = 0.0_8
      CALL SPTOGG_PP_B(vv, vvb, azetab)
      DO k=nsh2,1,-1
        psilocb(k) = psilocb(k) + diss(k, 2)*vvb(k)
        vvb(k) = 0.0_8
      END DO
    END IF
    dvordlb = 0.0_8
    dvordmb = 0.0_8
    DO j=nlon,1,-1
      DO i=nlat,1,-1
        dpsidmb(i, j) = dpsidmb(i, j) + (sinfi(i)*dorodl(i, j)+dvordl(i&
&         , j))*gjacobb(i, j)
        dvordlb(i, j) = dvordlb(i, j) + dpsidm(i, j)*gjacobb(i, j)
        dpsidlb(i, j) = dpsidlb(i, j) - (sinfi(i)*dorodm(i, j)+dvordm(i&
&         , j))*gjacobb(i, j)
        dvordmb(i, j) = dvordmb(i, j) - dpsidl(i, j)*gjacobb(i, j)
        gjacobb(i, j) = 0.0_8
      END DO
    END DO
    CALL SPTOGG_PD_B(psiloc, psilocb, dpsidmb)
    CALL SPTOGG_PP_B(dpsidls, dpsidlsb, dpsidlb)
    CALL DDL_B(psiloc, psilocb, dpsidlsb)
    CALL SPTOGG_PD_B(pvor, pvorb, dvordmb)
    CALL SPTOGG_PP_B(vv, vvb, dvordlb)
    CALL DDL_B(pvor, pvorb, vvb)
  END SUBROUTINE JACOBD_B
!----------------------------------------------------------------------
! advection of potential vorticity and dissipation on gaussian grid
! input psiloc,  pvor
! output sjacob
!----------------------------------------------------------------------
  FUNCTION JACOBD(psiloc, pvor) RESULT (SJACOB)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: psiloc(nsh2)
    REAL*8, INTENT(IN) :: pvor(nsh2)
    REAL*8 :: sjacob(nsh2)
    INTEGER :: i, j, k
    REAL*8 :: dpsidl(nlat, nlon), dpsidm(nlat, nlon), dvordl(nlat, nlon)
    REAL*8 :: dvordm(nlat, nlon), gjacob(nlat, nlon), vv(nsh2)
    REAL*8 :: azeta(nlat, nlon), dpsidls(nsh2)
! space derivatives of potential vorticity 
    vv = DDL(pvor)
    dvordl = SPTOGG_PP(vv)
    dvordm = SPTOGG_PD(pvor)
! space derivatives of streamfunction
    dpsidls = DDL(psiloc)
    dpsidl = SPTOGG_PP(dpsidls)
    dpsidm = SPTOGG_PD(psiloc)
! jacobian term + orographic forcing
    DO j=1,nlon
      DO i=1,nlat
        gjacob(i, j) = dpsidm(i, j)*(dvordl(i, j)+sinfi(i)*dorodl(i, j))&
&         - dpsidl(i, j)*(dvordm(i, j)+sinfi(i)*dorodm(i, j))
      END DO
    END DO
! dissipation 
    IF (lgdiss) THEN
!   spatially varying dissipation 
      DO k=1,nsh2
        vv(k) = diss(k, 2)*psiloc(k)
      END DO
      azeta = SPTOGG_PP(vv)
      DO j=1,nlon
        DO i=1,nlat
          gjacob(i, j) = gjacob(i, j) - dpsidm(i, j)*ddisdy(i, j) - &
&           dpsidl(i, j)*ddisdx(i, j) + rdiss(i, j)*azeta(i, j)
        END DO
      END DO
      sjacob = GGTOSP(gjacob)
    ELSE
!   uniform dissipation
      sjacob = GGTOSP(gjacob)
      DO k=1,nsh2
        sjacob(k) = sjacob(k) + diss(k, 2)*psiloc(k)
      END DO
    END IF
! planetary vorticity advection
    DO k=1,nsh2
      sjacob(k) = sjacob(k) - dpsidls(k)
    END DO
    RETURN
  END FUNCTION JACOBD
!  Differentiation of qtopsi in reverse (adjoint) mode:
!   gradient     of useful results: psi psit qprime
!   with respect to varying inputs: psi psit qprime
!-----------------------------------------------------------------------
! computation of streamfunction from potential vorticity
! input  qprime which is potential vorticity field
! output psi,  the streamfunction and psit,  the layer thicknesses
!-----------------------------------------------------------------------
  SUBROUTINE QTOPSI_B(qprime, qprimeb, psi, psib, psit, psitb)
    IMPLICIT NONE
! potential vorticity
    REAL*8, INTENT(IN) :: qprime(:, :)
    REAL*8 :: qprimeb(:, :)
! stream function at the nvl levels
    REAL*8 :: psi(:, :)
    REAL*8 :: psib(:, :)
! thickness at the ntl levels
    REAL*8 :: psit(:, :)
    REAL*8 :: psitb(:, :)
    INTEGER :: k
    REAL*8 :: r3
! only used as portable workspace
    REAL*8 :: ws(nsh2)
    REAL*8 :: wsb(nsh2)
    INTRINSIC SIZE
    REAL*8 :: tempb
    REAL*8 :: tempb0
    INTEGER :: ad_to
    INTEGER :: ad_to0
    INTEGER :: ad_to1
    DO k=1,SIZE(psi, 1)
      ws(k) = qprime(k, 1) + qprime(k, 3)
      psi(k, 1) = rinhel(k, 1)*(ws(k)+qprime(k, 2))
      psi(k, 2) = ws(k) - 2.d0*qprime(k, 2)
      psi(k, 3) = qprime(k, 1) - qprime(k, 3)
    END DO
    CALL PUSHINTEGER4(k - 1)
    DO k=1,SIZE(psit, 1)
      psit(k, 1) = rinhel(k, 2)*psi(k, 2) + rinhel(k, 3)*psi(k, 3)
      psit(k, 2) = rinhel(k, 4)*psi(k, 2) + rinhel(k, 5)*psi(k, 3)
    END DO
    CALL PUSHINTEGER4(k - 1)
    r3 = 1./3.
    DO k=1,SIZE(psi, 1)
      psi(k, 2) = r3*(psi(k, 1)-psit(k, 1)+psit(k, 2))
      psi(k, 1) = psi(k, 2) + psit(k, 1)
      psi(k, 3) = psi(k, 2) - psit(k, 2)
    END DO
    CALL PUSHINTEGER4(k - 1)
    CALL POPINTEGER4(ad_to1)
    DO k=ad_to1,1,-1
      psib(k, 2) = psib(k, 2) + psib(k, 3)
      psitb(k, 2) = psitb(k, 2) - psib(k, 3)
      psib(k, 3) = 0.0_8
      psib(k, 2) = psib(k, 2) + psib(k, 1)
      psitb(k, 1) = psitb(k, 1) + psib(k, 1)
      psib(k, 1) = 0.0_8
      tempb0 = r3*psib(k, 2)
      psib(k, 1) = psib(k, 1) + tempb0
      psitb(k, 1) = psitb(k, 1) - tempb0
      psitb(k, 2) = psitb(k, 2) + tempb0
      psib(k, 2) = 0.0_8
    END DO
    CALL POPINTEGER4(ad_to0)
    DO k=ad_to0,1,-1
      psib(k, 2) = psib(k, 2) + rinhel(k, 4)*psitb(k, 2)
      psib(k, 3) = psib(k, 3) + rinhel(k, 5)*psitb(k, 2)
      psitb(k, 2) = 0.0_8
      psib(k, 2) = psib(k, 2) + rinhel(k, 2)*psitb(k, 1)
      psib(k, 3) = psib(k, 3) + rinhel(k, 3)*psitb(k, 1)
      psitb(k, 1) = 0.0_8
    END DO
    wsb = 0.0_8
    CALL POPINTEGER4(ad_to)
    DO k=ad_to,1,-1
      qprimeb(k, 1) = qprimeb(k, 1) + psib(k, 3)
      qprimeb(k, 3) = qprimeb(k, 3) - psib(k, 3)
      psib(k, 3) = 0.0_8
      wsb(k) = wsb(k) + psib(k, 2)
      qprimeb(k, 2) = qprimeb(k, 2) - 2.d0*psib(k, 2)
      psib(k, 2) = 0.0_8
      tempb = rinhel(k, 1)*psib(k, 1)
      wsb(k) = wsb(k) + tempb
      qprimeb(k, 2) = qprimeb(k, 2) + tempb
      psib(k, 1) = 0.0_8
      qprimeb(k, 1) = qprimeb(k, 1) + wsb(k)
      qprimeb(k, 3) = qprimeb(k, 3) + wsb(k)
      wsb(k) = 0.0_8
    END DO
  END SUBROUTINE QTOPSI_B
!-----------------------------------------------------------------------
! computation of streamfunction from potential vorticity
! input  qprime which is potential vorticity field
! output psi,  the streamfunction and psit,  the layer thicknesses
!-----------------------------------------------------------------------
  SUBROUTINE QTOPSI(qprime, psi, psit)
    IMPLICIT NONE
! potential vorticity
    REAL*8, INTENT(IN) :: qprime(:, :)
! stream function at the nvl levels
    REAL*8, INTENT(OUT) :: psi(:, :)
! thickness at the ntl levels
    REAL*8, INTENT(OUT) :: psit(:, :)
    INTEGER :: k
    REAL*8 :: r3
! only used as portable workspace
    REAL*8 :: ws(nsh2)
    INTRINSIC SIZE
    DO k=1,SIZE(psi, 1)
      ws(k) = qprime(k, 1) + qprime(k, 3)
      psi(k, 1) = rinhel(k, 1)*(ws(k)+qprime(k, 2))
      psi(k, 2) = ws(k) - 2.d0*qprime(k, 2)
      psi(k, 3) = qprime(k, 1) - qprime(k, 3)
    END DO
    DO k=1,SIZE(psit, 1)
      psit(k, 1) = rinhel(k, 2)*psi(k, 2) + rinhel(k, 3)*psi(k, 3)
      psit(k, 2) = rinhel(k, 4)*psi(k, 2) + rinhel(k, 5)*psi(k, 3)
    END DO
    r3 = 1./3.
    DO k=1,SIZE(psi, 1)
      psi(k, 2) = r3*(psi(k, 1)-psit(k, 1)+psit(k, 2))
      psi(k, 1) = psi(k, 2) + psit(k, 1)
      psi(k, 3) = psi(k, 2) - psit(k, 2)
    END DO
    RETURN
  END SUBROUTINE QTOPSI
!-----------------------------------------------------------------------
! computation of potential vorticity from stream function
! input psi streamfunction
! output qprime,  the potential vorticity and psit,  the layer thick.
!-----------------------------------------------------------------------
  SUBROUTINE PSITOQ(psi, psit, qprime)
    IMPLICIT NONE
! stream function at the nvl levels
    REAL*8, INTENT(IN) :: psi(:, :)
! thickness at the ntl levels
    REAL*8, INTENT(OUT) :: psit(:, :)
! potential vorticity
    REAL*8, INTENT(OUT) :: qprime(:, :)
    INTEGER :: k
    INTRINSIC SIZE
    DO k=1,SIZE(psit, 1)
      psit(k, 1) = psi(k, 1) - psi(k, 2)
      psit(k, 2) = psi(k, 2) - psi(k, 3)
      qprime(k, 1) = rinhel(k, 0)*psi(k, 1) - rl1*psit(k, 1)
      qprime(k, 2) = rinhel(k, 0)*psi(k, 2) + rl1*psit(k, 1) - rl2*psit(&
&       k, 2)
      qprime(k, 3) = rinhel(k, 0)*psi(k, 3) + rl2*psit(k, 2)
    END DO
    RETURN
  END SUBROUTINE PSITOQ
!  Differentiation of fmtofs in reverse (adjoint) mode:
!   gradient     of useful results: z
!   with respect to varying inputs: y
!-----------------------------------------------------------------------
! transforms francos format to the french format for global fields
! input  y spectral coefficients in francos format
! output z spectral coefficients in french format
! fm format:
! k       m  n
! 1       0  0
! 2       0  1
! 3       0  2
! :       :  :
! nm+1    0  nm
! nm+2    1  1 --> real part
! nm+3    1  2 --> real part
! :       :  :
! nm+nm+1 1  nm --> real part
! :       :  :
! :       nm nm --> real part
!  repeat for imaginary part
!  disadvantage: 0 0 mode and imaginary parts of m = 0 modes are obsolete
! fs format stores all m for every n first and has no obsolete indices
! 
! k       m  n
! 1       0  1
! 2       1  1 --> real part
! 3       1  1 --> imaginary part: k = 1-3 is T1 truncation
! 4       0  2
! 5       1  2 --> real part
! 6       1  2 --> imaginary part
! 7       2  2 --> real part
! 8       2  2 --> imaginary part: k = 1-8 is T2 truncation
! etcetera
!-----------------------------------------------------------------------
  SUBROUTINE FMTOFS_B(y, yb, zb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    REAL*8 :: yb(:, :)
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: z
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: zb
    INTEGER :: m, n, k, indx, l
    INTRINSIC SIZE
    INTRINSIC MAX
    INTEGER :: max1
    INTEGER :: branch
    INTEGER :: ad_from
    INTEGER :: ad_to
    DO l=1,SIZE(y, 2)
      CALL PUSHINTEGER4(k)
      k = 1
      DO m=0,nm
        IF (m .LT. 1) THEN
          max1 = 1
        ELSE
          max1 = m
        END IF
        ad_from = max1
        DO n=ad_from,nm
          CALL PUSHINTEGER4(k)
          k = k + 1
          IF (m .EQ. 0) THEN
            CALL PUSHINTEGER4(indx)
            indx = n**2
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHINTEGER4(indx)
            indx = n**2 + 2*m - 1
            CALL PUSHCONTROL1B(1)
          END IF
          IF (m .NE. 0) THEN
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
        END DO
        CALL PUSHINTEGER4(ad_from)
      END DO
    END DO
    CALL PUSHINTEGER4(l - 1)
    yb = 0.0_8
    CALL POPINTEGER4(ad_to)
    DO l=ad_to,1,-1
      DO m=nm,0,-1
        CALL POPINTEGER4(ad_from)
        DO n=nm,ad_from,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            yb(k+nsh, l) = yb(k+nsh, l) + zb(indx+1, l)
            zb(indx+1, l) = 0.0_8
          END IF
          yb(k, l) = yb(k, l) + zb(indx, l)
          zb(indx, l) = 0.0_8
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPINTEGER4(indx)
          ELSE
            CALL POPINTEGER4(indx)
          END IF
          CALL POPINTEGER4(k)
        END DO
      END DO
      CALL POPINTEGER4(k)
    END DO
  END SUBROUTINE FMTOFS_B
!-----------------------------------------------------------------------
! transforms francos format to the french format for global fields
! input  y spectral coefficients in francos format
! output z spectral coefficients in french format
! fm format:
! k       m  n
! 1       0  0
! 2       0  1
! 3       0  2
! :       :  :
! nm+1    0  nm
! nm+2    1  1 --> real part
! nm+3    1  2 --> real part
! :       :  :
! nm+nm+1 1  nm --> real part
! :       :  :
! :       nm nm --> real part
!  repeat for imaginary part
!  disadvantage: 0 0 mode and imaginary parts of m = 0 modes are obsolete
! fs format stores all m for every n first and has no obsolete indices
! 
! k       m  n
! 1       0  1
! 2       1  1 --> real part
! 3       1  1 --> imaginary part: k = 1-3 is T1 truncation
! 4       0  2
! 5       1  2 --> real part
! 6       1  2 --> imaginary part
! 7       2  2 --> real part
! 8       2  2 --> imaginary part: k = 1-8 is T2 truncation
! etcetera
!-----------------------------------------------------------------------
  FUNCTION FMTOFS(y) RESULT (Z)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: z
    INTEGER :: m, n, k, indx, l
    INTRINSIC SIZE
    INTRINSIC MAX
    INTEGER :: max1
    DO l=1,SIZE(y, 2)
      k = 1
      DO m=0,nm
        IF (m .LT. 1) THEN
          max1 = 1
        ELSE
          max1 = m
        END IF
        DO n=max1,nm
          k = k + 1
          IF (m .EQ. 0) THEN
            indx = n**2
          ELSE
            indx = n**2 + 2*m - 1
          END IF
          z(indx, l) = y(k, l)
          IF (m .NE. 0) z(indx+1, l) = y(k+nsh, l)
        END DO
      END DO
    END DO
    RETURN
  END FUNCTION FMTOFS
!  Differentiation of fstofm in reverse (adjoint) mode:
!   gradient     of useful results: y z
!   with respect to varying inputs: y
!-----------------------------------------------------------------------
! transforms the french format to francos format for global fields
! input  y spectral coef. in french format,  ntr is truncation limit
! output z spectral coefficients in francos format
! fm format:
! k       m  n
! 1       0  0
! 2       0  1
! 3       0  2
! :       :  :
! nm+1    0  nm
! nm+2    1  1 --> real part
! nm+3    1  2 --> real part
! :       :  :
! nm+nm+1 1  nm --> real part
! :       :  :
! :       nm nm --> real part
!  repeat for imaginary part
!  disadvantage: 0 0 mode and imaginary parts of m = 0 modes are obsolete
! fs format stores all m for every n first and has no obsolete indices
! 
! k       m  n
! 1       0  1
! 2       1  1 --> real part
! 3       1  1 --> imaginary part: k = 1-3 is T1 truncation
! 4       0  2
! 5       1  2 --> real part
! 6       1  2 --> imaginary part
! 7       2  2 --> real part
! 8       2  2 --> imaginary part: k = 1-8 is T2 truncation
! etcetera
!-----------------------------------------------------------------------
  SUBROUTINE FSTOFM_B(y, yb, ntr, zb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    REAL*8 :: yb(:, :)
    INTEGER, INTENT(IN) :: ntr
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: z
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: zb
    INTEGER :: m, n, k, indx, i, l
    INTRINSIC SIZE
    INTRINSIC MAX
    INTEGER :: max1
    INTEGER :: ad_to
    INTEGER :: branch
    INTEGER :: ad_from
    INTEGER :: ad_to0
    DO l=1,SIZE(y, 2)
      DO i=1,SIZE(y, 1)

      END DO
      CALL PUSHINTEGER4(i - 1)
      CALL PUSHINTEGER4(k)
      k = 1
      DO m=0,nm
        IF (m .LT. 1) THEN
          max1 = 1
        ELSE
          max1 = m
        END IF
        ad_from = max1
        DO n=ad_from,nm
          CALL PUSHINTEGER4(k)
          k = k + 1
          IF (m .LE. ntr .AND. n .LE. ntr) THEN
            IF (m .EQ. 0) THEN
              CALL PUSHINTEGER4(indx)
              indx = n**2
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHINTEGER4(indx)
              indx = n**2 + 2*m - 1
              CALL PUSHCONTROL1B(1)
            END IF
            IF (m .NE. 0) THEN
              CALL PUSHCONTROL2B(0)
            ELSE
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            CALL PUSHCONTROL2B(2)
          END IF
        END DO
        CALL PUSHINTEGER4(ad_from)
      END DO
    END DO
    CALL PUSHINTEGER4(l - 1)
    CALL POPINTEGER4(ad_to0)
    DO l=ad_to0,1,-1
      DO m=nm,0,-1
        CALL POPINTEGER4(ad_from)
        DO n=nm,ad_from,-1
          CALL POPCONTROL2B(branch)
          IF (branch .EQ. 0) THEN
            yb(indx+1, l) = yb(indx+1, l) + zb(k+nsh, l)
            zb(k+nsh, l) = 0.0_8
          ELSE IF (branch .NE. 1) THEN
            GOTO 100
          END IF
          yb(indx, l) = yb(indx, l) + zb(k, l)
          zb(k, l) = 0.0_8
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPINTEGER4(indx)
          ELSE
            CALL POPINTEGER4(indx)
          END IF
 100      CALL POPINTEGER4(k)
        END DO
      END DO
      CALL POPINTEGER4(k)
      CALL POPINTEGER4(ad_to)
      DO i=ad_to,1,-1
        zb(i, l) = 0.0_8
      END DO
    END DO
  END SUBROUTINE FSTOFM_B
!-----------------------------------------------------------------------
! transforms the french format to francos format for global fields
! input  y spectral coef. in french format,  ntr is truncation limit
! output z spectral coefficients in francos format
! fm format:
! k       m  n
! 1       0  0
! 2       0  1
! 3       0  2
! :       :  :
! nm+1    0  nm
! nm+2    1  1 --> real part
! nm+3    1  2 --> real part
! :       :  :
! nm+nm+1 1  nm --> real part
! :       :  :
! :       nm nm --> real part
!  repeat for imaginary part
!  disadvantage: 0 0 mode and imaginary parts of m = 0 modes are obsolete
! fs format stores all m for every n first and has no obsolete indices
! 
! k       m  n
! 1       0  1
! 2       1  1 --> real part
! 3       1  1 --> imaginary part: k = 1-3 is T1 truncation
! 4       0  2
! 5       1  2 --> real part
! 6       1  2 --> imaginary part
! 7       2  2 --> real part
! 8       2  2 --> imaginary part: k = 1-8 is T2 truncation
! etcetera
!-----------------------------------------------------------------------
  FUNCTION FSTOFM(y, ntr) RESULT (Z)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    INTEGER, INTENT(IN) :: ntr
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: z
    INTEGER :: m, n, k, indx, i, l
    INTRINSIC SIZE
    INTRINSIC MAX
    INTEGER :: max1
    DO l=1,SIZE(y, 2)
      DO i=1,SIZE(y, 1)
        z(i, l) = 0d0
      END DO
      k = 1
      DO m=0,nm
        IF (m .LT. 1) THEN
          max1 = 1
        ELSE
          max1 = m
        END IF
        DO n=max1,nm
          k = k + 1
          IF (m .LE. ntr .AND. n .LE. ntr) THEN
            IF (m .EQ. 0) THEN
              indx = n**2
            ELSE
              indx = n**2 + 2*m - 1
            END IF
            z(k, l) = y(indx, l)
            IF (m .NE. 0) z(k+nsh, l) = y(indx+1, l)
          END IF
        END DO
      END DO
    END DO
    RETURN
  END FUNCTION FSTOFM
!  Differentiation of sptogg_pp in reverse (adjoint) mode:
!   gradient     of useful results: tmp agg as
!   with respect to varying inputs: tmp as
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid using
! legendre polynomials
!
! input  spectral field as
! output gaussian grid agg
!-----------------------------------------------------------------------
  SUBROUTINE SPTOGG_PP_B(as, asb, aggb)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: as(nsh, 2)
    REAL*8 :: asb(nsh, 2)
! Return value
    REAL*8 :: agg(nlat, nlon)
    REAL*8 :: aggb(nlat, nlon)
    CALL SPTOGG_B(as, asb, pp, aggb)
  END SUBROUTINE SPTOGG_PP_B
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid using
! legendre polynomials
!
! input  spectral field as
! output gaussian grid agg
!-----------------------------------------------------------------------
  FUNCTION SPTOGG_PP(as) RESULT (AGG)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: as(nsh, 2)
! Return value
    REAL*8 :: agg(nlat, nlon)
    agg = SPTOGG(as, pp)
  END FUNCTION SPTOGG_PP
!  Differentiation of sptogg_pd in reverse (adjoint) mode:
!   gradient     of useful results: tmp agg as
!   with respect to varying inputs: tmp as
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid using
! derivatives with respect to sin(fi) .
!
! input  spectral field as
! output gaussian grid agg
!-----------------------------------------------------------------------
  SUBROUTINE SPTOGG_PD_B(as, asb, aggb)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: as(nsh, 2)
    REAL*8 :: asb(nsh, 2)
! Return value
    REAL*8 :: agg(nlat, nlon)
    REAL*8 :: aggb(nlat, nlon)
    CALL SPTOGG_B(as, asb, pd, aggb)
  END SUBROUTINE SPTOGG_PD_B
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid using
! derivatives with respect to sin(fi) .
!
! input  spectral field as
! output gaussian grid agg
!-----------------------------------------------------------------------
  FUNCTION SPTOGG_PD(as) RESULT (AGG)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: as(nsh, 2)
! Return value
    REAL*8 :: agg(nlat, nlon)
    agg = SPTOGG(as, pd)
  END FUNCTION SPTOGG_PD
!  Differentiation of sptogg in reverse (adjoint) mode:
!   gradient     of useful results: tmp agg as
!   with respect to varying inputs: tmp as
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid
! input  spectral field as,  legendre polynomials pploc (pp or pd) 
!        where pp are legendre polynomials and pd derivatives with
!        respect to sin(fi)
! output gaussian grid agg
!-----------------------------------------------------------------------
  SUBROUTINE SPTOGG_B(as, asb, pploc, aggb)
    IMPLICIT NONE
! Input 
    REAL*8, INTENT(IN) :: as(:, :)
    REAL*8 :: asb(:, :)
    REAL*8, INTENT(IN) :: pploc(:, :)
! Return value
    REAL*8 :: agg(nlat, nlon)
    REAL*8 :: aggb(nlat, nlon)
! Local data
!    real*8, allocatable :: tmp(:,:)   ! Work space used by the nag version of the fft    
    INTEGER :: i, j, k, k1, k2, m, mi, mr, nlon1
    INTEGER :: ifail
    REAL :: trigi
    INTEGER :: ad_to
    INTEGER :: ad_from
    INTEGER :: ad_to0
    nlon1 = nlon + 1
    k2 = nshm(0)
    k = k2 + 1
    CALL PUSHINTEGER4(k - 1)
    DO m=1,nm
      CALL PUSHINTEGER4(mr)
      mr = m + 1
      CALL PUSHINTEGER4(mi)
      mi = nlon1 - m
      k1 = k2 + 1
      k2 = k2 + nshm(m)
      ad_from = k1
      k = k2 + 1
      CALL PUSHINTEGER4(k - 1)
      CALL PUSHINTEGER4(ad_from)
    END DO
    CALL C06FQF_B(nlat, nlon, agg, aggb, 'r', trigi, tmp, tmpb, ifail)
    DO m=nm,1,-1
      CALL POPINTEGER4(ad_from)
      CALL POPINTEGER4(ad_to0)
      DO k=ad_to0,ad_from,-1
        DO i=nlat,1,-1
          asb(k, 2) = asb(k, 2) - pploc(i, k)*aggb(i, mi)
        END DO
        DO i=nlat,1,-1
          asb(k, 1) = asb(k, 1) + pploc(i, k)*aggb(i, mr)
        END DO
      END DO
      CALL POPINTEGER4(mi)
      CALL POPINTEGER4(mr)
    END DO
    CALL POPINTEGER4(ad_to)
    DO k=ad_to,1,-1
      DO i=nlat,1,-1
        asb(k, 1) = asb(k, 1) + pploc(i, k)*aggb(i, 1)
      END DO
    END DO
  END SUBROUTINE SPTOGG_B
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid
! input  spectral field as,  legendre polynomials pploc (pp or pd) 
!        where pp are legendre polynomials and pd derivatives with
!        respect to sin(fi)
! output gaussian grid agg
!-----------------------------------------------------------------------
  FUNCTION SPTOGG(as, pploc) RESULT (AGG)
    IMPLICIT NONE
! Input 
    REAL*8, INTENT(IN) :: as(:, :)
    REAL*8, INTENT(IN) :: pploc(:, :)
! Return value
    REAL*8 :: agg(nlat, nlon)
! Local data
!    real*8, allocatable :: tmp(:,:)   ! Work space used by the nag version of the fft    
    INTEGER :: i, j, k, k1, k2, m, mi, mr, nlon1
    INTEGER :: ifail
    REAL :: trigi
! inverse legendre transform
    DO j=1,nlon
      DO i=1,nlat
        agg(i, j) = 0.0d0
      END DO
    END DO
    nlon1 = nlon + 1
    k2 = nshm(0)
    DO k=1,k2
      DO i=1,nlat
        agg(i, 1) = agg(i, 1) + as(k, 1)*pploc(i, k)
      END DO
    END DO
    DO m=1,nm
      mr = m + 1
      mi = nlon1 - m
      k1 = k2 + 1
      k2 = k2 + nshm(m)
      DO k=k1,k2
        DO i=1,nlat
          agg(i, mr) = agg(i, mr) + as(k, 1)*pploc(i, k)
        END DO
        DO i=1,nlat
          agg(i, mi) = agg(i, mi) - as(k, 2)*pploc(i, k)
        END DO
      END DO
    END DO
! inverse fourier transform
    ifail = 0
!   allocate(tmp(nlat,nlon))
    CALL C06FQF(nlat, nlon, agg, 'r', trigi, tmp, ifail)
  END FUNCTION SPTOGG
!  Differentiation of ggtosp in reverse (adjoint) mode:
!   gradient     of useful results: tmp as
!   with respect to varying inputs: tmp agg
!-----------------------------------------------------------------------
! conversion from gaussian grid (agg) to spectral coefficients (as)
! input gaussian grid field agg
! output as contains spectral coefficients
!-----------------------------------------------------------------------
  SUBROUTINE GGTOSP_B(agg, aggb, asb)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: agg(:, :)
    REAL*8 :: aggb(:, :)
! Return value
    REAL*8 :: as(nsh, 2)
    REAL*8 :: asb(nsh, 2)
! Local data
    INTEGER :: i, k, k1, k2, m, mi, mr, nlon1
    INTEGER :: ifail
    REAL :: trigd
! Make a local copy of agg so it is not destroyed by c06fpf
!    allocate(agg_copy(nlat,nlon))
! fourier transform
!    allocate(tmp(nlat,nlon))
    INTEGER :: ad_to
    INTEGER :: ad_from
    INTEGER :: ad_to0
    nlon1 = nlon + 1
    k2 = nshm(0)
    k = k2 + 1
    CALL PUSHINTEGER4(k - 1)
    DO m=1,nm
      CALL PUSHINTEGER4(mr)
      mr = m + 1
      CALL PUSHINTEGER4(mi)
      mi = nlon1 - m
      k1 = k2 + 1
      k2 = k2 + nshm(m)
      ad_from = k1
      k = k2 + 1
      CALL PUSHINTEGER4(k - 1)
      CALL PUSHINTEGER4(ad_from)
    END DO
    agg_copyb = 0.0_8
    DO m=nm,1,-1
      CALL POPINTEGER4(ad_from)
      CALL POPINTEGER4(ad_to0)
      DO k=ad_to0,ad_from,-1
        DO i=nlat,1,-1
          agg_copyb(i, mi) = agg_copyb(i, mi) + pw(i, k)*asb(k, 2)
          agg_copyb(i, mr) = agg_copyb(i, mr) + pw(i, k)*asb(k, 1)
        END DO
      END DO
      CALL POPINTEGER4(mi)
      CALL POPINTEGER4(mr)
    END DO
    CALL POPINTEGER4(ad_to)
    DO k=ad_to,1,-1
      DO i=nlat,1,-1
        agg_copyb(i, 1) = agg_copyb(i, 1) + pw(i, k)*asb(k, 1)
      END DO
    END DO
    CALL C06FPF_B(nlat, nlon, agg_copy, agg_copyb, 'r', trigd, tmp, tmpb&
&           , ifail)
    aggb = 0.0_8
    aggb(:, :) = agg_copyb(:, :)
  END SUBROUTINE GGTOSP_B
!-----------------------------------------------------------------------
! conversion from gaussian grid (agg) to spectral coefficients (as)
! input gaussian grid field agg
! output as contains spectral coefficients
!-----------------------------------------------------------------------
  FUNCTION GGTOSP(agg) RESULT (AS)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: agg(:, :)
! Return value
    REAL*8 :: as(nsh, 2)
! Local data
    INTEGER :: i, k, k1, k2, m, mi, mr, nlon1
    INTEGER :: ifail
    REAL :: trigd
! Make a local copy of agg so it is not destroyed by c06fpf
!    allocate(agg_copy(nlat,nlon))
    agg_copy(:, :) = agg(:, :)
! fourier transform
    ifail = 0
!    allocate(tmp(nlat,nlon))
    CALL C06FPF(nlat, nlon, agg_copy, 'r', trigd, tmp, ifail)
! legendre transform
    DO i=1,2
      DO k=1,nsh
        as(k, i) = 0.0d0
      END DO
    END DO
    nlon1 = nlon + 1
    k2 = nshm(0)
    DO k=1,k2
      DO i=1,nlat
        as(k, 1) = as(k, 1) + agg_copy(i, 1)*pw(i, k)
      END DO
    END DO
    DO m=1,nm
      mr = m + 1
      mi = nlon1 - m
      k1 = k2 + 1
      k2 = k2 + nshm(m)
      DO k=k1,k2
        DO i=1,nlat
          as(k, 1) = as(k, 1) + agg_copy(i, mr)*pw(i, k)
          as(k, 2) = as(k, 2) + agg_copy(i, mi)*pw(i, k)
        END DO
      END DO
    END DO
  END FUNCTION GGTOSP
!  Differentiation of ddl in reverse (adjoint) mode:
!   gradient     of useful results: as dadl
!   with respect to varying inputs: as
!-----------------------------------------------------------------------
! zonal derivative in spectral space
! input spectral field as
! output spectral field dadl which is as differentiated wrt lambda
!-----------------------------------------------------------------------
  SUBROUTINE DDL_B(as, asb, dadlb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: as(nsh, 2)
    REAL*8 :: asb(nsh, 2)
    REAL*8 :: dadl(nsh, 2)
    REAL*8 :: dadlb(nsh, 2)
    INTEGER :: k
    DO k=nsh,1,-1
      asb(k, 1) = asb(k, 1) + rm(k)*dadlb(k, 2)
      dadlb(k, 2) = 0.0_8
      asb(k, 2) = asb(k, 2) - rm(k)*dadlb(k, 1)
      dadlb(k, 1) = 0.0_8
    END DO
  END SUBROUTINE DDL_B
!-----------------------------------------------------------------------
! zonal derivative in spectral space
! input spectral field as
! output spectral field dadl which is as differentiated wrt lambda
!-----------------------------------------------------------------------
  FUNCTION DDL(as) RESULT (DADL)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: as(nsh, 2)
    REAL*8 :: dadl(nsh, 2)
    INTEGER :: k
    DO k=1,nsh
      dadl(k, 1) = -(rm(k)*as(k, 2))
      dadl(k, 2) = rm(k)*as(k, 1)
    END DO
    RETURN
  END FUNCTION DDL
END MODULE TAPENADE_B
