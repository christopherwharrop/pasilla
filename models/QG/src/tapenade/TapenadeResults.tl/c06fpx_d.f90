!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:54
!
!  Differentiation of c06fpx in forward (tangent) mode:
!   variations   of useful results: a b
!   with respect to varying inputs: a b
SUBROUTINE C06FPX_D(a, ad, b, bd, m, n, q, nq, trig)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!
!     Real to Hermitian Fast Fourier Transform Kernel Driver
!
!     Mixed-radix, self-sorting, decimation in time
!
!     .. Scalar Arguments ..
  INTEGER :: m, n, nq
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:m*n-1), b(0:m*n-1), trig(0:2*n-1)
  DOUBLE PRECISION :: ad(0:m*n-1), bd(0:m*n-1)
  INTEGER :: q(nq)
!     .. Local Scalars ..
  DOUBLE PRECISION :: factor
  INTEGER :: i, p, qi, r
  LOGICAL :: ina
!     .. External Subroutines ..
  EXTERNAL C06FPR, C06FPS, C06FPT, C06FPU, C06FPV, C06FPW
  EXTERNAL C06FPR_D, C06FPS_D, C06FPT_D, C06FPU_D, C06FPV_D, C06FPW_D
!     .. Intrinsic Functions ..
  INTRINSIC SQRT, DBLE
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: result1
!     .. Executable Statements ..
  ina = .true.
  p = n
  r = 1
  IF (n .EQ. 1) THEN
    RETURN
  ELSE
    DO i=nq,1,-1
      qi = q(i)
      p = p/qi
      IF (ina) THEN
        IF (qi .EQ. 2) THEN
          CALL C06FPW_D(a, ad, b, bd, m*p, r, trig((p-1)*qi*r), trig(n+(&
&                 p-1)*qi*r))
        ELSE IF (qi .EQ. 3) THEN
          CALL C06FPV_D(a, ad, b, bd, m*p, r, trig((p-1)*qi*r), trig(n+(&
&                 p-1)*qi*r))
        ELSE IF (qi .EQ. 4) THEN
          CALL C06FPU_D(a, ad, b, bd, m*p, r, trig((p-1)*qi*r), trig(n+(&
&                 p-1)*qi*r))
        ELSE IF (qi .EQ. 5) THEN
          CALL C06FPT_D(a, ad, b, bd, m*p, r, trig((p-1)*qi*r), trig(n+(&
&                 p-1)*qi*r))
        ELSE IF (qi .EQ. 6) THEN
          CALL C06FPS_D(a, ad, b, bd, m*p, r, trig((p-1)*qi*r), trig(n+(&
&                 p-1)*qi*r))
        ELSE
          CALL C06FPR_D(a, ad, b, bd, m*p, qi, r, trig((p-1)*qi*r), trig&
&                 (n+(p-1)*qi*r))
        END IF
      ELSE IF (qi .EQ. 2) THEN
        CALL C06FPW_D(b, bd, a, ad, m*p, r, trig((p-1)*qi*r), trig(n+(p-&
&               1)*qi*r))
      ELSE IF (qi .EQ. 3) THEN
        CALL C06FPV_D(b, bd, a, ad, m*p, r, trig((p-1)*qi*r), trig(n+(p-&
&               1)*qi*r))
      ELSE IF (qi .EQ. 4) THEN
        CALL C06FPU_D(b, bd, a, ad, m*p, r, trig((p-1)*qi*r), trig(n+(p-&
&               1)*qi*r))
      ELSE IF (qi .EQ. 5) THEN
        CALL C06FPT_D(b, bd, a, ad, m*p, r, trig((p-1)*qi*r), trig(n+(p-&
&               1)*qi*r))
      ELSE IF (qi .EQ. 6) THEN
        CALL C06FPS_D(b, bd, a, ad, m*p, r, trig((p-1)*qi*r), trig(n+(p-&
&               1)*qi*r))
      ELSE
        CALL C06FPR_D(b, bd, a, ad, m*p, qi, r, trig((p-1)*qi*r), trig(n&
&               +(p-1)*qi*r))
      END IF
      ina = .NOT.ina
      r = r*qi
    END DO
!
    arg1 = DBLE(n)
    result1 = SQRT(arg1)
    factor = 1.0d0/result1
    IF (ina) THEN
      DO i=0,m*n-1
        ad(i) = factor*ad(i)
        a(i) = a(i)*factor
      END DO
    ELSE
      DO i=0,m*n-1
        ad(i) = factor*bd(i)
        a(i) = b(i)*factor
      END DO
    END IF
!
    RETURN
  END IF
END SUBROUTINE C06FPX_D
