!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:54
!
!  Differentiation of c06fqx in forward (tangent) mode:
!   variations   of useful results: a b
!   with respect to varying inputs: a b
SUBROUTINE C06FQX_D(a, ad, b, bd, m, n, q, nq, trig)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!
!     Hermitian to Real Fast Fourier Transform Kernel Driver
!
!     Self-sorting, decimation in frequency
!
!     .. Scalar Arguments ..
  INTEGER :: m, n, nq
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:m*n-1), b(0:m*n-1), trig(0:2*n-1)
  DOUBLE PRECISION :: ad(0:m*n-1), bd(0:m*n-1)
  INTEGER :: q(nq)
!     .. Local Scalars ..
  DOUBLE PRECISION :: factor
  INTEGER :: i, p, qi, r
  LOGICAL :: ina
!     .. External Subroutines ..
  EXTERNAL C06FQQ, C06FQR, C06FQS, C06FQT, C06FQU, C06FQV, C06FQW
  EXTERNAL C06FQQ_D, C06FQR_D, C06FQS_D, C06FQT_D, C06FQU_D, C06FQV_D, &
&     C06FQW_D
!     .. Intrinsic Functions ..
  INTRINSIC SQRT, DBLE
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: result1
!     .. Executable Statements ..
  ina = .true.
  p = 1
  r = n
  IF (n .EQ. 1) THEN
    RETURN
  ELSE
    CALL C06FQQ_D(a, ad, m, n)
    DO i=1,nq
      qi = q(i)
      r = r/qi
      IF (ina) THEN
        IF (qi .EQ. 2) THEN
          CALL C06FQW_D(a, ad, b, bd, m*p, r, trig((p-1)*qi*r), trig(n+(&
&                 p-1)*qi*r))
        ELSE IF (qi .EQ. 3) THEN
          CALL C06FQV_D(a, ad, b, bd, m*p, r, trig((p-1)*qi*r), trig(n+(&
&                 p-1)*qi*r))
        ELSE IF (qi .EQ. 4) THEN
          CALL C06FQU_D(a, ad, b, bd, m*p, r, trig((p-1)*qi*r), trig(n+(&
&                 p-1)*qi*r))
        ELSE IF (qi .EQ. 5) THEN
          CALL C06FQT_D(a, ad, b, bd, m*p, r, trig((p-1)*qi*r), trig(n+(&
&                 p-1)*qi*r))
        ELSE IF (qi .EQ. 6) THEN
          CALL C06FQS_D(a, ad, b, bd, m*p, r, trig((p-1)*qi*r), trig(n+(&
&                 p-1)*qi*r))
        ELSE
          CALL C06FQR_D(a, ad, b, bd, m*p, qi, r, trig((p-1)*qi*r), trig&
&                 (n+(p-1)*qi*r))
        END IF
      ELSE IF (qi .EQ. 2) THEN
        CALL C06FQW_D(b, bd, a, ad, m*p, r, trig((p-1)*qi*r), trig(n+(p-&
&               1)*qi*r))
      ELSE IF (qi .EQ. 3) THEN
        CALL C06FQV_D(b, bd, a, ad, m*p, r, trig((p-1)*qi*r), trig(n+(p-&
&               1)*qi*r))
      ELSE IF (qi .EQ. 4) THEN
        CALL C06FQU_D(b, bd, a, ad, m*p, r, trig((p-1)*qi*r), trig(n+(p-&
&               1)*qi*r))
      ELSE IF (qi .EQ. 5) THEN
        CALL C06FQT_D(b, bd, a, ad, m*p, r, trig((p-1)*qi*r), trig(n+(p-&
&               1)*qi*r))
      ELSE IF (qi .EQ. 6) THEN
        CALL C06FQS_D(b, bd, a, ad, m*p, r, trig((p-1)*qi*r), trig(n+(p-&
&               1)*qi*r))
      ELSE
        CALL C06FQR_D(b, bd, a, ad, m*p, qi, r, trig((p-1)*qi*r), trig(n&
&               +(p-1)*qi*r))
      END IF
      ina = .NOT.ina
      p = p*qi
    END DO
!
    arg1 = DBLE(n)
    result1 = SQRT(arg1)
    factor = 2.0d0/result1
    IF (ina) THEN
      DO i=0,m*n-1
        ad(i) = factor*ad(i)
        a(i) = a(i)*factor
      END DO
    ELSE
      DO i=0,m*n-1
        ad(i) = factor*bd(i)
        a(i) = b(i)*factor
      END DO
    END IF
!
    RETURN
  END IF
END SUBROUTINE C06FQX_D
