!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:54
!
!  Differentiation of c06fpf in forward (tangent) mode:
!   variations   of useful results: x work
!   with respect to varying inputs: x work
SUBROUTINE C06FPF_D(m, n, x, xd, init, trig, work, workd, ifail)
  IMPLICIT NONE
!VD$R NOVECTOR
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     .. Parameters ..
  CHARACTER(len=6) :: srname
  PARAMETER (srname='C06FPF')
!     .. Scalar Arguments ..
  INTEGER :: ifail, m, n
  CHARACTER(len=1) :: init
!     .. Array Arguments ..
  DOUBLE PRECISION :: trig(2*n), work(m*n), x(m*n)
  DOUBLE PRECISION :: workd(m*n), xd(m*n)
!     .. Local Scalars ..
  INTEGER :: ierror, nq, nrec
!     .. Local Arrays ..
  INTEGER :: q(30)
  CHARACTER(len=80) :: rec(1)
  EXTERNAL P01ABF
!     .. External Functions ..
  INTEGER :: P01ABF
!     .. External Subroutines ..
  EXTERNAL C06FPQ, C06FPX
  EXTERNAL C06FPX_D
!     .. Executable Statements ..
  CALL C06FPQ(m, n, init, trig, q, nq, ierror)
  IF (ierror .EQ. 0) CALL C06FPX_D(x, xd, work, workd, m, n, q, nq, trig&
&                           )
!CWH      ELSE IF (IERROR.EQ.1) THEN
!CWH         WRITE (REC(1),FMT=99999) M
!CWH      ELSE IF (IERROR.EQ.2) THEN
!CWH         WRITE (REC(1),FMT=99998) N
!CWH      ELSE IF (IERROR.EQ.3) THEN
!CWH         WRITE (REC(1),FMT=99997) INIT
!CWH      ELSE IF (IERROR.EQ.4) THEN
!CWH         WRITE (REC(1),FMT=99996) INIT
!CWH      ELSE IF (IERROR.EQ.5) THEN
!CWH         WRITE (REC(1),FMT=99995) INIT
!
  nrec = 1
  ifail = P01ABF(ifail, ierror, srname, nrec, rec)
!
  RETURN
!
99999 FORMAT(' ** M must be at least 1: M = ',i16)
99998 FORMAT(' ** N must be at least 1: N = ',i16)
99997 FORMAT(' ** ',a1,' is an invalid value of INIT')
99996 FORMAT(' ** INIT = ',a1,', but TRIG array never initialized')
99995 FORMAT(' ** INIT = ',a1,', but N and TRIG array incompatible')
END SUBROUTINE C06FPF_D

!  Differentiation of c06fpx in forward (tangent) mode:
!   variations   of useful results: a b
!   with respect to varying inputs: a b
SUBROUTINE C06FPX_D(a, ad, b, bd, m, n, q, nq, trig)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!
!     Real to Hermitian Fast Fourier Transform Kernel Driver
!
!     Mixed-radix, self-sorting, decimation in time
!
!     .. Scalar Arguments ..
  INTEGER :: m, n, nq
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:m*n-1), b(0:m*n-1), trig(0:2*n-1)
  DOUBLE PRECISION :: ad(0:m*n-1), bd(0:m*n-1)
  INTEGER :: q(nq)
!     .. Local Scalars ..
  DOUBLE PRECISION :: factor
  INTEGER :: i, p, qi, r
  LOGICAL :: ina
!     .. External Subroutines ..
  EXTERNAL C06FPR, C06FPS, C06FPT, C06FPU, C06FPV, C06FPW
  EXTERNAL C06FPR_D, C06FPS_D, C06FPT_D, C06FPU_D, C06FPV_D, C06FPW_D
!     .. Intrinsic Functions ..
  INTRINSIC SQRT, DBLE
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: result1
!     .. Executable Statements ..
  ina = .true.
  p = n
  r = 1
  IF (n .EQ. 1) THEN
    RETURN
  ELSE
    DO i=nq,1,-1
      qi = q(i)
      p = p/qi
      IF (ina) THEN
        IF (qi .EQ. 2) THEN
          CALL C06FPW_D(a, ad, b, bd, m*p, r, trig((p-1)*qi*r), trig(n+(&
&                 p-1)*qi*r))
        ELSE IF (qi .EQ. 3) THEN
          CALL C06FPV_D(a, ad, b, bd, m*p, r, trig((p-1)*qi*r), trig(n+(&
&                 p-1)*qi*r))
        ELSE IF (qi .EQ. 4) THEN
          CALL C06FPU_D(a, ad, b, bd, m*p, r, trig((p-1)*qi*r), trig(n+(&
&                 p-1)*qi*r))
        ELSE IF (qi .EQ. 5) THEN
          CALL C06FPT_D(a, ad, b, bd, m*p, r, trig((p-1)*qi*r), trig(n+(&
&                 p-1)*qi*r))
        ELSE IF (qi .EQ. 6) THEN
          CALL C06FPS_D(a, ad, b, bd, m*p, r, trig((p-1)*qi*r), trig(n+(&
&                 p-1)*qi*r))
        ELSE
          CALL C06FPR_D(a, ad, b, bd, m*p, qi, r, trig((p-1)*qi*r), trig&
&                 (n+(p-1)*qi*r))
        END IF
      ELSE IF (qi .EQ. 2) THEN
        CALL C06FPW_D(b, bd, a, ad, m*p, r, trig((p-1)*qi*r), trig(n+(p-&
&               1)*qi*r))
      ELSE IF (qi .EQ. 3) THEN
        CALL C06FPV_D(b, bd, a, ad, m*p, r, trig((p-1)*qi*r), trig(n+(p-&
&               1)*qi*r))
      ELSE IF (qi .EQ. 4) THEN
        CALL C06FPU_D(b, bd, a, ad, m*p, r, trig((p-1)*qi*r), trig(n+(p-&
&               1)*qi*r))
      ELSE IF (qi .EQ. 5) THEN
        CALL C06FPT_D(b, bd, a, ad, m*p, r, trig((p-1)*qi*r), trig(n+(p-&
&               1)*qi*r))
      ELSE IF (qi .EQ. 6) THEN
        CALL C06FPS_D(b, bd, a, ad, m*p, r, trig((p-1)*qi*r), trig(n+(p-&
&               1)*qi*r))
      ELSE
        CALL C06FPR_D(b, bd, a, ad, m*p, qi, r, trig((p-1)*qi*r), trig(n&
&               +(p-1)*qi*r))
      END IF
      ina = .NOT.ina
      r = r*qi
    END DO
!
    arg1 = DBLE(n)
    result1 = SQRT(arg1)
    factor = 1.0d0/result1
    IF (ina) THEN
      DO i=0,m*n-1
        ad(i) = factor*ad(i)
        a(i) = a(i)*factor
      END DO
    ELSE
      DO i=0,m*n-1
        ad(i) = factor*bd(i)
        a(i) = b(i)*factor
      END DO
    END IF
!
    RETURN
  END IF
END SUBROUTINE C06FPX_D

!  Differentiation of c06fpr in forward (tangent) mode:
!   variations   of useful results: a b
!   with respect to varying inputs: a b
SUBROUTINE C06FPR_D(a, ad, b, bd, p, q, r, cosine, sine)
  IMPLICIT NONE
!     MARK 15 RE-ISSUE. NAG COPYRIGHT 1991.
!
!     Real to Hermitian fast Fourier transform kernel
!     Odd factors greater than 6
!
!     Self-sorting, decimation in time
!
!     .. Scalar Arguments ..
  INTEGER :: p, q, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:q-1, 0:r-1), b(0:p-1, 0:r-1, 0:q-1), &
& cosine(0:r-1, q-1), sine(0:r-1, q-1)
  DOUBLE PRECISION :: ad(0:p-1, 0:q-1, 0:r-1), bd(0:p-1, 0:r-1, 0:q-1)
!     .. Local Scalars ..
  DOUBLE PRECISION :: ai, ar, temp1, temp2, temp3, temp4
  DOUBLE PRECISION :: aid, ard, temp1d, temp2d, temp3d, temp4d
  INTEGER :: i, indx, j, k, kp, l, q2, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
!     .. Executable Statements ..
!
  q2 = (q-1)/2
  IF (p .GE. r/2) THEN
!
!        Code for K=0 --
!
    DO j=1,q2
      DO i=0,p-1
        temp1d = ad(i, j, 0)
        temp1 = a(i, j, 0)
        ad(i, j, 0) = temp1d + ad(i, q-j, 0)
        a(i, j, 0) = temp1 + a(i, q-j, 0)
        ad(i, q-j, 0) = temp1d - ad(i, q-j, 0)
        a(i, q-j, 0) = temp1 - a(i, q-j, 0)
      END DO
    END DO
    DO l=1,q2
      DO i=0,p-1
        bd(i, 0, l) = ad(i, 0, 0)
        b(i, 0, l) = a(i, 0, 0)
        bd(i, 0, q-l) = 0.D0
        b(i, 0, q-l) = 0.0d0
      END DO
      DO j=1,q2
        indx = MOD(j*l, q)
        DO i=0,p-1
          bd(i, 0, l) = bd(i, 0, l) + cosine(0, indx)*ad(i, j, 0)
          b(i, 0, l) = b(i, 0, l) + a(i, j, 0)*cosine(0, indx)
          bd(i, 0, q-l) = bd(i, 0, q-l) + sine(0, indx)*ad(i, q-j, 0)
          b(i, 0, q-l) = b(i, 0, q-l) + a(i, q-j, 0)*sine(0, indx)
        END DO
      END DO
    END DO
    DO i=0,p-1
      bd(i, 0, 0) = ad(i, 0, 0)
      b(i, 0, 0) = a(i, 0, 0)
    END DO
    DO j=1,q2
      DO i=0,p-1
        bd(i, 0, 0) = bd(i, 0, 0) + ad(i, j, 0)
        b(i, 0, 0) = b(i, 0, 0) + a(i, j, 0)
      END DO
    END DO
!
!        Code for general K --
!
    DO k=1,(r-1)/2
      kp = r - k
      DO j=1,q-1
        DO i=0,p-1
          ard = ad(i, j, k)
          ar = a(i, j, k)
          aid = ad(i, j, kp)
          ai = a(i, j, kp)
          ad(i, j, k) = cosine(k, j)*ard - sine(k, j)*aid
          a(i, j, k) = cosine(k, j)*ar - sine(k, j)*ai
          ad(i, j, kp) = cosine(k, j)*aid + sine(k, j)*ard
          a(i, j, kp) = cosine(k, j)*ai + sine(k, j)*ar
        END DO
      END DO
      DO j=1,q2
        DO i=0,p-1
          temp1d = ad(i, j, k)
          temp1 = a(i, j, k)
          temp2d = ad(i, j, kp)
          temp2 = a(i, j, kp)
          ad(i, j, k) = temp1d + ad(i, q-j, k)
          a(i, j, k) = temp1 + a(i, q-j, k)
          ad(i, j, kp) = temp2d + ad(i, q-j, kp)
          a(i, j, kp) = temp2 + a(i, q-j, kp)
          ad(i, q-j, k) = temp1d - ad(i, q-j, k)
          a(i, q-j, k) = temp1 - a(i, q-j, k)
          ad(i, q-j, kp) = temp2d - ad(i, q-j, kp)
          a(i, q-j, kp) = temp2 - a(i, q-j, kp)
        END DO
      END DO
      DO l=1,q2
        DO i=0,p-1
          bd(i, k, l) = ad(i, 0, k)
          b(i, k, l) = a(i, 0, k)
          bd(i, kp, q-l-1) = ad(i, 0, kp)
          b(i, kp, q-l-1) = a(i, 0, kp)
          bd(i, kp, l-1) = 0.D0
          b(i, kp, l-1) = 0.0d0
          bd(i, k, q-l) = 0.D0
          b(i, k, q-l) = 0.0d0
        END DO
        DO j=1,q2
          indx = MOD(j*l, q)
          DO i=0,p-1
            bd(i, k, l) = bd(i, k, l) + cosine(0, indx)*ad(i, j, k)
            b(i, k, l) = b(i, k, l) + a(i, j, k)*cosine(0, indx)
            bd(i, kp, q-l-1) = bd(i, kp, q-l-1) + cosine(0, indx)*ad(i, &
&             j, kp)
            b(i, kp, q-l-1) = b(i, kp, q-l-1) + a(i, j, kp)*cosine(0, &
&             indx)
            bd(i, kp, l-1) = bd(i, kp, l-1) - sine(0, indx)*ad(i, q-j, k&
&             )
            b(i, kp, l-1) = b(i, kp, l-1) - a(i, q-j, k)*sine(0, indx)
            bd(i, k, q-l) = bd(i, k, q-l) + sine(0, indx)*ad(i, q-j, kp)
            b(i, k, q-l) = b(i, k, q-l) + a(i, q-j, kp)*sine(0, indx)
          END DO
        END DO
      END DO
      DO i=0,p-1
        bd(i, k, 0) = ad(i, 0, k)
        b(i, k, 0) = a(i, 0, k)
        bd(i, kp, q-1) = ad(i, 0, kp)
        b(i, kp, q-1) = a(i, 0, kp)
      END DO
      DO j=1,q2
        DO i=0,p-1
          bd(i, k, 0) = bd(i, k, 0) + ad(i, j, k)
          b(i, k, 0) = b(i, k, 0) + a(i, j, k)
          bd(i, kp, q-1) = bd(i, kp, q-1) + ad(i, j, kp)
          b(i, kp, q-1) = b(i, kp, q-1) + a(i, j, kp)
        END DO
      END DO
      DO l=1,q2
        DO i=0,p-1
          temp1d = bd(i, k, l)
          temp1 = b(i, k, l)
          temp2d = bd(i, kp, q-l-1)
          temp2 = b(i, kp, q-l-1)
          temp3d = bd(i, kp, l-1)
          temp3 = b(i, kp, l-1)
          bd(i, k, l) = temp1d - bd(i, k, q-l)
          b(i, k, l) = temp1 - b(i, k, q-l)
          bd(i, kp, l-1) = temp1d + bd(i, k, q-l)
          b(i, kp, l-1) = temp1 + b(i, k, q-l)
          bd(i, kp, q-l-1) = temp2d - temp3d
          b(i, kp, q-l-1) = temp2 - temp3
          bd(i, k, q-l) = -temp2d - temp3d
          b(i, k, q-l) = -temp2 - temp3
        END DO
      END DO
    END DO
!
!        Code for K=R/2 if R is even --
!
    IF (MOD(r, 2) .EQ. 0) THEN
      r2 = r/2
      DO j=1,q2-1,2
        DO i=0,p-1
          temp1d = ad(i, j, r2)
          temp1 = a(i, j, r2)
          temp2d = ad(i, q-j, r2)
          temp2 = a(i, q-j, r2)
          ad(i, j, r2) = temp2d - temp1d
          a(i, j, r2) = -temp1 + temp2
          ad(i, q-j, r2) = -temp1d - temp2d
          a(i, q-j, r2) = -temp1 - temp2
          temp3d = ad(i, j+1, r2)
          temp3 = a(i, j+1, r2)
          temp4d = ad(i, q-j-1, r2)
          temp4 = a(i, q-j-1, r2)
          ad(i, j+1, r2) = temp3d - temp4d
          a(i, j+1, r2) = temp3 - temp4
          ad(i, q-j-1, r2) = temp3d + temp4d
          a(i, q-j-1, r2) = temp3 + temp4
        END DO
      END DO
      IF (MOD(q2, 2) .EQ. 1) THEN
        DO i=0,p-1
          temp1d = ad(i, q2, r2)
          temp1 = a(i, q2, r2)
          temp2d = ad(i, q2+1, r2)
          temp2 = a(i, q2+1, r2)
          ad(i, q2, r2) = temp2d - temp1d
          a(i, q2, r2) = -temp1 + temp2
          ad(i, q2+1, r2) = -temp1d - temp2d
          a(i, q2+1, r2) = -temp1 - temp2
        END DO
      END IF
      DO l=0,q2-1
        DO i=0,p-1
          bd(i, r2, l) = ad(i, 0, r2)
          b(i, r2, l) = a(i, 0, r2)
          bd(i, r2, q-l-1) = 0.D0
          b(i, r2, q-l-1) = 0.0d0
        END DO
        DO j=1,q2
          indx = MOD(j*(l+q2+1), q)
          DO i=0,p-1
            bd(i, r2, l) = bd(i, r2, l) + cosine(0, indx)*ad(i, j, r2)
            b(i, r2, l) = b(i, r2, l) + a(i, j, r2)*cosine(0, indx)
            bd(i, r2, q-l-1) = bd(i, r2, q-l-1) + sine(0, indx)*ad(i, q-&
&             j, r2)
            b(i, r2, q-l-1) = b(i, r2, q-l-1) + a(i, q-j, r2)*sine(0, &
&             indx)
          END DO
        END DO
      END DO
      DO i=0,p-1
        bd(i, r2, q2) = ad(i, 0, r2)
        b(i, r2, q2) = a(i, 0, r2)
      END DO
      DO j=1,q2
        DO i=0,p-1
          bd(i, r2, q2) = bd(i, r2, q2) + ad(i, j, r2)
          b(i, r2, q2) = b(i, r2, q2) + a(i, j, r2)
        END DO
      END DO
    END IF
  ELSE
!
!
    DO i=0,p-1
!
!           Code for K=0 --
!
      DO j=1,q2
        temp1d = ad(i, j, 0)
        temp1 = a(i, j, 0)
        ad(i, j, 0) = temp1d + ad(i, q-j, 0)
        a(i, j, 0) = temp1 + a(i, q-j, 0)
        ad(i, q-j, 0) = temp1d - ad(i, q-j, 0)
        a(i, q-j, 0) = temp1 - a(i, q-j, 0)
      END DO
      DO l=1,q2
        bd(i, 0, l) = ad(i, 0, 0)
        b(i, 0, l) = a(i, 0, 0)
        bd(i, 0, q-l) = 0.D0
        b(i, 0, q-l) = 0.0d0
        DO j=1,q2
          indx = MOD(j*l, q)
          bd(i, 0, l) = bd(i, 0, l) + cosine(0, indx)*ad(i, j, 0)
          b(i, 0, l) = b(i, 0, l) + a(i, j, 0)*cosine(0, indx)
          bd(i, 0, q-l) = bd(i, 0, q-l) + sine(0, indx)*ad(i, q-j, 0)
          b(i, 0, q-l) = b(i, 0, q-l) + a(i, q-j, 0)*sine(0, indx)
        END DO
      END DO
      bd(i, 0, 0) = ad(i, 0, 0)
      b(i, 0, 0) = a(i, 0, 0)
      DO j=1,q2
        bd(i, 0, 0) = bd(i, 0, 0) + ad(i, j, 0)
        b(i, 0, 0) = b(i, 0, 0) + a(i, j, 0)
      END DO
!
!           Code for general K --
!
      DO j=1,q-1
        DO k=1,(r-1)/2
          ard = ad(i, j, k)
          ar = a(i, j, k)
          aid = ad(i, j, r-k)
          ai = a(i, j, r-k)
          ad(i, j, k) = cosine(k, j)*ard - sine(k, j)*aid
          a(i, j, k) = cosine(k, j)*ar - sine(k, j)*ai
          ad(i, j, r-k) = cosine(k, j)*aid + sine(k, j)*ard
          a(i, j, r-k) = cosine(k, j)*ai + sine(k, j)*ar
        END DO
      END DO
      DO j=1,q2
        DO k=1,(r-1)/2
          temp1d = ad(i, j, k)
          temp1 = a(i, j, k)
          temp2d = ad(i, j, r-k)
          temp2 = a(i, j, r-k)
          ad(i, j, k) = temp1d + ad(i, q-j, k)
          a(i, j, k) = temp1 + a(i, q-j, k)
          ad(i, j, r-k) = temp2d + ad(i, q-j, r-k)
          a(i, j, r-k) = temp2 + a(i, q-j, r-k)
          ad(i, q-j, k) = temp1d - ad(i, q-j, k)
          a(i, q-j, k) = temp1 - a(i, q-j, k)
          ad(i, q-j, r-k) = temp2d - ad(i, q-j, r-k)
          a(i, q-j, r-k) = temp2 - a(i, q-j, r-k)
        END DO
      END DO
      DO l=1,q2
        DO k=1,(r-1)/2
          bd(i, k, l) = ad(i, 0, k)
          b(i, k, l) = a(i, 0, k)
          bd(i, r-k, q-l-1) = ad(i, 0, r-k)
          b(i, r-k, q-l-1) = a(i, 0, r-k)
          bd(i, r-k, l-1) = 0.D0
          b(i, r-k, l-1) = 0.0d0
          bd(i, k, q-l) = 0.D0
          b(i, k, q-l) = 0.0d0
        END DO
        DO j=1,q2
          indx = MOD(j*l, q)
          DO k=1,(r-1)/2
            bd(i, k, l) = bd(i, k, l) + cosine(0, indx)*ad(i, j, k)
            b(i, k, l) = b(i, k, l) + a(i, j, k)*cosine(0, indx)
            bd(i, r-k, q-l-1) = bd(i, r-k, q-l-1) + cosine(0, indx)*ad(i&
&             , j, r-k)
            b(i, r-k, q-l-1) = b(i, r-k, q-l-1) + a(i, j, r-k)*cosine(0&
&             , indx)
            bd(i, r-k, l-1) = bd(i, r-k, l-1) - sine(0, indx)*ad(i, q-j&
&             , k)
            b(i, r-k, l-1) = b(i, r-k, l-1) - a(i, q-j, k)*sine(0, indx)
            bd(i, k, q-l) = bd(i, k, q-l) + sine(0, indx)*ad(i, q-j, r-k&
&             )
            b(i, k, q-l) = b(i, k, q-l) + a(i, q-j, r-k)*sine(0, indx)
          END DO
        END DO
      END DO
      DO k=1,(r-1)/2
        bd(i, k, 0) = ad(i, 0, k)
        b(i, k, 0) = a(i, 0, k)
        bd(i, r-k, q-1) = ad(i, 0, r-k)
        b(i, r-k, q-1) = a(i, 0, r-k)
      END DO
      DO j=1,q2
        DO k=1,(r-1)/2
          bd(i, k, 0) = bd(i, k, 0) + ad(i, j, k)
          b(i, k, 0) = b(i, k, 0) + a(i, j, k)
          bd(i, r-k, q-1) = bd(i, r-k, q-1) + ad(i, j, r-k)
          b(i, r-k, q-1) = b(i, r-k, q-1) + a(i, j, r-k)
        END DO
      END DO
      DO l=1,q2
        DO k=1,(r-1)/2
          temp1d = bd(i, k, l)
          temp1 = b(i, k, l)
          temp2d = bd(i, r-k, q-l-1)
          temp2 = b(i, r-k, q-l-1)
          temp3d = bd(i, r-k, l-1)
          temp3 = b(i, r-k, l-1)
          bd(i, k, l) = temp1d - bd(i, k, q-l)
          b(i, k, l) = temp1 - b(i, k, q-l)
          bd(i, r-k, l-1) = temp1d + bd(i, k, q-l)
          b(i, r-k, l-1) = temp1 + b(i, k, q-l)
          bd(i, r-k, q-l-1) = temp2d - temp3d
          b(i, r-k, q-l-1) = temp2 - temp3
          bd(i, k, q-l) = -temp2d - temp3d
          b(i, k, q-l) = -temp2 - temp3
        END DO
      END DO
!
!           Code for K=R/2 if R is even --
!
      IF (MOD(r, 2) .EQ. 0) THEN
        r2 = r/2
        DO j=1,q2-1,2
          temp1d = ad(i, j, r2)
          temp1 = a(i, j, r2)
          temp2d = ad(i, q-j, r2)
          temp2 = a(i, q-j, r2)
          ad(i, j, r2) = temp2d - temp1d
          a(i, j, r2) = -temp1 + temp2
          ad(i, q-j, r2) = -temp1d - temp2d
          a(i, q-j, r2) = -temp1 - temp2
          temp3d = ad(i, j+1, r2)
          temp3 = a(i, j+1, r2)
          temp4d = ad(i, q-j-1, r2)
          temp4 = a(i, q-j-1, r2)
          ad(i, j+1, r2) = temp3d - temp4d
          a(i, j+1, r2) = temp3 - temp4
          ad(i, q-j-1, r2) = temp3d + temp4d
          a(i, q-j-1, r2) = temp3 + temp4
        END DO
        IF (MOD(q2, 2) .EQ. 1) THEN
          temp1d = ad(i, q2, r2)
          temp1 = a(i, q2, r2)
          temp2d = ad(i, q2+1, r2)
          temp2 = a(i, q2+1, r2)
          ad(i, q2, r2) = temp2d - temp1d
          a(i, q2, r2) = -temp1 + temp2
          ad(i, q2+1, r2) = -temp1d - temp2d
          a(i, q2+1, r2) = -temp1 - temp2
        END IF
        DO l=0,q2-1
          bd(i, r2, l) = ad(i, 0, r2)
          b(i, r2, l) = a(i, 0, r2)
          bd(i, r2, q-l-1) = 0.D0
          b(i, r2, q-l-1) = 0.0d0
          DO j=1,q2
            indx = MOD(j*(l+q2+1), q)
            bd(i, r2, l) = bd(i, r2, l) + cosine(0, indx)*ad(i, j, r2)
            b(i, r2, l) = b(i, r2, l) + a(i, j, r2)*cosine(0, indx)
            bd(i, r2, q-l-1) = bd(i, r2, q-l-1) + sine(0, indx)*ad(i, q-&
&             j, r2)
            b(i, r2, q-l-1) = b(i, r2, q-l-1) + a(i, q-j, r2)*sine(0, &
&             indx)
          END DO
        END DO
        bd(i, r2, q2) = ad(i, 0, r2)
        b(i, r2, q2) = a(i, 0, r2)
        DO j=1,q2
          bd(i, r2, q2) = bd(i, r2, q2) + ad(i, j, r2)
          b(i, r2, q2) = b(i, r2, q2) + a(i, j, r2)
        END DO
      END IF
    END DO
  END IF
  RETURN
END SUBROUTINE C06FPR_D

!  Differentiation of c06fps in forward (tangent) mode:
!   variations   of useful results: b
!   with respect to varying inputs: a b
SUBROUTINE C06FPS_D(a, ad, b, bd, p, r, cosine, sine)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     MARK 14 REVISED. IER-694 (DEC 1989).
!
!     Radix six real to Hermitian fast Fourier transform kernel
!
!     Self-sorting, decimation in time
!
!     .. Parameters ..
  DOUBLE PRECISION :: sin60
  PARAMETER (sin60=0.866025403784438646763723170752936d0)
!     .. Scalar Arguments ..
  INTEGER :: p, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:5, 0:r-1), b(0:p-1, 0:r-1, 0:5), cosine&
& (0:r-1, 5), sine(0:r-1, 5)
  DOUBLE PRECISION :: ad(0:p-1, 0:5, 0:r-1), bd(0:p-1, 0:r-1, 0:5)
!     .. Local Scalars ..
  DOUBLE PRECISION :: c2k, c3k, c4k, c5k, ck, s2k, s3k, s4k, s5k, sk, t1&
& , t1i, t1r, t2, t2i, t2r, t3, t3i, t3r, t4, t5, t6, u0, u0i, u0r, u1i&
& , u1r, u2i, u2r, ui, ur, v0, v0i, v0r, v1i, v1r, v2i, v2r, vi, vr, x1p&
& , x2p, x3p, x4p, x5p, y1p, y2p, y3p, y4p, y5p
  DOUBLE PRECISION :: t1d, t1id, t1rd, t2d, t2id, t2rd, t3d, t3id, t3rd&
& , t4d, t5d, t6d, u0d, u0id, u0rd, u1id, u1rd, u2id, u2rd, uid, urd, &
& v0d, v0id, v0rd, v1id, v1rd, v2id, v2rd, vid, vrd, x1pd, x2pd, x3pd, &
& x4pd, x5pd, y1pd, y2pd, y3pd, y4pd, y5pd
  INTEGER :: i, k, kp, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
!     .. Executable Statements ..
  DO i=0,p-1
!
!        Code for K=0 --
!
    t1d = ad(i, 2, 0) + ad(i, 4, 0)
    t1 = a(i, 2, 0) + a(i, 4, 0)
    urd = ad(i, 0, 0) - 0.5d0*t1d
    ur = a(i, 0, 0) - 0.5d0*t1
    uid = -(sin60*(ad(i, 2, 0)-ad(i, 4, 0)))
    ui = -(sin60*(a(i, 2, 0)-a(i, 4, 0)))
    u0d = ad(i, 0, 0) + t1d
    u0 = a(i, 0, 0) + t1
    t1d = ad(i, 5, 0) + ad(i, 1, 0)
    t1 = a(i, 5, 0) + a(i, 1, 0)
    vrd = ad(i, 3, 0) - 0.5d0*t1d
    vr = a(i, 3, 0) - 0.5d0*t1
    vid = -(sin60*(ad(i, 5, 0)-ad(i, 1, 0)))
    vi = -(sin60*(a(i, 5, 0)-a(i, 1, 0)))
    v0d = ad(i, 3, 0) + t1d
    v0 = a(i, 3, 0) + t1
    bd(i, 0, 0) = u0d + v0d
    b(i, 0, 0) = u0 + v0
    bd(i, 0, 1) = urd - vrd
    b(i, 0, 1) = ur - vr
    bd(i, 0, 2) = urd + vrd
    b(i, 0, 2) = ur + vr
    bd(i, 0, 3) = u0d - v0d
    b(i, 0, 3) = u0 - v0
    bd(i, 0, 4) = -uid - vid
    b(i, 0, 4) = -ui - vi
    bd(i, 0, 5) = uid - vid
    b(i, 0, 5) = ui - vi
  END DO
!
!     Code for general K --
!
  IF (p .LE. (r-1)/2) THEN
    DO i=0,p-1
!DIR$ IVDEP
      DO k=1,(r-1)/2
        x1pd = cosine(k, 1)*ad(i, 1, k) - sine(k, 1)*ad(i, 1, r-k)
        x1p = cosine(k, 1)*a(i, 1, k) - sine(k, 1)*a(i, 1, r-k)
        y1pd = cosine(k, 1)*ad(i, 1, r-k) + sine(k, 1)*ad(i, 1, k)
        y1p = cosine(k, 1)*a(i, 1, r-k) + sine(k, 1)*a(i, 1, k)
        x2pd = cosine(k, 2)*ad(i, 2, k) - sine(k, 2)*ad(i, 2, r-k)
        x2p = cosine(k, 2)*a(i, 2, k) - sine(k, 2)*a(i, 2, r-k)
        y2pd = cosine(k, 2)*ad(i, 2, r-k) + sine(k, 2)*ad(i, 2, k)
        y2p = cosine(k, 2)*a(i, 2, r-k) + sine(k, 2)*a(i, 2, k)
        x3pd = cosine(k, 3)*ad(i, 3, k) - sine(k, 3)*ad(i, 3, r-k)
        x3p = cosine(k, 3)*a(i, 3, k) - sine(k, 3)*a(i, 3, r-k)
        y3pd = cosine(k, 3)*ad(i, 3, r-k) + sine(k, 3)*ad(i, 3, k)
        y3p = cosine(k, 3)*a(i, 3, r-k) + sine(k, 3)*a(i, 3, k)
        x4pd = cosine(k, 4)*ad(i, 4, k) - sine(k, 4)*ad(i, 4, r-k)
        x4p = cosine(k, 4)*a(i, 4, k) - sine(k, 4)*a(i, 4, r-k)
        y4pd = cosine(k, 4)*ad(i, 4, r-k) + sine(k, 4)*ad(i, 4, k)
        y4p = cosine(k, 4)*a(i, 4, r-k) + sine(k, 4)*a(i, 4, k)
        x5pd = cosine(k, 5)*ad(i, 5, k) - sine(k, 5)*ad(i, 5, r-k)
        x5p = cosine(k, 5)*a(i, 5, k) - sine(k, 5)*a(i, 5, r-k)
        y5pd = cosine(k, 5)*ad(i, 5, r-k) + sine(k, 5)*ad(i, 5, k)
        y5p = cosine(k, 5)*a(i, 5, r-k) + sine(k, 5)*a(i, 5, k)
        t1rd = x2pd + x4pd
        t1r = x2p + x4p
        t1id = y2pd + y4pd
        t1i = y2p + y4p
        t2rd = ad(i, 0, k) - 0.5d0*t1rd
        t2r = a(i, 0, k) - 0.5d0*t1r
        t2id = ad(i, 0, r-k) - 0.5d0*t1id
        t2i = a(i, 0, r-k) - 0.5d0*t1i
        t3rd = sin60*(x2pd-x4pd)
        t3r = sin60*(x2p-x4p)
        t3id = sin60*(y2pd-y4pd)
        t3i = sin60*(y2p-y4p)
        u0rd = ad(i, 0, k) + t1rd
        u0r = a(i, 0, k) + t1r
        u0id = ad(i, 0, r-k) + t1id
        u0i = a(i, 0, r-k) + t1i
        u1rd = t2rd + t3id
        u1r = t2r + t3i
        u1id = t2id - t3rd
        u1i = t2i - t3r
        u2rd = t2rd - t3id
        u2r = t2r - t3i
        u2id = t2id + t3rd
        u2i = t2i + t3r
        t1rd = x5pd + x1pd
        t1r = x5p + x1p
        t1id = y5pd + y1pd
        t1i = y5p + y1p
        t2rd = x3pd - 0.5d0*t1rd
        t2r = x3p - 0.5d0*t1r
        t2id = y3pd - 0.5d0*t1id
        t2i = y3p - 0.5d0*t1i
        t3rd = sin60*(x5pd-x1pd)
        t3r = sin60*(x5p-x1p)
        t3id = sin60*(y5pd-y1pd)
        t3i = sin60*(y5p-y1p)
        v0rd = x3pd + t1rd
        v0r = x3p + t1r
        v0id = y3pd + t1id
        v0i = y3p + t1i
        v1rd = t2rd + t3id
        v1r = t2r + t3i
        v1id = t2id - t3rd
        v1i = t2i - t3r
        v2rd = t2rd - t3id
        v2r = t2r - t3i
        v2id = t2id + t3rd
        v2i = t2i + t3r
        bd(i, k, 0) = u0rd + v0rd
        b(i, k, 0) = u0r + v0r
        bd(i, r-k, 0) = u2rd - v2rd
        b(i, r-k, 0) = u2r - v2r
        bd(i, k, 1) = u1rd - v1rd
        b(i, k, 1) = u1r - v1r
        bd(i, r-k, 1) = u1rd + v1rd
        b(i, r-k, 1) = u1r + v1r
        bd(i, k, 2) = u2rd + v2rd
        b(i, k, 2) = u2r + v2r
        bd(i, r-k, 2) = u0rd - v0rd
        b(i, r-k, 2) = u0r - v0r
        bd(i, k, 3) = v0id - u0id
        b(i, k, 3) = -u0i + v0i
        bd(i, r-k, 3) = u2id + v2id
        b(i, r-k, 3) = u2i + v2i
        bd(i, k, 4) = -u1id - v1id
        b(i, k, 4) = -u1i - v1i
        bd(i, r-k, 4) = u1id - v1id
        b(i, r-k, 4) = u1i - v1i
        bd(i, k, 5) = v2id - u2id
        b(i, k, 5) = -u2i + v2i
        bd(i, r-k, 5) = u0id + v0id
        b(i, r-k, 5) = u0i + v0i
      END DO
    END DO
  ELSE
    DO k=1,(r-1)/2
      kp = r - k
      ck = cosine(k, 1)
      sk = sine(k, 1)
      c2k = cosine(k, 2)
      s2k = sine(k, 2)
      c3k = cosine(k, 3)
      s3k = sine(k, 3)
      c4k = cosine(k, 4)
      s4k = sine(k, 4)
      c5k = cosine(k, 5)
      s5k = sine(k, 5)
      DO i=0,p-1
        x1pd = ck*ad(i, 1, k) - sk*ad(i, 1, kp)
        x1p = ck*a(i, 1, k) - sk*a(i, 1, kp)
        y1pd = ck*ad(i, 1, kp) + sk*ad(i, 1, k)
        y1p = ck*a(i, 1, kp) + sk*a(i, 1, k)
        x2pd = c2k*ad(i, 2, k) - s2k*ad(i, 2, kp)
        x2p = c2k*a(i, 2, k) - s2k*a(i, 2, kp)
        y2pd = c2k*ad(i, 2, kp) + s2k*ad(i, 2, k)
        y2p = c2k*a(i, 2, kp) + s2k*a(i, 2, k)
        x3pd = c3k*ad(i, 3, k) - s3k*ad(i, 3, kp)
        x3p = c3k*a(i, 3, k) - s3k*a(i, 3, kp)
        y3pd = c3k*ad(i, 3, kp) + s3k*ad(i, 3, k)
        y3p = c3k*a(i, 3, kp) + s3k*a(i, 3, k)
        x4pd = c4k*ad(i, 4, k) - s4k*ad(i, 4, kp)
        x4p = c4k*a(i, 4, k) - s4k*a(i, 4, kp)
        y4pd = c4k*ad(i, 4, kp) + s4k*ad(i, 4, k)
        y4p = c4k*a(i, 4, kp) + s4k*a(i, 4, k)
        x5pd = c5k*ad(i, 5, k) - s5k*ad(i, 5, kp)
        x5p = c5k*a(i, 5, k) - s5k*a(i, 5, kp)
        y5pd = c5k*ad(i, 5, kp) + s5k*ad(i, 5, k)
        y5p = c5k*a(i, 5, kp) + s5k*a(i, 5, k)
        t1rd = x2pd + x4pd
        t1r = x2p + x4p
        t1id = y2pd + y4pd
        t1i = y2p + y4p
        t2rd = ad(i, 0, k) - 0.5d0*t1rd
        t2r = a(i, 0, k) - 0.5d0*t1r
        t2id = ad(i, 0, kp) - 0.5d0*t1id
        t2i = a(i, 0, kp) - 0.5d0*t1i
        t3rd = sin60*(x2pd-x4pd)
        t3r = sin60*(x2p-x4p)
        t3id = sin60*(y2pd-y4pd)
        t3i = sin60*(y2p-y4p)
        u0rd = ad(i, 0, k) + t1rd
        u0r = a(i, 0, k) + t1r
        u0id = ad(i, 0, kp) + t1id
        u0i = a(i, 0, kp) + t1i
        u1rd = t2rd + t3id
        u1r = t2r + t3i
        u1id = t2id - t3rd
        u1i = t2i - t3r
        u2rd = t2rd - t3id
        u2r = t2r - t3i
        u2id = t2id + t3rd
        u2i = t2i + t3r
        t1rd = x5pd + x1pd
        t1r = x5p + x1p
        t1id = y5pd + y1pd
        t1i = y5p + y1p
        t2rd = x3pd - 0.5d0*t1rd
        t2r = x3p - 0.5d0*t1r
        t2id = y3pd - 0.5d0*t1id
        t2i = y3p - 0.5d0*t1i
        t3rd = sin60*(x5pd-x1pd)
        t3r = sin60*(x5p-x1p)
        t3id = sin60*(y5pd-y1pd)
        t3i = sin60*(y5p-y1p)
        v0rd = x3pd + t1rd
        v0r = x3p + t1r
        v0id = y3pd + t1id
        v0i = y3p + t1i
        v1rd = t2rd + t3id
        v1r = t2r + t3i
        v1id = t2id - t3rd
        v1i = t2i - t3r
        v2rd = t2rd - t3id
        v2r = t2r - t3i
        v2id = t2id + t3rd
        v2i = t2i + t3r
        bd(i, k, 0) = u0rd + v0rd
        b(i, k, 0) = u0r + v0r
        bd(i, kp, 0) = u2rd - v2rd
        b(i, kp, 0) = u2r - v2r
        bd(i, k, 1) = u1rd - v1rd
        b(i, k, 1) = u1r - v1r
        bd(i, kp, 1) = u1rd + v1rd
        b(i, kp, 1) = u1r + v1r
        bd(i, k, 2) = u2rd + v2rd
        b(i, k, 2) = u2r + v2r
        bd(i, kp, 2) = u0rd - v0rd
        b(i, kp, 2) = u0r - v0r
        bd(i, k, 3) = v0id - u0id
        b(i, k, 3) = -u0i + v0i
        bd(i, kp, 3) = u2id + v2id
        b(i, kp, 3) = u2i + v2i
        bd(i, k, 4) = -u1id - v1id
        b(i, k, 4) = -u1i - v1i
        bd(i, kp, 4) = u1id - v1id
        b(i, kp, 4) = u1i - v1i
        bd(i, k, 5) = v2id - u2id
        b(i, k, 5) = -u2i + v2i
        bd(i, kp, 5) = u0id + v0id
        b(i, kp, 5) = u0i + v0i
      END DO
    END DO
  END IF
!
!     Code for K=R/2 when R is even --
!
  IF (MOD(r, 2) .EQ. 0) THEN
    r2 = r/2
    DO i=0,p-1
      t1d = ad(i, 2, r2) - ad(i, 4, r2)
      t1 = a(i, 2, r2) - a(i, 4, r2)
      t2d = ad(i, 0, r2) + 0.5d0*t1d
      t2 = a(i, 0, r2) + 0.5d0*t1
      t3d = sin60*(ad(i, 2, r2)+ad(i, 4, r2))
      t3 = sin60*(a(i, 2, r2)+a(i, 4, r2))
      t4d = ad(i, 1, r2) + ad(i, 5, r2)
      t4 = a(i, 1, r2) + a(i, 5, r2)
      t5d = -ad(i, 3, r2) - 0.5d0*t4d
      t5 = -a(i, 3, r2) - 0.5d0*t4
      t6d = sin60*(ad(i, 1, r2)-ad(i, 5, r2))
      t6 = sin60*(a(i, 1, r2)-a(i, 5, r2))
      bd(i, r2, 0) = t2d + t6d
      b(i, r2, 0) = t2 + t6
      bd(i, r2, 1) = ad(i, 0, r2) - t1d
      b(i, r2, 1) = a(i, 0, r2) - t1
      bd(i, r2, 2) = t2d - t6d
      b(i, r2, 2) = t2 - t6
      bd(i, r2, 3) = t5d + t3d
      b(i, r2, 3) = t5 + t3
      bd(i, r2, 4) = ad(i, 3, r2) - t4d
      b(i, r2, 4) = a(i, 3, r2) - t4
      bd(i, r2, 5) = t5d - t3d
      b(i, r2, 5) = t5 - t3
    END DO
  END IF
!
  RETURN
END SUBROUTINE C06FPS_D

!  Differentiation of c06fpt in forward (tangent) mode:
!   variations   of useful results: b
!   with respect to varying inputs: a b
SUBROUTINE C06FPT_D(a, ad, b, bd, p, r, cosine, sine)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     MARK 14 REVISED. IER-695 (DEC 1989).
!
!     Radix five real to Hermitian fast Fourier transform kernel
!
!     Self-sorting, decimation in time
!
!     .. Parameters ..
  DOUBLE PRECISION :: r54, sin72, s36s72
  PARAMETER (r54=0.559016994374947424102293417182819d0, sin72=&
&   0.951056516295153572116439333379382d0, s36s72=&
&   0.618033988749894848204586834365638d0)
!     .. Scalar Arguments ..
  INTEGER :: p, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:4, 0:r-1), b(0:p-1, 0:r-1, 0:4), cosine&
& (0:r-1, 4), sine(0:r-1, 4)
  DOUBLE PRECISION :: ad(0:p-1, 0:4, 0:r-1), bd(0:p-1, 0:r-1, 0:4)
!     .. Local Scalars ..
  DOUBLE PRECISION :: c2k, c3k, c4k, ck, s2k, s3k, s4k, sk, t1, t10i, &
& t10r, t11i, t11r, t1i, t1r, t2, t2i, t2r, t3, t3i, t3r, t4, t4i, t4r, &
& t5, t5i, t5r, t6, t6i, t6r, t7, t7i, t7r, t8i, t8r, t9i, t9r, x1p, x2p&
& , x3p, x4p, y1p, y2p, y3p, y4p
  DOUBLE PRECISION :: t1d, t10id, t10rd, t11id, t11rd, t1id, t1rd, t2d, &
& t2id, t2rd, t3d, t3id, t3rd, t4d, t4id, t4rd, t5d, t5id, t5rd, t6d, &
& t6id, t6rd, t7d, t7id, t7rd, t8id, t8rd, t9id, t9rd, x1pd, x2pd, x3pd&
& , x4pd, y1pd, y2pd, y3pd, y4pd
  INTEGER :: i, k, kp, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
!     .. Executable Statements ..
  DO i=0,p-1
!
!        Code for K=0 --
!
    t1d = ad(i, 1, 0) + ad(i, 4, 0)
    t1 = a(i, 1, 0) + a(i, 4, 0)
    t2d = ad(i, 2, 0) + ad(i, 3, 0)
    t2 = a(i, 2, 0) + a(i, 3, 0)
    t3d = sin72*(ad(i, 1, 0)-ad(i, 4, 0))
    t3 = sin72*(a(i, 1, 0)-a(i, 4, 0))
    t4d = sin72*(ad(i, 2, 0)-ad(i, 3, 0))
    t4 = sin72*(a(i, 2, 0)-a(i, 3, 0))
    t5d = t1d + t2d
    t5 = t1 + t2
    t6d = r54*(t1d-t2d)
    t6 = r54*(t1-t2)
    t7d = ad(i, 0, 0) - 0.25d0*t5d
    t7 = a(i, 0, 0) - 0.25d0*t5
    bd(i, 0, 0) = ad(i, 0, 0) + t5d
    b(i, 0, 0) = a(i, 0, 0) + t5
    bd(i, 0, 1) = t7d + t6d
    b(i, 0, 1) = t7 + t6
    bd(i, 0, 2) = t7d - t6d
    b(i, 0, 2) = t7 - t6
    bd(i, 0, 3) = t4d - s36s72*t3d
    b(i, 0, 3) = -(s36s72*t3) + t4
    bd(i, 0, 4) = -t3d - s36s72*t4d
    b(i, 0, 4) = -t3 - s36s72*t4
  END DO
!
!     Code for general K --
!
  IF (p .LE. (r-1)/2) THEN
    DO i=0,p-1
!DIR$ IVDEP
      DO k=1,(r-1)/2
        x1pd = cosine(k, 1)*ad(i, 1, k) - sine(k, 1)*ad(i, 1, r-k)
        x1p = cosine(k, 1)*a(i, 1, k) - sine(k, 1)*a(i, 1, r-k)
        y1pd = cosine(k, 1)*ad(i, 1, r-k) + sine(k, 1)*ad(i, 1, k)
        y1p = cosine(k, 1)*a(i, 1, r-k) + sine(k, 1)*a(i, 1, k)
        x2pd = cosine(k, 2)*ad(i, 2, k) - sine(k, 2)*ad(i, 2, r-k)
        x2p = cosine(k, 2)*a(i, 2, k) - sine(k, 2)*a(i, 2, r-k)
        y2pd = cosine(k, 2)*ad(i, 2, r-k) + sine(k, 2)*ad(i, 2, k)
        y2p = cosine(k, 2)*a(i, 2, r-k) + sine(k, 2)*a(i, 2, k)
        x3pd = cosine(k, 3)*ad(i, 3, k) - sine(k, 3)*ad(i, 3, r-k)
        x3p = cosine(k, 3)*a(i, 3, k) - sine(k, 3)*a(i, 3, r-k)
        y3pd = cosine(k, 3)*ad(i, 3, r-k) + sine(k, 3)*ad(i, 3, k)
        y3p = cosine(k, 3)*a(i, 3, r-k) + sine(k, 3)*a(i, 3, k)
        x4pd = cosine(k, 4)*ad(i, 4, k) - sine(k, 4)*ad(i, 4, r-k)
        x4p = cosine(k, 4)*a(i, 4, k) - sine(k, 4)*a(i, 4, r-k)
        y4pd = cosine(k, 4)*ad(i, 4, r-k) + sine(k, 4)*ad(i, 4, k)
        y4p = cosine(k, 4)*a(i, 4, r-k) + sine(k, 4)*a(i, 4, k)
        t1rd = x1pd + x4pd
        t1r = x1p + x4p
        t1id = y1pd + y4pd
        t1i = y1p + y4p
        t2rd = x2pd + x3pd
        t2r = x2p + x3p
        t2id = y2pd + y3pd
        t2i = y2p + y3p
        t3rd = sin72*(x1pd-x4pd)
        t3r = sin72*(x1p-x4p)
        t3id = sin72*(y1pd-y4pd)
        t3i = sin72*(y1p-y4p)
        t4rd = sin72*(x2pd-x3pd)
        t4r = sin72*(x2p-x3p)
        t4id = sin72*(y2pd-y3pd)
        t4i = sin72*(y2p-y3p)
        t5rd = t1rd + t2rd
        t5r = t1r + t2r
        t5id = t1id + t2id
        t5i = t1i + t2i
        t6rd = r54*(t1rd-t2rd)
        t6r = r54*(t1r-t2r)
        t6id = r54*(t1id-t2id)
        t6i = r54*(t1i-t2i)
        t7rd = ad(i, 0, k) - 0.25d0*t5rd
        t7r = a(i, 0, k) - 0.25d0*t5r
        t7id = ad(i, 0, r-k) - 0.25d0*t5id
        t7i = a(i, 0, r-k) - 0.25d0*t5i
        t8rd = t7rd + t6rd
        t8r = t7r + t6r
        t8id = t7id + t6id
        t8i = t7i + t6i
        t9rd = t7rd - t6rd
        t9r = t7r - t6r
        t9id = t7id - t6id
        t9i = t7i - t6i
        t10rd = t3rd + s36s72*t4rd
        t10r = t3r + s36s72*t4r
        t10id = t3id + s36s72*t4id
        t10i = t3i + s36s72*t4i
        t11rd = s36s72*t3rd - t4rd
        t11r = s36s72*t3r - t4r
        t11id = s36s72*t3id - t4id
        t11i = s36s72*t3i - t4i
        bd(i, k, 0) = ad(i, 0, k) + t5rd
        b(i, k, 0) = a(i, 0, k) + t5r
        bd(i, r-k, 0) = t8rd - t10id
        b(i, r-k, 0) = t8r - t10i
        bd(i, k, 1) = t8rd + t10id
        b(i, k, 1) = t8r + t10i
        bd(i, r-k, 1) = t9rd - t11id
        b(i, r-k, 1) = t9r - t11i
        bd(i, k, 2) = t9rd + t11id
        b(i, k, 2) = t9r + t11i
        bd(i, r-k, 2) = t9id - t11rd
        b(i, r-k, 2) = t9i - t11r
        bd(i, k, 3) = -t9id - t11rd
        b(i, k, 3) = -t9i - t11r
        bd(i, r-k, 3) = t8id - t10rd
        b(i, r-k, 3) = t8i - t10r
        bd(i, k, 4) = -t8id - t10rd
        b(i, k, 4) = -t8i - t10r
        bd(i, r-k, 4) = ad(i, 0, r-k) + t5id
        b(i, r-k, 4) = a(i, 0, r-k) + t5i
      END DO
    END DO
  ELSE
    DO k=1,(r-1)/2
      kp = r - k
      ck = cosine(k, 1)
      sk = sine(k, 1)
      c2k = cosine(k, 2)
      s2k = sine(k, 2)
      c3k = cosine(k, 3)
      s3k = sine(k, 3)
      c4k = cosine(k, 4)
      s4k = sine(k, 4)
      DO i=0,p-1
        x1pd = ck*ad(i, 1, k) - sk*ad(i, 1, kp)
        x1p = ck*a(i, 1, k) - sk*a(i, 1, kp)
        y1pd = ck*ad(i, 1, kp) + sk*ad(i, 1, k)
        y1p = ck*a(i, 1, kp) + sk*a(i, 1, k)
        x2pd = c2k*ad(i, 2, k) - s2k*ad(i, 2, kp)
        x2p = c2k*a(i, 2, k) - s2k*a(i, 2, kp)
        y2pd = c2k*ad(i, 2, kp) + s2k*ad(i, 2, k)
        y2p = c2k*a(i, 2, kp) + s2k*a(i, 2, k)
        x3pd = c3k*ad(i, 3, k) - s3k*ad(i, 3, kp)
        x3p = c3k*a(i, 3, k) - s3k*a(i, 3, kp)
        y3pd = c3k*ad(i, 3, kp) + s3k*ad(i, 3, k)
        y3p = c3k*a(i, 3, kp) + s3k*a(i, 3, k)
        x4pd = c4k*ad(i, 4, k) - s4k*ad(i, 4, kp)
        x4p = c4k*a(i, 4, k) - s4k*a(i, 4, kp)
        y4pd = c4k*ad(i, 4, kp) + s4k*ad(i, 4, k)
        y4p = c4k*a(i, 4, kp) + s4k*a(i, 4, k)
        t1rd = x1pd + x4pd
        t1r = x1p + x4p
        t1id = y1pd + y4pd
        t1i = y1p + y4p
        t2rd = x2pd + x3pd
        t2r = x2p + x3p
        t2id = y2pd + y3pd
        t2i = y2p + y3p
        t3rd = sin72*(x1pd-x4pd)
        t3r = sin72*(x1p-x4p)
        t3id = sin72*(y1pd-y4pd)
        t3i = sin72*(y1p-y4p)
        t4rd = sin72*(x2pd-x3pd)
        t4r = sin72*(x2p-x3p)
        t4id = sin72*(y2pd-y3pd)
        t4i = sin72*(y2p-y3p)
        t5rd = t1rd + t2rd
        t5r = t1r + t2r
        t5id = t1id + t2id
        t5i = t1i + t2i
        t6rd = r54*(t1rd-t2rd)
        t6r = r54*(t1r-t2r)
        t6id = r54*(t1id-t2id)
        t6i = r54*(t1i-t2i)
        t7rd = ad(i, 0, k) - 0.25d0*t5rd
        t7r = a(i, 0, k) - 0.25d0*t5r
        t7id = ad(i, 0, kp) - 0.25d0*t5id
        t7i = a(i, 0, kp) - 0.25d0*t5i
        t8rd = t7rd + t6rd
        t8r = t7r + t6r
        t8id = t7id + t6id
        t8i = t7i + t6i
        t9rd = t7rd - t6rd
        t9r = t7r - t6r
        t9id = t7id - t6id
        t9i = t7i - t6i
        t10rd = t3rd + s36s72*t4rd
        t10r = t3r + s36s72*t4r
        t10id = t3id + s36s72*t4id
        t10i = t3i + s36s72*t4i
        t11rd = s36s72*t3rd - t4rd
        t11r = s36s72*t3r - t4r
        t11id = s36s72*t3id - t4id
        t11i = s36s72*t3i - t4i
        bd(i, k, 0) = ad(i, 0, k) + t5rd
        b(i, k, 0) = a(i, 0, k) + t5r
        bd(i, kp, 0) = t8rd - t10id
        b(i, kp, 0) = t8r - t10i
        bd(i, k, 1) = t8rd + t10id
        b(i, k, 1) = t8r + t10i
        bd(i, kp, 1) = t9rd - t11id
        b(i, kp, 1) = t9r - t11i
        bd(i, k, 2) = t9rd + t11id
        b(i, k, 2) = t9r + t11i
        bd(i, kp, 2) = t9id - t11rd
        b(i, kp, 2) = t9i - t11r
        bd(i, k, 3) = -t9id - t11rd
        b(i, k, 3) = -t9i - t11r
        bd(i, kp, 3) = t8id - t10rd
        b(i, kp, 3) = t8i - t10r
        bd(i, k, 4) = -t8id - t10rd
        b(i, k, 4) = -t8i - t10r
        bd(i, kp, 4) = ad(i, 0, kp) + t5id
        b(i, kp, 4) = a(i, 0, kp) + t5i
      END DO
    END DO
  END IF
!
!     Code for K=R/2 when R is even not needed
!
!     IF (MOD(R,2).EQ.0) THEN
!        R2 = R/2
!        DO 120 I = 0, P - 1
!           T1 = SIN72*(A(I,1,R2)+A(I,4,R2))
!           T2 = SIN72*(A(I,2,R2)+A(I,3,R2))
!           T3 = A(I,1,R2) - A(I,4,R2)
!           T4 = A(I,2,R2) - A(I,3,R2)
!           T5 = T4 - T3
!           T6 = R54*(T4+T3)
!           T7 = A(I,0,R2) - 0.25D0*T5
!           B(I,R2,0) = T7 + T6
!           B(I,R2,1) = T7 - T6
!           B(I,R2,2) = A(I,0,R2) + T5
!           B(I,R2,3) = -T1 + S36S72*T2
!           B(I,R2,4) = -S36S72*T1 - T2
! 120    CONTINUE
!     END IF
!
  RETURN
END SUBROUTINE C06FPT_D

!  Differentiation of c06fpu in forward (tangent) mode:
!   variations   of useful results: b
!   with respect to varying inputs: a b
SUBROUTINE C06FPU_D(a, ad, b, bd, p, r, cosine, sine)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     MARK 14 REVISED. IER-696 (DEC 1989).
!
!     Radix four real to Hermitian fast Fourier transform kernel
!
!     Self-sorting, decimation in time
!
!     .. Parameters ..
  DOUBLE PRECISION :: root2i
  PARAMETER (root2i=0.707106781186547524400844362104849d0)
!     .. Scalar Arguments ..
  INTEGER :: p, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:3, 0:r-1), b(0:p-1, 0:r-1, 0:3), cosine&
& (0:r-1, 3), sine(0:r-1, 3)
  DOUBLE PRECISION :: ad(0:p-1, 0:3, 0:r-1), bd(0:p-1, 0:r-1, 0:3)
!     .. Local Scalars ..
  DOUBLE PRECISION :: c2k, c3k, ck, s2k, s3k, sk, t1, t1i, t1r, t2, t2i&
& , t2r, t3i, t3r, t4i, t4r, x1p, x2p, x3p, y1p, y2p, y3p
  DOUBLE PRECISION :: t1d, t1id, t1rd, t2d, t2id, t2rd, t3id, t3rd, t4id&
& , t4rd, x1pd, x2pd, x3pd, y1pd, y2pd, y3pd
  INTEGER :: i, k, kp, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
!     .. Executable Statements ..
  DO i=0,p-1
!
!        Code for K=0 --
!
    t1d = ad(i, 0, 0) + ad(i, 2, 0)
    t1 = a(i, 0, 0) + a(i, 2, 0)
    t2d = ad(i, 1, 0) + ad(i, 3, 0)
    t2 = a(i, 1, 0) + a(i, 3, 0)
    bd(i, 0, 0) = t1d + t2d
    b(i, 0, 0) = t1 + t2
    bd(i, 0, 1) = ad(i, 0, 0) - ad(i, 2, 0)
    b(i, 0, 1) = a(i, 0, 0) - a(i, 2, 0)
    bd(i, 0, 2) = t1d - t2d
    b(i, 0, 2) = t1 - t2
    bd(i, 0, 3) = ad(i, 3, 0) - ad(i, 1, 0)
    b(i, 0, 3) = -a(i, 1, 0) + a(i, 3, 0)
  END DO
!
!     Code for general K --
!
  IF (p .LT. (r-1)/2) THEN
    DO i=0,p-1
!DIR$ IVDEP
      DO k=1,(r-1)/2
        x1pd = cosine(k, 1)*ad(i, 1, k) - sine(k, 1)*ad(i, 1, r-k)
        x1p = cosine(k, 1)*a(i, 1, k) - sine(k, 1)*a(i, 1, r-k)
        y1pd = cosine(k, 1)*ad(i, 1, r-k) + sine(k, 1)*ad(i, 1, k)
        y1p = cosine(k, 1)*a(i, 1, r-k) + sine(k, 1)*a(i, 1, k)
        x2pd = cosine(k, 2)*ad(i, 2, k) - sine(k, 2)*ad(i, 2, r-k)
        x2p = cosine(k, 2)*a(i, 2, k) - sine(k, 2)*a(i, 2, r-k)
        y2pd = cosine(k, 2)*ad(i, 2, r-k) + sine(k, 2)*ad(i, 2, k)
        y2p = cosine(k, 2)*a(i, 2, r-k) + sine(k, 2)*a(i, 2, k)
        x3pd = cosine(k, 3)*ad(i, 3, k) - sine(k, 3)*ad(i, 3, r-k)
        x3p = cosine(k, 3)*a(i, 3, k) - sine(k, 3)*a(i, 3, r-k)
        y3pd = cosine(k, 3)*ad(i, 3, r-k) + sine(k, 3)*ad(i, 3, k)
        y3p = cosine(k, 3)*a(i, 3, r-k) + sine(k, 3)*a(i, 3, k)
        t1rd = ad(i, 0, k) + x2pd
        t1r = a(i, 0, k) + x2p
        t1id = ad(i, 0, r-k) + y2pd
        t1i = a(i, 0, r-k) + y2p
        t2rd = x1pd + x3pd
        t2r = x1p + x3p
        t2id = y1pd + y3pd
        t2i = y1p + y3p
        t3rd = ad(i, 0, k) - x2pd
        t3r = a(i, 0, k) - x2p
        t3id = ad(i, 0, r-k) - y2pd
        t3i = a(i, 0, r-k) - y2p
        t4rd = x1pd - x3pd
        t4r = x1p - x3p
        t4id = y1pd - y3pd
        t4i = y1p - y3p
        bd(i, k, 0) = t1rd + t2rd
        b(i, k, 0) = t1r + t2r
        bd(i, r-k, 0) = t3rd - t4id
        b(i, r-k, 0) = t3r - t4i
        bd(i, k, 1) = t3rd + t4id
        b(i, k, 1) = t3r + t4i
        bd(i, r-k, 1) = t1rd - t2rd
        b(i, r-k, 1) = t1r - t2r
        bd(i, k, 2) = t2id - t1id
        b(i, k, 2) = t2i - t1i
        bd(i, r-k, 2) = t3id - t4rd
        b(i, r-k, 2) = t3i - t4r
        bd(i, k, 3) = -t3id - t4rd
        b(i, k, 3) = -t3i - t4r
        bd(i, r-k, 3) = t1id + t2id
        b(i, r-k, 3) = t1i + t2i
      END DO
    END DO
  ELSE
    DO k=1,(r-1)/2
      kp = r - k
      ck = cosine(k, 1)
      sk = sine(k, 1)
      c2k = cosine(k, 2)
      s2k = sine(k, 2)
      c3k = cosine(k, 3)
      s3k = sine(k, 3)
      DO i=0,p-1
        x1pd = ck*ad(i, 1, k) - sk*ad(i, 1, kp)
        x1p = ck*a(i, 1, k) - sk*a(i, 1, kp)
        y1pd = ck*ad(i, 1, kp) + sk*ad(i, 1, k)
        y1p = ck*a(i, 1, kp) + sk*a(i, 1, k)
        x2pd = c2k*ad(i, 2, k) - s2k*ad(i, 2, kp)
        x2p = c2k*a(i, 2, k) - s2k*a(i, 2, kp)
        y2pd = c2k*ad(i, 2, kp) + s2k*ad(i, 2, k)
        y2p = c2k*a(i, 2, kp) + s2k*a(i, 2, k)
        x3pd = c3k*ad(i, 3, k) - s3k*ad(i, 3, kp)
        x3p = c3k*a(i, 3, k) - s3k*a(i, 3, kp)
        y3pd = c3k*ad(i, 3, kp) + s3k*ad(i, 3, k)
        y3p = c3k*a(i, 3, kp) + s3k*a(i, 3, k)
        t1rd = ad(i, 0, k) + x2pd
        t1r = a(i, 0, k) + x2p
        t1id = ad(i, 0, kp) + y2pd
        t1i = a(i, 0, kp) + y2p
        t2rd = x1pd + x3pd
        t2r = x1p + x3p
        t2id = y1pd + y3pd
        t2i = y1p + y3p
        t3rd = ad(i, 0, k) - x2pd
        t3r = a(i, 0, k) - x2p
        t3id = ad(i, 0, kp) - y2pd
        t3i = a(i, 0, kp) - y2p
        t4rd = x1pd - x3pd
        t4r = x1p - x3p
        t4id = y1pd - y3pd
        t4i = y1p - y3p
        bd(i, k, 0) = t1rd + t2rd
        b(i, k, 0) = t1r + t2r
        bd(i, kp, 0) = t3rd - t4id
        b(i, kp, 0) = t3r - t4i
        bd(i, k, 1) = t3rd + t4id
        b(i, k, 1) = t3r + t4i
        bd(i, kp, 1) = t1rd - t2rd
        b(i, kp, 1) = t1r - t2r
        bd(i, k, 2) = t2id - t1id
        b(i, k, 2) = t2i - t1i
        bd(i, kp, 2) = t3id - t4rd
        b(i, kp, 2) = t3i - t4r
        bd(i, k, 3) = -t3id - t4rd
        b(i, k, 3) = -t3i - t4r
        bd(i, kp, 3) = t1id + t2id
        b(i, kp, 3) = t1i + t2i
      END DO
    END DO
  END IF
!
!     Code for K=R/2 when R is even --
!
  IF (MOD(r, 2) .EQ. 0) THEN
    r2 = r/2
    DO i=0,p-1
      t1d = root2i*(ad(i, 1, r2)-ad(i, 3, r2))
      t1 = root2i*(a(i, 1, r2)-a(i, 3, r2))
      t2d = root2i*(ad(i, 1, r2)+ad(i, 3, r2))
      t2 = root2i*(a(i, 1, r2)+a(i, 3, r2))
      bd(i, r2, 0) = ad(i, 0, r2) + t1d
      b(i, r2, 0) = a(i, 0, r2) + t1
      bd(i, r2, 1) = ad(i, 0, r2) - t1d
      b(i, r2, 1) = a(i, 0, r2) - t1
      bd(i, r2, 2) = ad(i, 2, r2) - t2d
      b(i, r2, 2) = a(i, 2, r2) - t2
      bd(i, r2, 3) = -ad(i, 2, r2) - t2d
      b(i, r2, 3) = -a(i, 2, r2) - t2
    END DO
  END IF
!
  RETURN
END SUBROUTINE C06FPU_D

!  Differentiation of c06fpv in forward (tangent) mode:
!   variations   of useful results: b
!   with respect to varying inputs: a b
SUBROUTINE C06FPV_D(a, ad, b, bd, p, r, cosine, sine)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     MARK 14 REVISED. IER-697 (DEC 1989).
!
!     Radix three Real to Hermitian fast Fourier transform kernel
!
!     Self-sorting, decimation in time
!
!     .. Parameters ..
  DOUBLE PRECISION :: sin60
  PARAMETER (sin60=0.866025403784438646763723170752936d0)
!     .. Scalar Arguments ..
  INTEGER :: p, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:2, 0:r-1), b(0:p-1, 0:r-1, 0:2), cosine&
& (0:r-1, 2), sine(0:r-1, 2)
  DOUBLE PRECISION :: ad(0:p-1, 0:2, 0:r-1), bd(0:p-1, 0:r-1, 0:2)
!     .. Local Scalars ..
  DOUBLE PRECISION :: c2k, ck, s2k, sk, t1, t1i, t1r, t2i, t2r, t3i, t3r&
& , x1p, x2p, y1p, y2p
  DOUBLE PRECISION :: t1d, t1id, t1rd, t2id, t2rd, t3id, t3rd, x1pd, &
& x2pd, y1pd, y2pd
  INTEGER :: i, k, kp, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
!     .. Executable Statements ..
  DO i=0,p-1
!
!        Code for K=0 --
!
    t1d = ad(i, 1, 0) + ad(i, 2, 0)
    t1 = a(i, 1, 0) + a(i, 2, 0)
    bd(i, 0, 0) = ad(i, 0, 0) + t1d
    b(i, 0, 0) = a(i, 0, 0) + t1
    bd(i, 0, 1) = ad(i, 0, 0) - 0.5d0*t1d
    b(i, 0, 1) = a(i, 0, 0) - 0.5d0*t1
    bd(i, 0, 2) = -(sin60*(ad(i, 1, 0)-ad(i, 2, 0)))
    b(i, 0, 2) = -(sin60*(a(i, 1, 0)-a(i, 2, 0)))
  END DO
!
!     Code for general K
!
  IF (p .LE. (r-1)/2) THEN
    DO i=0,p-1
!DIR$ IVDEP
      DO k=1,(r-1)/2
        x1pd = cosine(k, 1)*ad(i, 1, k) - sine(k, 1)*ad(i, 1, r-k)
        x1p = cosine(k, 1)*a(i, 1, k) - sine(k, 1)*a(i, 1, r-k)
        y1pd = cosine(k, 1)*ad(i, 1, r-k) + sine(k, 1)*ad(i, 1, k)
        y1p = cosine(k, 1)*a(i, 1, r-k) + sine(k, 1)*a(i, 1, k)
        x2pd = cosine(k, 2)*ad(i, 2, k) - sine(k, 2)*ad(i, 2, r-k)
        x2p = cosine(k, 2)*a(i, 2, k) - sine(k, 2)*a(i, 2, r-k)
        y2pd = cosine(k, 2)*ad(i, 2, r-k) + sine(k, 2)*ad(i, 2, k)
        y2p = cosine(k, 2)*a(i, 2, r-k) + sine(k, 2)*a(i, 2, k)
        t1rd = x1pd + x2pd
        t1r = x1p + x2p
        t1id = y1pd + y2pd
        t1i = y1p + y2p
        t2rd = ad(i, 0, k) - 0.5d0*t1rd
        t2r = a(i, 0, k) - 0.5d0*t1r
        t2id = ad(i, 0, r-k) - 0.5d0*t1id
        t2i = a(i, 0, r-k) - 0.5d0*t1i
        t3rd = sin60*(x1pd-x2pd)
        t3r = sin60*(x1p-x2p)
        t3id = sin60*(y1pd-y2pd)
        t3i = sin60*(y1p-y2p)
        bd(i, k, 0) = ad(i, 0, k) + t1rd
        b(i, k, 0) = a(i, 0, k) + t1r
        bd(i, r-k, 0) = t2rd - t3id
        b(i, r-k, 0) = t2r - t3i
        bd(i, k, 1) = t2rd + t3id
        b(i, k, 1) = t2r + t3i
        bd(i, r-k, 1) = t2id - t3rd
        b(i, r-k, 1) = t2i - t3r
        bd(i, k, 2) = -(t2id+t3rd)
        b(i, k, 2) = -(t2i+t3r)
        bd(i, r-k, 2) = ad(i, 0, r-k) + t1id
        b(i, r-k, 2) = a(i, 0, r-k) + t1i
      END DO
    END DO
  ELSE
    DO k=1,(r-1)/2
      kp = r - k
      ck = cosine(k, 1)
      sk = sine(k, 1)
      c2k = cosine(k, 2)
      s2k = sine(k, 2)
      DO i=0,p-1
        x1pd = ck*ad(i, 1, k) - sk*ad(i, 1, kp)
        x1p = ck*a(i, 1, k) - sk*a(i, 1, kp)
        y1pd = ck*ad(i, 1, kp) + sk*ad(i, 1, k)
        y1p = ck*a(i, 1, kp) + sk*a(i, 1, k)
        x2pd = c2k*ad(i, 2, k) - s2k*ad(i, 2, kp)
        x2p = c2k*a(i, 2, k) - s2k*a(i, 2, kp)
        y2pd = c2k*ad(i, 2, kp) + s2k*ad(i, 2, k)
        y2p = c2k*a(i, 2, kp) + s2k*a(i, 2, k)
        t1rd = x1pd + x2pd
        t1r = x1p + x2p
        t1id = y1pd + y2pd
        t1i = y1p + y2p
        t2rd = ad(i, 0, k) - 0.5d0*t1rd
        t2r = a(i, 0, k) - 0.5d0*t1r
        t2id = ad(i, 0, kp) - 0.5d0*t1id
        t2i = a(i, 0, kp) - 0.5d0*t1i
        t3rd = sin60*(x1pd-x2pd)
        t3r = sin60*(x1p-x2p)
        t3id = sin60*(y1pd-y2pd)
        t3i = sin60*(y1p-y2p)
        bd(i, k, 0) = ad(i, 0, k) + t1rd
        b(i, k, 0) = a(i, 0, k) + t1r
        bd(i, kp, 0) = t2rd - t3id
        b(i, kp, 0) = t2r - t3i
        bd(i, k, 1) = t2rd + t3id
        b(i, k, 1) = t2r + t3i
        bd(i, kp, 1) = t2id - t3rd
        b(i, kp, 1) = t2i - t3r
        bd(i, k, 2) = -(t2id+t3rd)
        b(i, k, 2) = -(t2i+t3r)
        bd(i, kp, 2) = ad(i, 0, kp) + t1id
        b(i, kp, 2) = a(i, 0, kp) + t1i
      END DO
    END DO
  END IF
!
!     Code for K=R/2 when R is even not needed
!
!     IF (MOD(R,2).EQ.0) THEN
!        R2 = R/2
!        DO 120 I = 0, P - 1
!           T1 = A(I,1,R2) - A(I,2,R2)
!           B(I,R2,0) = A(I,0,R2) + 0.5D0*T1
!           B(I,R2,1) = A(I,0,R2) - T1
!           B(I,R2,2) = -SIN60*(A(I,1,R2)+A(I,2,R2))
! 120    CONTINUE
!     END IF
!
  RETURN
END SUBROUTINE C06FPV_D

!  Differentiation of c06fpw in forward (tangent) mode:
!   variations   of useful results: b
!   with respect to varying inputs: a b
SUBROUTINE C06FPW_D(a, ad, b, bd, p, r, cosine, sine)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     MARK 14 REVISED. IER-698 (DEC 1989).
!
!     Radix two Real to Hermitian fast Fourier transform kernel
!
!     Self-sorting, decimation in time
!
!     .. Scalar Arguments ..
  INTEGER :: p, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:1, 0:r-1), b(0:p-1, 0:r-1, 0:1), cosine&
& (0:r-1), sine(0:r-1)
  DOUBLE PRECISION :: ad(0:p-1, 0:1, 0:r-1), bd(0:p-1, 0:r-1, 0:1)
!     .. Local Scalars ..
  DOUBLE PRECISION :: ck, sk, x1, y1
  DOUBLE PRECISION :: x1d, y1d
  INTEGER :: i, k, kp, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
!     .. Executable Statements ..
  DO i=0,p-1
!
!        Code for K=0 --
!
    bd(i, 0, 0) = ad(i, 0, 0) + ad(i, 1, 0)
    b(i, 0, 0) = a(i, 0, 0) + a(i, 1, 0)
    bd(i, 0, 1) = ad(i, 0, 0) - ad(i, 1, 0)
    b(i, 0, 1) = a(i, 0, 0) - a(i, 1, 0)
  END DO
!
!     Code for general K
!
  IF (p .LT. (r-1)/2) THEN
    DO i=0,p-1
!DIR$ IVDEP
      DO k=1,(r-1)/2
        x1d = cosine(k)*ad(i, 1, k) - sine(k)*ad(i, 1, r-k)
        x1 = cosine(k)*a(i, 1, k) - sine(k)*a(i, 1, r-k)
        y1d = cosine(k)*ad(i, 1, r-k) + sine(k)*ad(i, 1, k)
        y1 = cosine(k)*a(i, 1, r-k) + sine(k)*a(i, 1, k)
        bd(i, k, 0) = ad(i, 0, k) + x1d
        b(i, k, 0) = a(i, 0, k) + x1
        bd(i, r-k, 0) = ad(i, 0, k) - x1d
        b(i, r-k, 0) = a(i, 0, k) - x1
        bd(i, k, 1) = y1d - ad(i, 0, r-k)
        b(i, k, 1) = -a(i, 0, r-k) + y1
        bd(i, r-k, 1) = ad(i, 0, r-k) + y1d
        b(i, r-k, 1) = a(i, 0, r-k) + y1
      END DO
    END DO
  ELSE
    DO k=1,(r-1)/2
      kp = r - k
      ck = cosine(k)
      sk = sine(k)
      DO i=0,p-1
        x1d = ck*ad(i, 1, k) - sk*ad(i, 1, kp)
        x1 = ck*a(i, 1, k) - sk*a(i, 1, kp)
        y1d = ck*ad(i, 1, kp) + sk*ad(i, 1, k)
        y1 = ck*a(i, 1, kp) + sk*a(i, 1, k)
        bd(i, k, 0) = ad(i, 0, k) + x1d
        b(i, k, 0) = a(i, 0, k) + x1
        bd(i, kp, 0) = ad(i, 0, k) - x1d
        b(i, kp, 0) = a(i, 0, k) - x1
        bd(i, k, 1) = y1d - ad(i, 0, kp)
        b(i, k, 1) = -a(i, 0, kp) + y1
        bd(i, kp, 1) = ad(i, 0, kp) + y1d
        b(i, kp, 1) = a(i, 0, kp) + y1
      END DO
    END DO
  END IF
!
!     Code for K=R/2 when R is even not needed
!
!     IF (MOD(R,2).EQ.0) THEN
!        R2 = R/2
!        DO 120 I = 0, P - 1
!           B(I,R2,0) = A(I,0,R2)
!           B(I,R2,1) = -A(I,1,R2)
! 120    CONTINUE
!     END IF
!
  RETURN
END SUBROUTINE C06FPW_D

!  Differentiation of c06fqf in forward (tangent) mode:
!   variations   of useful results: x work
!   with respect to varying inputs: x work
SUBROUTINE C06FQF_D(m, n, x, xd, init, trig, work, workd, ifail)
  IMPLICIT NONE
!VD$R NOVECTOR
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     .. Parameters ..
  CHARACTER(len=6) :: srname
  PARAMETER (srname='C06FQF')
!     .. Scalar Arguments ..
  INTEGER :: ifail, m, n
  CHARACTER(len=1) :: init
!     .. Array Arguments ..
  DOUBLE PRECISION :: trig(2*n), work(m*n), x(m*n)
  DOUBLE PRECISION :: workd(m*n), xd(m*n)
!     .. Local Scalars ..
  INTEGER :: ierror, nq, nrec
!     .. Local Arrays ..
  INTEGER :: q(30)
  CHARACTER(len=80) :: rec(1)
  EXTERNAL P01ABF
!     .. External Functions ..
  INTEGER :: P01ABF
!     .. External Subroutines ..
  EXTERNAL C06FPQ, C06FQX
  EXTERNAL C06FQX_D
!     .. Executable Statements ..
  CALL C06FPQ(m, n, init, trig, q, nq, ierror)
  IF (ierror .EQ. 0) CALL C06FQX_D(x, xd, work, workd, m, n, q, nq, trig&
&                           )
!CWH      ELSE IF (IERROR.EQ.1) THEN
!CWH         WRITE (REC(1),FMT=99999) M
!CWH      ELSE IF (IERROR.EQ.2) THEN
!CWH         WRITE (REC(1),FMT=99998) N
!CWH      ELSE IF (IERROR.EQ.3) THEN
!CWH         WRITE (REC(1),FMT=99997) INIT
!CWH      ELSE IF (IERROR.EQ.4) THEN
!CWH         WRITE (REC(1),FMT=99996) INIT
!CWH      ELSE IF (IERROR.EQ.5) THEN
!CWH         WRITE (REC(1),FMT=99995) INIT
!
  nrec = 1
  ifail = P01ABF(ifail, ierror, srname, nrec, rec)
!
  RETURN
!
99999 FORMAT(' ** M must be at least 1: M = ',i16)
99998 FORMAT(' ** N must be at least 1: N = ',i16)
99997 FORMAT(' ** ',a1,' is an invalid value of INIT')
99996 FORMAT(' ** INIT = ',a1,', but TRIG array never initialized')
99995 FORMAT(' ** INIT = ',a1,', but N and TRIG array incompatible')
END SUBROUTINE C06FQF_D

!  Differentiation of c06fqx in forward (tangent) mode:
!   variations   of useful results: a b
!   with respect to varying inputs: a b
SUBROUTINE C06FQX_D(a, ad, b, bd, m, n, q, nq, trig)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!
!     Hermitian to Real Fast Fourier Transform Kernel Driver
!
!     Self-sorting, decimation in frequency
!
!     .. Scalar Arguments ..
  INTEGER :: m, n, nq
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:m*n-1), b(0:m*n-1), trig(0:2*n-1)
  DOUBLE PRECISION :: ad(0:m*n-1), bd(0:m*n-1)
  INTEGER :: q(nq)
!     .. Local Scalars ..
  DOUBLE PRECISION :: factor
  INTEGER :: i, p, qi, r
  LOGICAL :: ina
!     .. External Subroutines ..
  EXTERNAL C06FQQ, C06FQR, C06FQS, C06FQT, C06FQU, C06FQV, C06FQW
  EXTERNAL C06FQQ_D, C06FQR_D, C06FQS_D, C06FQT_D, C06FQU_D, C06FQV_D, &
&     C06FQW_D
!     .. Intrinsic Functions ..
  INTRINSIC SQRT, DBLE
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: result1
!     .. Executable Statements ..
  ina = .true.
  p = 1
  r = n
  IF (n .EQ. 1) THEN
    RETURN
  ELSE
    CALL C06FQQ_D(a, ad, m, n)
    DO i=1,nq
      qi = q(i)
      r = r/qi
      IF (ina) THEN
        IF (qi .EQ. 2) THEN
          CALL C06FQW_D(a, ad, b, bd, m*p, r, trig((p-1)*qi*r), trig(n+(&
&                 p-1)*qi*r))
        ELSE IF (qi .EQ. 3) THEN
          CALL C06FQV_D(a, ad, b, bd, m*p, r, trig((p-1)*qi*r), trig(n+(&
&                 p-1)*qi*r))
        ELSE IF (qi .EQ. 4) THEN
          CALL C06FQU_D(a, ad, b, bd, m*p, r, trig((p-1)*qi*r), trig(n+(&
&                 p-1)*qi*r))
        ELSE IF (qi .EQ. 5) THEN
          CALL C06FQT_D(a, ad, b, bd, m*p, r, trig((p-1)*qi*r), trig(n+(&
&                 p-1)*qi*r))
        ELSE IF (qi .EQ. 6) THEN
          CALL C06FQS_D(a, ad, b, bd, m*p, r, trig((p-1)*qi*r), trig(n+(&
&                 p-1)*qi*r))
        ELSE
          CALL C06FQR_D(a, ad, b, bd, m*p, qi, r, trig((p-1)*qi*r), trig&
&                 (n+(p-1)*qi*r))
        END IF
      ELSE IF (qi .EQ. 2) THEN
        CALL C06FQW_D(b, bd, a, ad, m*p, r, trig((p-1)*qi*r), trig(n+(p-&
&               1)*qi*r))
      ELSE IF (qi .EQ. 3) THEN
        CALL C06FQV_D(b, bd, a, ad, m*p, r, trig((p-1)*qi*r), trig(n+(p-&
&               1)*qi*r))
      ELSE IF (qi .EQ. 4) THEN
        CALL C06FQU_D(b, bd, a, ad, m*p, r, trig((p-1)*qi*r), trig(n+(p-&
&               1)*qi*r))
      ELSE IF (qi .EQ. 5) THEN
        CALL C06FQT_D(b, bd, a, ad, m*p, r, trig((p-1)*qi*r), trig(n+(p-&
&               1)*qi*r))
      ELSE IF (qi .EQ. 6) THEN
        CALL C06FQS_D(b, bd, a, ad, m*p, r, trig((p-1)*qi*r), trig(n+(p-&
&               1)*qi*r))
      ELSE
        CALL C06FQR_D(b, bd, a, ad, m*p, qi, r, trig((p-1)*qi*r), trig(n&
&               +(p-1)*qi*r))
      END IF
      ina = .NOT.ina
      p = p*qi
    END DO
!
    arg1 = DBLE(n)
    result1 = SQRT(arg1)
    factor = 2.0d0/result1
    IF (ina) THEN
      DO i=0,m*n-1
        ad(i) = factor*ad(i)
        a(i) = a(i)*factor
      END DO
    ELSE
      DO i=0,m*n-1
        ad(i) = factor*bd(i)
        a(i) = b(i)*factor
      END DO
    END IF
!
    RETURN
  END IF
END SUBROUTINE C06FQX_D

!  Differentiation of c06fqq in forward (tangent) mode:
!   variations   of useful results: a
!   with respect to varying inputs: a
SUBROUTINE C06FQQ_D(a, ad, m, n)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     .. Scalar Arguments ..
  INTEGER :: m, n
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:m-1, 0:n-1)
  DOUBLE PRECISION :: ad(0:m-1, 0:n-1)
!     .. Local Scalars ..
  INTEGER :: l
!     .. Intrinsic Functions ..
  INTRINSIC MOD
!     .. Executable Statements ..
  DO l=0,m-1
    ad(l, 0) = 0.5d0*ad(l, 0)
    a(l, 0) = 0.5d0*a(l, 0)
  END DO
  IF (MOD(n, 2) .EQ. 0) THEN
    DO l=0,m-1
      ad(l, n/2) = 0.5d0*ad(l, n/2)
      a(l, n/2) = 0.5d0*a(l, n/2)
    END DO
  END IF
!
  RETURN
END SUBROUTINE C06FQQ_D

!  Differentiation of c06fqr in forward (tangent) mode:
!   variations   of useful results: a b
!   with respect to varying inputs: a b
SUBROUTINE C06FQR_D(a, ad, b, bd, p, q, r, cosine, sine)
  IMPLICIT NONE
!     MARK 15 RE-ISSUE. NAG COPYRIGHT 1991.
!
!     Hermitian to real fast Fourier transform kernel
!     Odd factors greater than 6
!
!     Self-sorting, decimation in frequency
!
!     .. Scalar Arguments ..
  INTEGER :: p, q, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:r-1, 0:q-1), b(0:p-1, 0:q-1, 0:r-1), &
& cosine(0:r-1, q-1), sine(0:r-1, q-1)
  DOUBLE PRECISION :: ad(0:p-1, 0:r-1, 0:q-1), bd(0:p-1, 0:q-1, 0:r-1)
!     .. Local Scalars ..
  DOUBLE PRECISION :: bi, br, temp, temp1, tempi, tempr
  DOUBLE PRECISION :: bid, brd, tempd, temp1d, tempid, temprd
  INTEGER :: i, indx, j, k, kp, l, q2, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
!     .. Executable Statements ..
!
  q2 = (q-1)/2
  IF (p .GE. r/2) THEN
!
!        Code for K=0 --
!
    DO l=1,q2
      DO i=0,p-1
        bd(i, l, 0) = ad(i, 0, 0)
        b(i, l, 0) = a(i, 0, 0)
        bd(i, q-l, 0) = 0.D0
        b(i, q-l, 0) = 0.0d0
      END DO
      DO j=1,q2
        indx = MOD(j*l, q)
        DO i=0,p-1
          bd(i, l, 0) = bd(i, l, 0) + cosine(0, indx)*ad(i, 0, j)
          b(i, l, 0) = b(i, l, 0) + a(i, 0, j)*cosine(0, indx)
          bd(i, q-l, 0) = bd(i, q-l, 0) - sine(0, indx)*ad(i, 0, q-j)
          b(i, q-l, 0) = b(i, q-l, 0) - a(i, 0, q-j)*sine(0, indx)
        END DO
      END DO
    END DO
    DO i=0,p-1
      bd(i, 0, 0) = ad(i, 0, 0)
      b(i, 0, 0) = a(i, 0, 0)
    END DO
    DO j=1,q2
      DO i=0,p-1
        bd(i, 0, 0) = bd(i, 0, 0) + ad(i, 0, j)
        b(i, 0, 0) = b(i, 0, 0) + a(i, 0, j)
      END DO
    END DO
    DO j=1,q2
      DO i=0,p-1
        tempd = bd(i, j, 0)
        temp = b(i, j, 0)
        bd(i, j, 0) = bd(i, j, 0) + bd(i, q-j, 0)
        b(i, j, 0) = b(i, j, 0) + b(i, q-j, 0)
        bd(i, q-j, 0) = tempd - bd(i, q-j, 0)
        b(i, q-j, 0) = temp - b(i, q-j, 0)
      END DO
    END DO
!
!        Code for general K --
!
    DO k=1,(r-1)/2
      kp = r - k
      DO j=1,q2
        DO i=0,p-1
          temprd = ad(i, k, j)
          tempr = a(i, k, j)
          tempid = ad(i, kp, q-j-1)
          tempi = a(i, kp, q-j-1)
          ad(i, k, j) = temprd + ad(i, kp, j-1)
          a(i, k, j) = tempr + a(i, kp, j-1)
          ad(i, kp, q-j-1) = tempid - ad(i, k, q-j)
          a(i, kp, q-j-1) = tempi - a(i, k, q-j)
          ad(i, kp, j-1) = temprd - ad(i, kp, j-1)
          a(i, kp, j-1) = tempr - a(i, kp, j-1)
          ad(i, k, q-j) = -tempid - ad(i, k, q-j)
          a(i, k, q-j) = -tempi - a(i, k, q-j)
        END DO
      END DO
      DO l=1,q2
        DO i=0,p-1
          bd(i, l, k) = ad(i, k, 0)
          b(i, l, k) = a(i, k, 0)
          bd(i, l, kp) = ad(i, kp, q-1)
          b(i, l, kp) = a(i, kp, q-1)
          bd(i, q-l, k) = 0.D0
          b(i, q-l, k) = 0.0d0
          bd(i, q-l, kp) = 0.D0
          b(i, q-l, kp) = 0.0d0
        END DO
        DO j=1,q2
          indx = MOD(j*l, q)
          DO i=0,p-1
            bd(i, l, k) = bd(i, l, k) + cosine(0, indx)*ad(i, k, j)
            b(i, l, k) = b(i, l, k) + a(i, k, j)*cosine(0, indx)
            bd(i, l, kp) = bd(i, l, kp) + cosine(0, indx)*ad(i, kp, q-j-&
&             1)
            b(i, l, kp) = b(i, l, kp) + a(i, kp, q-j-1)*cosine(0, indx)
            bd(i, q-l, k) = bd(i, q-l, k) + sine(0, indx)*ad(i, kp, j-1)
            b(i, q-l, k) = b(i, q-l, k) + a(i, kp, j-1)*sine(0, indx)
            bd(i, q-l, kp) = bd(i, q-l, kp) - sine(0, indx)*ad(i, k, q-j&
&             )
            b(i, q-l, kp) = b(i, q-l, kp) - a(i, k, q-j)*sine(0, indx)
          END DO
        END DO
      END DO
      DO i=0,p-1
        bd(i, 0, k) = ad(i, k, 0)
        b(i, 0, k) = a(i, k, 0)
        bd(i, 0, kp) = ad(i, kp, q-1)
        b(i, 0, kp) = a(i, kp, q-1)
      END DO
      DO j=1,q2
        DO i=0,p-1
          bd(i, 0, k) = bd(i, 0, k) + ad(i, k, j)
          b(i, 0, k) = b(i, 0, k) + a(i, k, j)
          bd(i, 0, kp) = bd(i, 0, kp) + ad(i, kp, q-j-1)
          b(i, 0, kp) = b(i, 0, kp) + a(i, kp, q-j-1)
        END DO
      END DO
      DO j=1,q2
        DO i=0,p-1
          temprd = bd(i, j, k)
          tempr = b(i, j, k)
          tempid = bd(i, j, kp)
          tempi = b(i, j, kp)
          bd(i, j, k) = temprd - bd(i, q-j, kp)
          b(i, j, k) = tempr - b(i, q-j, kp)
          bd(i, j, kp) = tempid + bd(i, q-j, k)
          b(i, j, kp) = tempi + b(i, q-j, k)
          temp1d = bd(i, q-j, k)
          temp1 = b(i, q-j, k)
          bd(i, q-j, k) = temprd + bd(i, q-j, kp)
          b(i, q-j, k) = tempr + b(i, q-j, kp)
          bd(i, q-j, kp) = tempid - temp1d
          b(i, q-j, kp) = tempi - temp1
        END DO
      END DO
      DO j=1,q-1
        DO i=0,p-1
          brd = bd(i, j, k)
          br = b(i, j, k)
          bid = bd(i, j, kp)
          bi = b(i, j, kp)
          bd(i, j, k) = cosine(k, j)*brd - sine(k, j)*bid
          b(i, j, k) = cosine(k, j)*br - sine(k, j)*bi
          bd(i, j, kp) = cosine(k, j)*bid + sine(k, j)*brd
          b(i, j, kp) = cosine(k, j)*bi + sine(k, j)*br
        END DO
      END DO
    END DO
!
!        Code for K=R/2 when R is even --
!
    IF (MOD(r, 2) .EQ. 0) THEN
      r2 = r/2
      DO l=1,q2
        DO i=0,p-1
          bd(i, l, r2) = ad(i, r2, q2)
          b(i, l, r2) = a(i, r2, q2)
          bd(i, q-l, r2) = 0.D0
          b(i, q-l, r2) = 0.0d0
        END DO
      END DO
      DO l=1,q2
        DO j=0,q2-1
          indx = MOD(l*(j+q2+1), q)
          DO i=0,p-1
            bd(i, l, r2) = bd(i, l, r2) + cosine(0, indx)*ad(i, r2, j)
            b(i, l, r2) = b(i, l, r2) + a(i, r2, j)*cosine(0, indx)
            bd(i, q-l, r2) = bd(i, q-l, r2) + sine(0, indx)*ad(i, r2, q-&
&             j-1)
            b(i, q-l, r2) = b(i, q-l, r2) + a(i, r2, q-j-1)*sine(0, indx&
&             )
          END DO
        END DO
      END DO
      DO i=0,p-1
        bd(i, 0, r2) = ad(i, r2, q2)
        b(i, 0, r2) = a(i, r2, q2)
      END DO
      DO j=0,q2-1
        DO i=0,p-1
          bd(i, 0, r2) = bd(i, 0, r2) + ad(i, r2, j)
          b(i, 0, r2) = b(i, 0, r2) + a(i, r2, j)
        END DO
      END DO
      DO j=1,q2-1,2
        DO i=0,p-1
          temprd = bd(i, j, r2)
          tempr = b(i, j, r2)
          tempid = bd(i, q-j, r2)
          tempi = b(i, q-j, r2)
          bd(i, j, r2) = tempid - temprd
          b(i, j, r2) = tempi - tempr
          bd(i, q-j, r2) = temprd + tempid
          b(i, q-j, r2) = tempr + tempi
          temprd = bd(i, j+1, r2)
          tempr = b(i, j+1, r2)
          tempid = bd(i, q-j-1, r2)
          tempi = b(i, q-j-1, r2)
          bd(i, j+1, r2) = temprd - tempid
          b(i, j+1, r2) = tempr - tempi
          bd(i, q-j-1, r2) = -temprd - tempid
          b(i, q-j-1, r2) = -tempr - tempi
        END DO
      END DO
      IF (MOD(q2, 2) .EQ. 1) THEN
        DO i=0,p-1
          temprd = bd(i, q2, r2)
          tempr = b(i, q2, r2)
          tempid = bd(i, q2+1, r2)
          tempi = b(i, q2+1, r2)
          bd(i, q2, r2) = tempid - temprd
          b(i, q2, r2) = tempi - tempr
          bd(i, q2+1, r2) = temprd + tempid
          b(i, q2+1, r2) = tempr + tempi
        END DO
      END IF
    END IF
  ELSE
!
!
    DO i=0,p-1
!
!           Code for K=0 --
!
      DO l=1,q2
        bd(i, l, 0) = ad(i, 0, 0)
        b(i, l, 0) = a(i, 0, 0)
        bd(i, q-l, 0) = 0.D0
        b(i, q-l, 0) = 0.0d0
        DO j=1,q2
          indx = MOD(j*l, q)
          bd(i, l, 0) = bd(i, l, 0) + cosine(0, indx)*ad(i, 0, j)
          b(i, l, 0) = b(i, l, 0) + a(i, 0, j)*cosine(0, indx)
          bd(i, q-l, 0) = bd(i, q-l, 0) - sine(0, indx)*ad(i, 0, q-j)
          b(i, q-l, 0) = b(i, q-l, 0) - a(i, 0, q-j)*sine(0, indx)
        END DO
      END DO
      bd(i, 0, 0) = ad(i, 0, 0)
      b(i, 0, 0) = a(i, 0, 0)
      DO j=1,q2
        bd(i, 0, 0) = bd(i, 0, 0) + ad(i, 0, j)
        b(i, 0, 0) = b(i, 0, 0) + a(i, 0, j)
      END DO
      DO j=1,q2
        tempd = bd(i, j, 0)
        temp = b(i, j, 0)
        bd(i, j, 0) = bd(i, j, 0) + bd(i, q-j, 0)
        b(i, j, 0) = b(i, j, 0) + b(i, q-j, 0)
        bd(i, q-j, 0) = tempd - bd(i, q-j, 0)
        b(i, q-j, 0) = temp - b(i, q-j, 0)
      END DO
!
!           Code for general K --
!
      DO j=1,q2
        DO k=1,(r-1)/2
          temprd = ad(i, k, j)
          tempr = a(i, k, j)
          tempid = ad(i, r-k, q-j-1)
          tempi = a(i, r-k, q-j-1)
          ad(i, k, j) = temprd + ad(i, r-k, j-1)
          a(i, k, j) = tempr + a(i, r-k, j-1)
          ad(i, r-k, q-j-1) = tempid - ad(i, k, q-j)
          a(i, r-k, q-j-1) = tempi - a(i, k, q-j)
          ad(i, r-k, j-1) = temprd - ad(i, r-k, j-1)
          a(i, r-k, j-1) = tempr - a(i, r-k, j-1)
          ad(i, k, q-j) = -tempid - ad(i, k, q-j)
          a(i, k, q-j) = -tempi - a(i, k, q-j)
        END DO
      END DO
      DO l=1,q2
        DO k=1,(r-1)/2
          bd(i, l, k) = ad(i, k, 0)
          b(i, l, k) = a(i, k, 0)
          bd(i, l, r-k) = ad(i, r-k, q-1)
          b(i, l, r-k) = a(i, r-k, q-1)
          bd(i, q-l, k) = 0.D0
          b(i, q-l, k) = 0.0d0
          bd(i, q-l, r-k) = 0.D0
          b(i, q-l, r-k) = 0.0d0
        END DO
        DO j=1,q2
          indx = MOD(j*l, q)
          DO k=1,(r-1)/2
            bd(i, l, k) = bd(i, l, k) + cosine(0, indx)*ad(i, k, j)
            b(i, l, k) = b(i, l, k) + a(i, k, j)*cosine(0, indx)
            bd(i, l, r-k) = bd(i, l, r-k) + cosine(0, indx)*ad(i, r-k, q&
&             -j-1)
            b(i, l, r-k) = b(i, l, r-k) + a(i, r-k, q-j-1)*cosine(0, &
&             indx)
            bd(i, q-l, k) = bd(i, q-l, k) + sine(0, indx)*ad(i, r-k, j-1&
&             )
            b(i, q-l, k) = b(i, q-l, k) + a(i, r-k, j-1)*sine(0, indx)
            bd(i, q-l, r-k) = bd(i, q-l, r-k) - sine(0, indx)*ad(i, k, q&
&             -j)
            b(i, q-l, r-k) = b(i, q-l, r-k) - a(i, k, q-j)*sine(0, indx)
          END DO
        END DO
      END DO
      DO k=1,(r-1)/2
        bd(i, 0, k) = ad(i, k, 0)
        b(i, 0, k) = a(i, k, 0)
        bd(i, 0, r-k) = ad(i, r-k, q-1)
        b(i, 0, r-k) = a(i, r-k, q-1)
      END DO
      DO j=1,q2
        DO k=1,(r-1)/2
          bd(i, 0, k) = bd(i, 0, k) + ad(i, k, j)
          b(i, 0, k) = b(i, 0, k) + a(i, k, j)
          bd(i, 0, r-k) = bd(i, 0, r-k) + ad(i, r-k, q-j-1)
          b(i, 0, r-k) = b(i, 0, r-k) + a(i, r-k, q-j-1)
        END DO
      END DO
      DO j=1,q2
        DO k=1,(r-1)/2
          temprd = bd(i, j, k)
          tempr = b(i, j, k)
          tempid = bd(i, j, r-k)
          tempi = b(i, j, r-k)
          bd(i, j, k) = temprd - bd(i, q-j, r-k)
          b(i, j, k) = tempr - b(i, q-j, r-k)
          bd(i, j, r-k) = tempid + bd(i, q-j, k)
          b(i, j, r-k) = tempi + b(i, q-j, k)
          temp1d = bd(i, q-j, k)
          temp1 = b(i, q-j, k)
          bd(i, q-j, k) = temprd + bd(i, q-j, r-k)
          b(i, q-j, k) = tempr + b(i, q-j, r-k)
          bd(i, q-j, r-k) = tempid - temp1d
          b(i, q-j, r-k) = tempi - temp1
        END DO
      END DO
      DO j=1,q-1
        DO k=1,(r-1)/2
          brd = bd(i, j, k)
          br = b(i, j, k)
          bid = bd(i, j, r-k)
          bi = b(i, j, r-k)
          bd(i, j, k) = cosine(k, j)*brd - sine(k, j)*bid
          b(i, j, k) = cosine(k, j)*br - sine(k, j)*bi
          bd(i, j, r-k) = cosine(k, j)*bid + sine(k, j)*brd
          b(i, j, r-k) = cosine(k, j)*bi + sine(k, j)*br
        END DO
      END DO
!
!           Code for K=R/2 when R is even --
!
      IF (MOD(r, 2) .EQ. 0) THEN
        r2 = r/2
        DO l=1,q2
          bd(i, l, r2) = ad(i, r2, q2)
          b(i, l, r2) = a(i, r2, q2)
          bd(i, q-l, r2) = 0.D0
          b(i, q-l, r2) = 0.0d0
        END DO
        DO l=1,q2
          DO j=0,q2-1
            indx = MOD(l*(j+q2+1), q)
            bd(i, l, r2) = bd(i, l, r2) + cosine(0, indx)*ad(i, r2, j)
            b(i, l, r2) = b(i, l, r2) + a(i, r2, j)*cosine(0, indx)
            bd(i, q-l, r2) = bd(i, q-l, r2) + sine(0, indx)*ad(i, r2, q-&
&             j-1)
            b(i, q-l, r2) = b(i, q-l, r2) + a(i, r2, q-j-1)*sine(0, indx&
&             )
          END DO
        END DO
        bd(i, 0, r2) = ad(i, r2, q2)
        b(i, 0, r2) = a(i, r2, q2)
        DO j=0,q2-1
          bd(i, 0, r2) = bd(i, 0, r2) + ad(i, r2, j)
          b(i, 0, r2) = b(i, 0, r2) + a(i, r2, j)
        END DO
        DO j=1,q2-1,2
          temprd = bd(i, j, r2)
          tempr = b(i, j, r2)
          tempid = bd(i, q-j, r2)
          tempi = b(i, q-j, r2)
          bd(i, j, r2) = tempid - temprd
          b(i, j, r2) = tempi - tempr
          bd(i, q-j, r2) = temprd + tempid
          b(i, q-j, r2) = tempr + tempi
          temprd = bd(i, j+1, r2)
          tempr = b(i, j+1, r2)
          tempid = bd(i, q-j-1, r2)
          tempi = b(i, q-j-1, r2)
          bd(i, j+1, r2) = temprd - tempid
          b(i, j+1, r2) = tempr - tempi
          bd(i, q-j-1, r2) = -temprd - tempid
          b(i, q-j-1, r2) = -tempr - tempi
        END DO
        IF (MOD(q2, 2) .EQ. 1) THEN
          temprd = bd(i, q2, r2)
          tempr = b(i, q2, r2)
          tempid = bd(i, q2+1, r2)
          tempi = b(i, q2+1, r2)
          bd(i, q2, r2) = tempid - temprd
          b(i, q2, r2) = tempi - tempr
          bd(i, q2+1, r2) = temprd + tempid
          b(i, q2+1, r2) = tempr + tempi
        END IF
      END IF
    END DO
  END IF
  RETURN
END SUBROUTINE C06FQR_D

!  Differentiation of c06fqs in forward (tangent) mode:
!   variations   of useful results: b
!   with respect to varying inputs: a b
SUBROUTINE C06FQS_D(a, ad, b, bd, p, r, cosine, sine)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     MARK 14 REVISED. IER-699 (DEC 1989).
!
!     Radix six Hermitian to real fast Fourier transform kernel
!
!     Self-sorting, decimation in frequency
!
!     .. Parameters ..
  DOUBLE PRECISION :: sin60
  PARAMETER (sin60=0.866025403784438646763723170752936d0)
!     .. Scalar Arguments ..
  INTEGER :: p, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:r-1, 0:5), b(0:p-1, 0:5, 0:r-1), cosine&
& (0:r-1, 5), sine(0:r-1, 5)
  DOUBLE PRECISION :: ad(0:p-1, 0:r-1, 0:5), bd(0:p-1, 0:5, 0:r-1)
!     .. Local Scalars ..
  DOUBLE PRECISION :: c2k, c3k, c4k, c5k, ck, s2k, s3k, s4k, s5k, sk, t1&
& , t1i, t1r, t2, t2i, t2r, t3, t3i, t3r, t4, t5, t6, u0, u0i, u0r, u1, &
& u1i, u1r, u2, u2i, u2r, v0, v0i, v0r, v1, v1i, v1r, v2, v2i, v2r, x0p&
& , x1p, x2p, x3p, x4p, x5p, y0p, y1p, y2p, y3p, y4p, y5p
  DOUBLE PRECISION :: t1d, t1id, t1rd, t2d, t2id, t2rd, t3d, t3id, t3rd&
& , t4d, t5d, t6d, u0d, u0id, u0rd, u1d, u1id, u1rd, u2d, u2id, u2rd, &
& v0d, v0id, v0rd, v1d, v1id, v1rd, v2d, v2id, v2rd, x0pd, x1pd, x2pd, &
& x3pd, x4pd, x5pd, y0pd, y1pd, y2pd, y3pd, y4pd, y5pd
  INTEGER :: i, k, kp, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
!     .. Executable Statements ..
  DO i=0,p-1
!
!        Code for K=0 --
!
    t1d = ad(i, 0, 2)
    t1 = a(i, 0, 2)
    t2d = ad(i, 0, 0) - 0.5d0*t1d
    t2 = a(i, 0, 0) - 0.5d0*t1
    t3d = sin60*ad(i, 0, 4)
    t3 = sin60*a(i, 0, 4)
    u0d = ad(i, 0, 0) + t1d
    u0 = a(i, 0, 0) + t1
    u1d = t2d + t3d
    u1 = t2 + t3
    u2d = t2d - t3d
    u2 = t2 - t3
    t1d = ad(i, 0, 1)
    t1 = a(i, 0, 1)
    t2d = ad(i, 0, 3) - 0.5d0*t1d
    t2 = a(i, 0, 3) - 0.5d0*t1
    t3d = -(sin60*ad(i, 0, 5))
    t3 = -(sin60*a(i, 0, 5))
    v0d = ad(i, 0, 3) + t1d
    v0 = a(i, 0, 3) + t1
    v1d = t2d + t3d
    v1 = t2 + t3
    v2d = t2d - t3d
    v2 = t2 - t3
    bd(i, 0, 0) = u0d + v0d
    b(i, 0, 0) = u0 + v0
    bd(i, 1, 0) = u1d - v1d
    b(i, 1, 0) = u1 - v1
    bd(i, 2, 0) = u2d + v2d
    b(i, 2, 0) = u2 + v2
    bd(i, 3, 0) = u0d - v0d
    b(i, 3, 0) = u0 - v0
    bd(i, 4, 0) = u1d + v1d
    b(i, 4, 0) = u1 + v1
    bd(i, 5, 0) = u2d - v2d
    b(i, 5, 0) = u2 - v2
  END DO
!
!     Code for general K --
!
  IF (p .LE. (r-1)/2) THEN
    DO i=0,p-1
!DIR$ IVDEP
      DO k=1,(r-1)/2
        t1rd = ad(i, k, 2) + ad(i, r-k, 1)
        t1r = a(i, k, 2) + a(i, r-k, 1)
        t1id = ad(i, r-k, 3) - ad(i, k, 4)
        t1i = a(i, r-k, 3) - a(i, k, 4)
        t2rd = ad(i, k, 0) - 0.5d0*t1rd
        t2r = a(i, k, 0) - 0.5d0*t1r
        t2id = ad(i, r-k, 5) - 0.5d0*t1id
        t2i = a(i, r-k, 5) - 0.5d0*t1i
        t3rd = sin60*(ad(i, k, 2)-ad(i, r-k, 1))
        t3r = sin60*(a(i, k, 2)-a(i, r-k, 1))
        t3id = sin60*(ad(i, r-k, 3)+ad(i, k, 4))
        t3i = sin60*(a(i, r-k, 3)+a(i, k, 4))
        u0rd = ad(i, k, 0) + t1rd
        u0r = a(i, k, 0) + t1r
        u0id = ad(i, r-k, 5) + t1id
        u0i = a(i, r-k, 5) + t1i
        u1rd = t2rd + t3id
        u1r = t2r + t3i
        u1id = t2id - t3rd
        u1i = t2i - t3r
        u2rd = t2rd - t3id
        u2r = t2r - t3i
        u2id = t2id + t3rd
        u2i = t2i + t3r
        t1rd = ad(i, r-k, 0) + ad(i, k, 1)
        t1r = a(i, r-k, 0) + a(i, k, 1)
        t1id = ad(i, r-k, 4) - ad(i, k, 5)
        t1i = -a(i, k, 5) + a(i, r-k, 4)
        t2rd = ad(i, r-k, 2) - 0.5d0*t1rd
        t2r = a(i, r-k, 2) - 0.5d0*t1r
        t2id = -ad(i, k, 3) - 0.5d0*t1id
        t2i = -a(i, k, 3) - 0.5d0*t1i
        t3rd = sin60*(ad(i, r-k, 0)-ad(i, k, 1))
        t3r = sin60*(a(i, r-k, 0)-a(i, k, 1))
        t3id = sin60*(-ad(i, k, 5)-ad(i, r-k, 4))
        t3i = sin60*(-a(i, k, 5)-a(i, r-k, 4))
        v0rd = ad(i, r-k, 2) + t1rd
        v0r = a(i, r-k, 2) + t1r
        v0id = t1id - ad(i, k, 3)
        v0i = -a(i, k, 3) + t1i
        v1rd = t2rd + t3id
        v1r = t2r + t3i
        v1id = t2id - t3rd
        v1i = t2i - t3r
        v2rd = t2rd - t3id
        v2r = t2r - t3i
        v2id = t2id + t3rd
        v2i = t2i + t3r
        x0pd = u0rd + v0rd
        x0p = u0r + v0r
        y0pd = u0id + v0id
        y0p = u0i + v0i
        x1pd = u1rd - v1rd
        x1p = u1r - v1r
        y1pd = u1id - v1id
        y1p = u1i - v1i
        x2pd = u2rd + v2rd
        x2p = u2r + v2r
        y2pd = u2id + v2id
        y2p = u2i + v2i
        x3pd = u0rd - v0rd
        x3p = u0r - v0r
        y3pd = u0id - v0id
        y3p = u0i - v0i
        x4pd = u1rd + v1rd
        x4p = u1r + v1r
        y4pd = u1id + v1id
        y4p = u1i + v1i
        x5pd = u2rd - v2rd
        x5p = u2r - v2r
        y5pd = u2id - v2id
        y5p = u2i - v2i
        bd(i, 0, k) = x0pd
        b(i, 0, k) = x0p
        bd(i, 0, r-k) = y0pd
        b(i, 0, r-k) = y0p
        bd(i, 1, k) = cosine(k, 1)*x1pd - sine(k, 1)*y1pd
        b(i, 1, k) = cosine(k, 1)*x1p - sine(k, 1)*y1p
        bd(i, 1, r-k) = cosine(k, 1)*y1pd + sine(k, 1)*x1pd
        b(i, 1, r-k) = cosine(k, 1)*y1p + sine(k, 1)*x1p
        bd(i, 2, k) = cosine(k, 2)*x2pd - sine(k, 2)*y2pd
        b(i, 2, k) = cosine(k, 2)*x2p - sine(k, 2)*y2p
        bd(i, 2, r-k) = cosine(k, 2)*y2pd + sine(k, 2)*x2pd
        b(i, 2, r-k) = cosine(k, 2)*y2p + sine(k, 2)*x2p
        bd(i, 3, k) = cosine(k, 3)*x3pd - sine(k, 3)*y3pd
        b(i, 3, k) = cosine(k, 3)*x3p - sine(k, 3)*y3p
        bd(i, 3, r-k) = cosine(k, 3)*y3pd + sine(k, 3)*x3pd
        b(i, 3, r-k) = cosine(k, 3)*y3p + sine(k, 3)*x3p
        bd(i, 4, k) = cosine(k, 4)*x4pd - sine(k, 4)*y4pd
        b(i, 4, k) = cosine(k, 4)*x4p - sine(k, 4)*y4p
        bd(i, 4, r-k) = cosine(k, 4)*y4pd + sine(k, 4)*x4pd
        b(i, 4, r-k) = cosine(k, 4)*y4p + sine(k, 4)*x4p
        bd(i, 5, k) = cosine(k, 5)*x5pd - sine(k, 5)*y5pd
        b(i, 5, k) = cosine(k, 5)*x5p - sine(k, 5)*y5p
        bd(i, 5, r-k) = cosine(k, 5)*y5pd + sine(k, 5)*x5pd
        b(i, 5, r-k) = cosine(k, 5)*y5p + sine(k, 5)*x5p
      END DO
    END DO
  ELSE
    DO k=1,(r-1)/2
      kp = r - k
      ck = cosine(k, 1)
      sk = sine(k, 1)
      c2k = cosine(k, 2)
      s2k = sine(k, 2)
      c3k = cosine(k, 3)
      s3k = sine(k, 3)
      c4k = cosine(k, 4)
      s4k = sine(k, 4)
      c5k = cosine(k, 5)
      s5k = sine(k, 5)
      DO i=0,p-1
        t1rd = ad(i, k, 2) + ad(i, kp, 1)
        t1r = a(i, k, 2) + a(i, kp, 1)
        t1id = ad(i, kp, 3) - ad(i, k, 4)
        t1i = a(i, kp, 3) - a(i, k, 4)
        t2rd = ad(i, k, 0) - 0.5d0*t1rd
        t2r = a(i, k, 0) - 0.5d0*t1r
        t2id = ad(i, kp, 5) - 0.5d0*t1id
        t2i = a(i, kp, 5) - 0.5d0*t1i
        t3rd = sin60*(ad(i, k, 2)-ad(i, kp, 1))
        t3r = sin60*(a(i, k, 2)-a(i, kp, 1))
        t3id = sin60*(ad(i, kp, 3)+ad(i, k, 4))
        t3i = sin60*(a(i, kp, 3)+a(i, k, 4))
        u0rd = ad(i, k, 0) + t1rd
        u0r = a(i, k, 0) + t1r
        u0id = ad(i, kp, 5) + t1id
        u0i = a(i, kp, 5) + t1i
        u1rd = t2rd + t3id
        u1r = t2r + t3i
        u1id = t2id - t3rd
        u1i = t2i - t3r
        u2rd = t2rd - t3id
        u2r = t2r - t3i
        u2id = t2id + t3rd
        u2i = t2i + t3r
        t1rd = ad(i, kp, 0) + ad(i, k, 1)
        t1r = a(i, kp, 0) + a(i, k, 1)
        t1id = ad(i, kp, 4) - ad(i, k, 5)
        t1i = -a(i, k, 5) + a(i, kp, 4)
        t2rd = ad(i, kp, 2) - 0.5d0*t1rd
        t2r = a(i, kp, 2) - 0.5d0*t1r
        t2id = -ad(i, k, 3) - 0.5d0*t1id
        t2i = -a(i, k, 3) - 0.5d0*t1i
        t3rd = sin60*(ad(i, kp, 0)-ad(i, k, 1))
        t3r = sin60*(a(i, kp, 0)-a(i, k, 1))
        t3id = sin60*(-ad(i, k, 5)-ad(i, kp, 4))
        t3i = sin60*(-a(i, k, 5)-a(i, kp, 4))
        v0rd = ad(i, kp, 2) + t1rd
        v0r = a(i, kp, 2) + t1r
        v0id = t1id - ad(i, k, 3)
        v0i = -a(i, k, 3) + t1i
        v1rd = t2rd + t3id
        v1r = t2r + t3i
        v1id = t2id - t3rd
        v1i = t2i - t3r
        v2rd = t2rd - t3id
        v2r = t2r - t3i
        v2id = t2id + t3rd
        v2i = t2i + t3r
        x0pd = u0rd + v0rd
        x0p = u0r + v0r
        y0pd = u0id + v0id
        y0p = u0i + v0i
        x1pd = u1rd - v1rd
        x1p = u1r - v1r
        y1pd = u1id - v1id
        y1p = u1i - v1i
        x2pd = u2rd + v2rd
        x2p = u2r + v2r
        y2pd = u2id + v2id
        y2p = u2i + v2i
        x3pd = u0rd - v0rd
        x3p = u0r - v0r
        y3pd = u0id - v0id
        y3p = u0i - v0i
        x4pd = u1rd + v1rd
        x4p = u1r + v1r
        y4pd = u1id + v1id
        y4p = u1i + v1i
        x5pd = u2rd - v2rd
        x5p = u2r - v2r
        y5pd = u2id - v2id
        y5p = u2i - v2i
        bd(i, 0, k) = x0pd
        b(i, 0, k) = x0p
        bd(i, 0, kp) = y0pd
        b(i, 0, kp) = y0p
        bd(i, 1, k) = ck*x1pd - sk*y1pd
        b(i, 1, k) = ck*x1p - sk*y1p
        bd(i, 1, kp) = ck*y1pd + sk*x1pd
        b(i, 1, kp) = ck*y1p + sk*x1p
        bd(i, 2, k) = c2k*x2pd - s2k*y2pd
        b(i, 2, k) = c2k*x2p - s2k*y2p
        bd(i, 2, kp) = c2k*y2pd + s2k*x2pd
        b(i, 2, kp) = c2k*y2p + s2k*x2p
        bd(i, 3, k) = c3k*x3pd - s3k*y3pd
        b(i, 3, k) = c3k*x3p - s3k*y3p
        bd(i, 3, kp) = c3k*y3pd + s3k*x3pd
        b(i, 3, kp) = c3k*y3p + s3k*x3p
        bd(i, 4, k) = c4k*x4pd - s4k*y4pd
        b(i, 4, k) = c4k*x4p - s4k*y4p
        bd(i, 4, kp) = c4k*y4pd + s4k*x4pd
        b(i, 4, kp) = c4k*y4p + s4k*x4p
        bd(i, 5, k) = c5k*x5pd - s5k*y5pd
        b(i, 5, k) = c5k*x5p - s5k*y5p
        bd(i, 5, kp) = c5k*y5pd + s5k*x5pd
        b(i, 5, kp) = c5k*y5p + s5k*x5p
      END DO
    END DO
  END IF
!
!     Code for K=R/2 when R is even --
!
  IF (MOD(r, 2) .EQ. 0) THEN
    r2 = r/2
    DO i=0,p-1
      t1d = ad(i, r2, 0) + ad(i, r2, 2)
      t1 = a(i, r2, 0) + a(i, r2, 2)
      t2d = ad(i, r2, 5) + ad(i, r2, 3)
      t2 = a(i, r2, 5) + a(i, r2, 3)
      t3d = ad(i, r2, 1) - 0.5d0*t1d
      t3 = a(i, r2, 1) - 0.5d0*t1
      t4d = ad(i, r2, 4) + 0.5d0*t2d
      t4 = a(i, r2, 4) + 0.5d0*t2
      t5d = sin60*(ad(i, r2, 0)-ad(i, r2, 2))
      t5 = sin60*(a(i, r2, 0)-a(i, r2, 2))
      t6d = sin60*(ad(i, r2, 5)-ad(i, r2, 3))
      t6 = sin60*(a(i, r2, 5)-a(i, r2, 3))
      bd(i, 0, r2) = ad(i, r2, 1) + t1d
      b(i, 0, r2) = a(i, r2, 1) + t1
      bd(i, 1, r2) = t4d + t5d
      b(i, 1, r2) = t4 + t5
      bd(i, 2, r2) = t6d - t3d
      b(i, 2, r2) = t6 - t3
      bd(i, 3, r2) = t2d - ad(i, r2, 4)
      b(i, 3, r2) = t2 - a(i, r2, 4)
      bd(i, 4, r2) = t3d + t6d
      b(i, 4, r2) = t3 + t6
      bd(i, 5, r2) = t4d - t5d
      b(i, 5, r2) = t4 - t5
    END DO
  END IF
!
  RETURN
END SUBROUTINE C06FQS_D

!  Differentiation of c06fqt in forward (tangent) mode:
!   variations   of useful results: b
!   with respect to varying inputs: a b
SUBROUTINE C06FQT_D(a, ad, b, bd, p, r, cosine, sine)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     MARK 14 REVISED. IER-700 (DEC 1989).
!
!     Radix five Hermitian to real fast Fourier transform kernel
!
!     Self-sorting, decimation in frequency
!
!     .. Parameters ..
  DOUBLE PRECISION :: r54, sin36, sin72, s36s72
  PARAMETER (r54=0.559016994374947424102293417182819d0, sin36=&
&   0.587785252292473129168705954639073d0, sin72=&
&   0.951056516295153572116439333379382d0, s36s72=&
&   0.618033988749894848204586834365638d0)
!     .. Scalar Arguments ..
  INTEGER :: p, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:r-1, 0:4), b(0:p-1, 0:4, 0:r-1), cosine&
& (0:r-1, 4), sine(0:r-1, 4)
  DOUBLE PRECISION :: ad(0:p-1, 0:r-1, 0:4), bd(0:p-1, 0:4, 0:r-1)
!     .. Local Scalars ..
  DOUBLE PRECISION :: c2k, c3k, c4k, ck, s2k, s3k, s4k, sk, t1, t10, &
& t10i, t10r, t11, t11i, t11r, t1i, t1r, t2, t2i, t2r, t3, t3i, t3r, t4&
& , t4i, t4r, t5, t5i, t5r, t6, t6i, t6r, t7, t7i, t7r, t8, t8i, t8r, t9&
& , t9i, t9r, x0p, x1p, x2p, x3p, x4p, y0p, y1p, y2p, y3p, y4p
  DOUBLE PRECISION :: t1d, t10d, t10id, t10rd, t11d, t11id, t11rd, t1id&
& , t1rd, t2d, t2id, t2rd, t3d, t3id, t3rd, t4d, t4id, t4rd, t5d, t5id, &
& t5rd, t6d, t6id, t6rd, t7d, t7id, t7rd, t8d, t8id, t8rd, t9d, t9id, &
& t9rd, x0pd, x1pd, x2pd, x3pd, x4pd, y0pd, y1pd, y2pd, y3pd, y4pd
  INTEGER :: i, k, kp, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
!     .. Executable Statements ..
  DO i=0,p-1
!
!        Code for K=0 --
!
    t1d = ad(i, 0, 1)
    t1 = a(i, 0, 1)
    t2d = ad(i, 0, 2)
    t2 = a(i, 0, 2)
    t3d = sin72*ad(i, 0, 4)
    t3 = sin72*a(i, 0, 4)
    t4d = sin72*ad(i, 0, 3)
    t4 = sin72*a(i, 0, 3)
    t5d = t1d + t2d
    t5 = t1 + t2
    t6d = r54*(t1d-t2d)
    t6 = r54*(t1-t2)
    t7d = ad(i, 0, 0) - 0.25d0*t5d
    t7 = a(i, 0, 0) - 0.25d0*t5
    t8d = t7d + t6d
    t8 = t7 + t6
    t9d = t7d - t6d
    t9 = t7 - t6
    t10d = t3d + s36s72*t4d
    t10 = t3 + s36s72*t4
    t11d = s36s72*t3d - t4d
    t11 = s36s72*t3 - t4
    bd(i, 0, 0) = ad(i, 0, 0) + t5d
    b(i, 0, 0) = a(i, 0, 0) + t5
    bd(i, 1, 0) = t8d + t10d
    b(i, 1, 0) = t8 + t10
    bd(i, 2, 0) = t9d + t11d
    b(i, 2, 0) = t9 + t11
    bd(i, 3, 0) = t9d - t11d
    b(i, 3, 0) = t9 - t11
    bd(i, 4, 0) = t8d - t10d
    b(i, 4, 0) = t8 - t10
  END DO
!
!     Code for general K --
!
  IF (p .LE. (r-1)/2) THEN
    DO i=0,p-1
!DIR$ IVDEP
      DO k=1,(r-1)/2
        t1rd = ad(i, k, 1) + ad(i, r-k, 0)
        t1r = a(i, k, 1) + a(i, r-k, 0)
        t1id = ad(i, r-k, 3) - ad(i, k, 4)
        t1i = a(i, r-k, 3) - a(i, k, 4)
        t2rd = ad(i, k, 2) + ad(i, r-k, 1)
        t2r = a(i, k, 2) + a(i, r-k, 1)
        t2id = ad(i, r-k, 2) - ad(i, k, 3)
        t2i = a(i, r-k, 2) - a(i, k, 3)
        t3rd = sin72*(ad(i, k, 1)-ad(i, r-k, 0))
        t3r = sin72*(a(i, k, 1)-a(i, r-k, 0))
        t3id = sin72*(ad(i, r-k, 3)+ad(i, k, 4))
        t3i = sin72*(a(i, r-k, 3)+a(i, k, 4))
        t4rd = sin72*(ad(i, k, 2)-ad(i, r-k, 1))
        t4r = sin72*(a(i, k, 2)-a(i, r-k, 1))
        t4id = sin72*(ad(i, r-k, 2)+ad(i, k, 3))
        t4i = sin72*(a(i, r-k, 2)+a(i, k, 3))
        t5rd = t1rd + t2rd
        t5r = t1r + t2r
        t5id = t1id + t2id
        t5i = t1i + t2i
        t6rd = r54*(t1rd-t2rd)
        t6r = r54*(t1r-t2r)
        t6id = r54*(t1id-t2id)
        t6i = r54*(t1i-t2i)
        t7rd = ad(i, k, 0) - 0.25d0*t5rd
        t7r = a(i, k, 0) - 0.25d0*t5r
        t7id = ad(i, r-k, 4) - 0.25d0*t5id
        t7i = a(i, r-k, 4) - 0.25d0*t5i
        t8rd = t7rd + t6rd
        t8r = t7r + t6r
        t8id = t7id + t6id
        t8i = t7i + t6i
        t9rd = t7rd - t6rd
        t9r = t7r - t6r
        t9id = t7id - t6id
        t9i = t7i - t6i
        t10rd = t3rd + s36s72*t4rd
        t10r = t3r + s36s72*t4r
        t10id = t3id + s36s72*t4id
        t10i = t3i + s36s72*t4i
        t11rd = s36s72*t3rd - t4rd
        t11r = s36s72*t3r - t4r
        t11id = s36s72*t3id - t4id
        t11i = s36s72*t3i - t4i
        x0pd = ad(i, k, 0) + t5rd
        x0p = a(i, k, 0) + t5r
        y0pd = ad(i, r-k, 4) + t5id
        y0p = a(i, r-k, 4) + t5i
        x1pd = t8rd + t10id
        x1p = t8r + t10i
        y1pd = t8id - t10rd
        y1p = t8i - t10r
        x2pd = t9rd + t11id
        x2p = t9r + t11i
        y2pd = t9id - t11rd
        y2p = t9i - t11r
        x3pd = t9rd - t11id
        x3p = t9r - t11i
        y3pd = t9id + t11rd
        y3p = t9i + t11r
        x4pd = t8rd - t10id
        x4p = t8r - t10i
        y4pd = t8id + t10rd
        y4p = t8i + t10r
        bd(i, 0, k) = x0pd
        b(i, 0, k) = x0p
        bd(i, 0, r-k) = y0pd
        b(i, 0, r-k) = y0p
        bd(i, 1, k) = cosine(k, 1)*x1pd - sine(k, 1)*y1pd
        b(i, 1, k) = cosine(k, 1)*x1p - sine(k, 1)*y1p
        bd(i, 1, r-k) = cosine(k, 1)*y1pd + sine(k, 1)*x1pd
        b(i, 1, r-k) = cosine(k, 1)*y1p + sine(k, 1)*x1p
        bd(i, 2, k) = cosine(k, 2)*x2pd - sine(k, 2)*y2pd
        b(i, 2, k) = cosine(k, 2)*x2p - sine(k, 2)*y2p
        bd(i, 2, r-k) = cosine(k, 2)*y2pd + sine(k, 2)*x2pd
        b(i, 2, r-k) = cosine(k, 2)*y2p + sine(k, 2)*x2p
        bd(i, 3, k) = cosine(k, 3)*x3pd - sine(k, 3)*y3pd
        b(i, 3, k) = cosine(k, 3)*x3p - sine(k, 3)*y3p
        bd(i, 3, r-k) = cosine(k, 3)*y3pd + sine(k, 3)*x3pd
        b(i, 3, r-k) = cosine(k, 3)*y3p + sine(k, 3)*x3p
        bd(i, 4, k) = cosine(k, 4)*x4pd - sine(k, 4)*y4pd
        b(i, 4, k) = cosine(k, 4)*x4p - sine(k, 4)*y4p
        bd(i, 4, r-k) = cosine(k, 4)*y4pd + sine(k, 4)*x4pd
        b(i, 4, r-k) = cosine(k, 4)*y4p + sine(k, 4)*x4p
      END DO
    END DO
  ELSE
    DO k=1,(r-1)/2
      kp = r - k
      ck = cosine(k, 1)
      sk = sine(k, 1)
      c2k = cosine(k, 2)
      s2k = sine(k, 2)
      c3k = cosine(k, 3)
      s3k = sine(k, 3)
      c4k = cosine(k, 4)
      s4k = sine(k, 4)
      DO i=0,p-1
        t1rd = ad(i, k, 1) + ad(i, kp, 0)
        t1r = a(i, k, 1) + a(i, kp, 0)
        t1id = ad(i, kp, 3) - ad(i, k, 4)
        t1i = a(i, kp, 3) - a(i, k, 4)
        t2rd = ad(i, k, 2) + ad(i, kp, 1)
        t2r = a(i, k, 2) + a(i, kp, 1)
        t2id = ad(i, kp, 2) - ad(i, k, 3)
        t2i = a(i, kp, 2) - a(i, k, 3)
        t3rd = sin72*(ad(i, k, 1)-ad(i, kp, 0))
        t3r = sin72*(a(i, k, 1)-a(i, kp, 0))
        t3id = sin72*(ad(i, kp, 3)+ad(i, k, 4))
        t3i = sin72*(a(i, kp, 3)+a(i, k, 4))
        t4rd = sin72*(ad(i, k, 2)-ad(i, kp, 1))
        t4r = sin72*(a(i, k, 2)-a(i, kp, 1))
        t4id = sin72*(ad(i, kp, 2)+ad(i, k, 3))
        t4i = sin72*(a(i, kp, 2)+a(i, k, 3))
        t5rd = t1rd + t2rd
        t5r = t1r + t2r
        t5id = t1id + t2id
        t5i = t1i + t2i
        t6rd = r54*(t1rd-t2rd)
        t6r = r54*(t1r-t2r)
        t6id = r54*(t1id-t2id)
        t6i = r54*(t1i-t2i)
        t7rd = ad(i, k, 0) - 0.25d0*t5rd
        t7r = a(i, k, 0) - 0.25d0*t5r
        t7id = ad(i, kp, 4) - 0.25d0*t5id
        t7i = a(i, kp, 4) - 0.25d0*t5i
        t8rd = t7rd + t6rd
        t8r = t7r + t6r
        t8id = t7id + t6id
        t8i = t7i + t6i
        t9rd = t7rd - t6rd
        t9r = t7r - t6r
        t9id = t7id - t6id
        t9i = t7i - t6i
        t10rd = t3rd + s36s72*t4rd
        t10r = t3r + s36s72*t4r
        t10id = t3id + s36s72*t4id
        t10i = t3i + s36s72*t4i
        t11rd = s36s72*t3rd - t4rd
        t11r = s36s72*t3r - t4r
        t11id = s36s72*t3id - t4id
        t11i = s36s72*t3i - t4i
        x0pd = ad(i, k, 0) + t5rd
        x0p = a(i, k, 0) + t5r
        y0pd = ad(i, kp, 4) + t5id
        y0p = a(i, kp, 4) + t5i
        x1pd = t8rd + t10id
        x1p = t8r + t10i
        y1pd = t8id - t10rd
        y1p = t8i - t10r
        x2pd = t9rd + t11id
        x2p = t9r + t11i
        y2pd = t9id - t11rd
        y2p = t9i - t11r
        x3pd = t9rd - t11id
        x3p = t9r - t11i
        y3pd = t9id + t11rd
        y3p = t9i + t11r
        x4pd = t8rd - t10id
        x4p = t8r - t10i
        y4pd = t8id + t10rd
        y4p = t8i + t10r
        bd(i, 0, k) = x0pd
        b(i, 0, k) = x0p
        bd(i, 0, kp) = y0pd
        b(i, 0, kp) = y0p
        bd(i, 1, k) = ck*x1pd - sk*y1pd
        b(i, 1, k) = ck*x1p - sk*y1p
        bd(i, 1, kp) = ck*y1pd + sk*x1pd
        b(i, 1, kp) = ck*y1p + sk*x1p
        bd(i, 2, k) = c2k*x2pd - s2k*y2pd
        b(i, 2, k) = c2k*x2p - s2k*y2p
        bd(i, 2, kp) = c2k*y2pd + s2k*x2pd
        b(i, 2, kp) = c2k*y2p + s2k*x2p
        bd(i, 3, k) = c3k*x3pd - s3k*y3pd
        b(i, 3, k) = c3k*x3p - s3k*y3p
        bd(i, 3, kp) = c3k*y3pd + s3k*x3pd
        b(i, 3, kp) = c3k*y3p + s3k*x3p
        bd(i, 4, k) = c4k*x4pd - s4k*y4pd
        b(i, 4, k) = c4k*x4p - s4k*y4p
        bd(i, 4, kp) = c4k*y4pd + s4k*x4pd
        b(i, 4, kp) = c4k*y4p + s4k*x4p
      END DO
    END DO
  END IF
!
!     Code for K=R/2 when R is even not needed
!
!     IF (MOD(R,2).EQ.0) THEN
!        R2 = R/2
!        DO 120 I = 0, P - 1
!           T1 = A(I,R2,0) + A(I,R2,1)
!           T2 = 0.25D0*T1 - A(I,R2,2)
!           T3 = R54*(A(I,R2,0)-A(I,R2,1))
!           T4 = SIN36*A(I,R2,4) + SIN72*A(I,R2,3)
!           T5 = SIN72*A(I,R2,4) - SIN36*A(I,R2,3)
!           T6 = T2 + T3
!           T7 = T2 - T3
!           B(I,0,R2) = T1 + A(I,R2,2)
!           B(I,1,R2) = T4 + T6
!           B(I,2,R2) = T5 - T7
!           B(I,3,R2) = T5 + T7
!           B(I,4,R2) = T4 - T6
! 120    CONTINUE
!     END IF
!
  RETURN
END SUBROUTINE C06FQT_D

!  Differentiation of c06fqu in forward (tangent) mode:
!   variations   of useful results: b
!   with respect to varying inputs: a b
SUBROUTINE C06FQU_D(a, ad, b, bd, p, r, cosine, sine)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     MARK 14 REVISED. IER-701 (DEC 1989).
!
!     Radix four Hermitian to real fast Fourier transform kernel
!
!     Self-sorting, decimation in frequency
!
!     .. Parameters ..
  DOUBLE PRECISION :: root2i
  PARAMETER (root2i=0.707106781186547524400844362104849d0)
!     .. Scalar Arguments ..
  INTEGER :: p, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:r-1, 0:3), b(0:p-1, 0:3, 0:r-1), cosine&
& (0:r-1, 3), sine(0:r-1, 3)
  DOUBLE PRECISION :: ad(0:p-1, 0:r-1, 0:3), bd(0:p-1, 0:3, 0:r-1)
!     .. Local Scalars ..
  DOUBLE PRECISION :: c2k, c3k, ck, s2k, s3k, sk, t1, t1i, t1r, t2, t2i&
& , t2r, t3, t3i, t3r, t4, t4i, t4r, x0p, x1p, x2p, x3p, y0p, y1p, y2p, &
& y3p
  DOUBLE PRECISION :: t1d, t1id, t1rd, t2d, t2id, t2rd, t3d, t3id, t3rd&
& , t4d, t4id, t4rd, x0pd, x1pd, x2pd, x3pd, y0pd, y1pd, y2pd, y3pd
  INTEGER :: i, k, kp, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
!     .. Executable Statements ..
  DO i=0,p-1
!
!        Code for K=0 --
!
    t1d = ad(i, 0, 0) + ad(i, 0, 2)
    t1 = a(i, 0, 0) + a(i, 0, 2)
    t2d = ad(i, 0, 1)
    t2 = a(i, 0, 1)
    t3d = ad(i, 0, 0) - ad(i, 0, 2)
    t3 = a(i, 0, 0) - a(i, 0, 2)
    t4d = ad(i, 0, 3)
    t4 = a(i, 0, 3)
    bd(i, 0, 0) = t1d + t2d
    b(i, 0, 0) = t1 + t2
    bd(i, 1, 0) = t3d + t4d
    b(i, 1, 0) = t3 + t4
    bd(i, 2, 0) = t1d - t2d
    b(i, 2, 0) = t1 - t2
    bd(i, 3, 0) = t3d - t4d
    b(i, 3, 0) = t3 - t4
  END DO
!
!     Code for general K --
!
  IF (p .LT. (r-1)/2) THEN
    DO i=0,p-1
!DIR$ IVDEP
      DO k=1,(r-1)/2
        t1rd = ad(i, k, 0) + ad(i, r-k, 1)
        t1r = a(i, k, 0) + a(i, r-k, 1)
        t1id = ad(i, r-k, 3) - ad(i, k, 2)
        t1i = a(i, r-k, 3) - a(i, k, 2)
        t2rd = ad(i, k, 1) + ad(i, r-k, 0)
        t2r = a(i, k, 1) + a(i, r-k, 0)
        t2id = ad(i, r-k, 2) - ad(i, k, 3)
        t2i = a(i, r-k, 2) - a(i, k, 3)
        t3rd = ad(i, k, 0) - ad(i, r-k, 1)
        t3r = a(i, k, 0) - a(i, r-k, 1)
        t3id = ad(i, r-k, 3) + ad(i, k, 2)
        t3i = a(i, r-k, 3) + a(i, k, 2)
        t4rd = ad(i, k, 1) - ad(i, r-k, 0)
        t4r = a(i, k, 1) - a(i, r-k, 0)
        t4id = ad(i, r-k, 2) + ad(i, k, 3)
        t4i = a(i, r-k, 2) + a(i, k, 3)
        x0pd = t1rd + t2rd
        x0p = t1r + t2r
        y0pd = t1id + t2id
        y0p = t1i + t2i
        x1pd = t3rd + t4id
        x1p = t3r + t4i
        y1pd = t3id - t4rd
        y1p = t3i - t4r
        x2pd = t1rd - t2rd
        x2p = t1r - t2r
        y2pd = t1id - t2id
        y2p = t1i - t2i
        x3pd = t3rd - t4id
        x3p = t3r - t4i
        y3pd = t3id + t4rd
        y3p = t3i + t4r
        bd(i, 0, k) = x0pd
        b(i, 0, k) = x0p
        bd(i, 0, r-k) = y0pd
        b(i, 0, r-k) = y0p
        bd(i, 1, k) = cosine(k, 1)*x1pd - sine(k, 1)*y1pd
        b(i, 1, k) = cosine(k, 1)*x1p - sine(k, 1)*y1p
        bd(i, 1, r-k) = cosine(k, 1)*y1pd + sine(k, 1)*x1pd
        b(i, 1, r-k) = cosine(k, 1)*y1p + sine(k, 1)*x1p
        bd(i, 2, k) = cosine(k, 2)*x2pd - sine(k, 2)*y2pd
        b(i, 2, k) = cosine(k, 2)*x2p - sine(k, 2)*y2p
        bd(i, 2, r-k) = cosine(k, 2)*y2pd + sine(k, 2)*x2pd
        b(i, 2, r-k) = cosine(k, 2)*y2p + sine(k, 2)*x2p
        bd(i, 3, k) = cosine(k, 3)*x3pd - sine(k, 3)*y3pd
        b(i, 3, k) = cosine(k, 3)*x3p - sine(k, 3)*y3p
        bd(i, 3, r-k) = cosine(k, 3)*y3pd + sine(k, 3)*x3pd
        b(i, 3, r-k) = cosine(k, 3)*y3p + sine(k, 3)*x3p
      END DO
    END DO
  ELSE
    DO k=1,(r-1)/2
      kp = r - k
      ck = cosine(k, 1)
      sk = sine(k, 1)
      c2k = cosine(k, 2)
      s2k = sine(k, 2)
      c3k = cosine(k, 3)
      s3k = sine(k, 3)
      DO i=0,p-1
        t1rd = ad(i, k, 0) + ad(i, kp, 1)
        t1r = a(i, k, 0) + a(i, kp, 1)
        t1id = ad(i, kp, 3) - ad(i, k, 2)
        t1i = a(i, kp, 3) - a(i, k, 2)
        t2rd = ad(i, k, 1) + ad(i, kp, 0)
        t2r = a(i, k, 1) + a(i, kp, 0)
        t2id = ad(i, kp, 2) - ad(i, k, 3)
        t2i = a(i, kp, 2) - a(i, k, 3)
        t3rd = ad(i, k, 0) - ad(i, kp, 1)
        t3r = a(i, k, 0) - a(i, kp, 1)
        t3id = ad(i, kp, 3) + ad(i, k, 2)
        t3i = a(i, kp, 3) + a(i, k, 2)
        t4rd = ad(i, k, 1) - ad(i, kp, 0)
        t4r = a(i, k, 1) - a(i, kp, 0)
        t4id = ad(i, kp, 2) + ad(i, k, 3)
        t4i = a(i, kp, 2) + a(i, k, 3)
        x0pd = t1rd + t2rd
        x0p = t1r + t2r
        y0pd = t1id + t2id
        y0p = t1i + t2i
        x1pd = t3rd + t4id
        x1p = t3r + t4i
        y1pd = t3id - t4rd
        y1p = t3i - t4r
        x2pd = t1rd - t2rd
        x2p = t1r - t2r
        y2pd = t1id - t2id
        y2p = t1i - t2i
        x3pd = t3rd - t4id
        x3p = t3r - t4i
        y3pd = t3id + t4rd
        y3p = t3i + t4r
        bd(i, 0, k) = x0pd
        b(i, 0, k) = x0p
        bd(i, 0, kp) = y0pd
        b(i, 0, kp) = y0p
        bd(i, 1, k) = ck*x1pd - sk*y1pd
        b(i, 1, k) = ck*x1p - sk*y1p
        bd(i, 1, kp) = ck*y1pd + sk*x1pd
        b(i, 1, kp) = ck*y1p + sk*x1p
        bd(i, 2, k) = c2k*x2pd - s2k*y2pd
        b(i, 2, k) = c2k*x2p - s2k*y2p
        bd(i, 2, kp) = c2k*y2pd + s2k*x2pd
        b(i, 2, kp) = c2k*y2p + s2k*x2p
        bd(i, 3, k) = c3k*x3pd - s3k*y3pd
        b(i, 3, k) = c3k*x3p - s3k*y3p
        bd(i, 3, kp) = c3k*y3pd + s3k*x3pd
        b(i, 3, kp) = c3k*y3p + s3k*x3p
      END DO
    END DO
  END IF
!
!     Code for K=R/2 when R is even --
!
  IF (MOD(r, 2) .EQ. 0) THEN
    r2 = r/2
    DO i=0,p-1
      bd(i, 0, r2) = ad(i, r2, 0) + ad(i, r2, 1)
      b(i, 0, r2) = a(i, r2, 0) + a(i, r2, 1)
      bd(i, 2, r2) = ad(i, r2, 3) - ad(i, r2, 2)
      b(i, 2, r2) = a(i, r2, 3) - a(i, r2, 2)
      t3d = ad(i, r2, 0) - ad(i, r2, 1)
      t3 = a(i, r2, 0) - a(i, r2, 1)
      t4d = ad(i, r2, 3) + ad(i, r2, 2)
      t4 = a(i, r2, 3) + a(i, r2, 2)
      bd(i, 1, r2) = root2i*(t3d+t4d)
      b(i, 1, r2) = root2i*(t3+t4)
      bd(i, 3, r2) = -(root2i*(t3d-t4d))
      b(i, 3, r2) = -(root2i*(t3-t4))
    END DO
  END IF
!
  RETURN
END SUBROUTINE C06FQU_D

!  Differentiation of c06fqv in forward (tangent) mode:
!   variations   of useful results: b
!   with respect to varying inputs: a b
SUBROUTINE C06FQV_D(a, ad, b, bd, p, r, cosine, sine)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     MARK 14 REVISED. IER-702 (DEC 1989).
!
!     Radix three Hermitian to real Fourier transform kernel
!
!     Self-sorting, decimation in frequency
!
!     .. Parameters ..
  DOUBLE PRECISION :: sin60
  PARAMETER (sin60=0.866025403784438646763723170752936d0)
!     .. Scalar Arguments ..
  INTEGER :: p, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:r-1, 0:2), b(0:p-1, 0:2, 0:r-1), cosine&
& (0:r-1, 2), sine(0:r-1, 2)
  DOUBLE PRECISION :: ad(0:p-1, 0:r-1, 0:2), bd(0:p-1, 0:2, 0:r-1)
!     .. Local Scalars ..
  DOUBLE PRECISION :: c2k, ck, s2k, sk, t1, t1i, t1r, t2, t2i, t2r, t3, &
& t3i, t3r, x0p, x1p, x2p, y0p, y1p, y2p
  DOUBLE PRECISION :: t1d, t1id, t1rd, t2d, t2id, t2rd, t3d, t3id, t3rd&
& , x0pd, x1pd, x2pd, y0pd, y1pd, y2pd
  INTEGER :: i, k, kp, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
!     .. Executable Statements ..
  DO i=0,p-1
!
!        Code for K=0 --
!
    t1d = ad(i, 0, 1)
    t1 = a(i, 0, 1)
    t2d = ad(i, 0, 0) - 0.5d0*t1d
    t2 = a(i, 0, 0) - 0.5d0*t1
    t3d = sin60*ad(i, 0, 2)
    t3 = sin60*a(i, 0, 2)
    bd(i, 0, 0) = ad(i, 0, 0) + t1d
    b(i, 0, 0) = a(i, 0, 0) + t1
    bd(i, 1, 0) = t2d + t3d
    b(i, 1, 0) = t2 + t3
    bd(i, 2, 0) = t2d - t3d
    b(i, 2, 0) = t2 - t3
  END DO
!
!     Code for general K
!
  IF (p .LE. (r-1)/2) THEN
    DO i=0,p-1
!DIR$ IVDEP
      DO k=1,(r-1)/2
        t1rd = ad(i, k, 1) + ad(i, r-k, 0)
        t1r = a(i, k, 1) + a(i, r-k, 0)
        t1id = ad(i, r-k, 1) - ad(i, k, 2)
        t1i = a(i, r-k, 1) - a(i, k, 2)
        t2rd = ad(i, k, 0) - 0.5d0*t1rd
        t2r = a(i, k, 0) - 0.5d0*t1r
        t2id = ad(i, r-k, 2) - 0.5d0*t1id
        t2i = a(i, r-k, 2) - 0.5d0*t1i
        t3rd = sin60*(ad(i, k, 1)-ad(i, r-k, 0))
        t3r = sin60*(a(i, k, 1)-a(i, r-k, 0))
        t3id = sin60*(ad(i, r-k, 1)+ad(i, k, 2))
        t3i = sin60*(a(i, r-k, 1)+a(i, k, 2))
        x0pd = ad(i, k, 0) + t1rd
        x0p = a(i, k, 0) + t1r
        y0pd = ad(i, r-k, 2) + t1id
        y0p = a(i, r-k, 2) + t1i
        x1pd = t2rd + t3id
        x1p = t2r + t3i
        y1pd = t2id - t3rd
        y1p = t2i - t3r
        x2pd = t2rd - t3id
        x2p = t2r - t3i
        y2pd = t2id + t3rd
        y2p = t2i + t3r
        bd(i, 0, k) = x0pd
        b(i, 0, k) = x0p
        bd(i, 0, r-k) = y0pd
        b(i, 0, r-k) = y0p
        bd(i, 1, k) = cosine(k, 1)*x1pd - sine(k, 1)*y1pd
        b(i, 1, k) = cosine(k, 1)*x1p - sine(k, 1)*y1p
        bd(i, 1, r-k) = sine(k, 1)*x1pd + cosine(k, 1)*y1pd
        b(i, 1, r-k) = sine(k, 1)*x1p + cosine(k, 1)*y1p
        bd(i, 2, k) = cosine(k, 2)*x2pd - sine(k, 2)*y2pd
        b(i, 2, k) = cosine(k, 2)*x2p - sine(k, 2)*y2p
        bd(i, 2, r-k) = sine(k, 2)*x2pd + cosine(k, 2)*y2pd
        b(i, 2, r-k) = sine(k, 2)*x2p + cosine(k, 2)*y2p
      END DO
    END DO
  ELSE
    DO k=1,(r-1)/2
      kp = r - k
      ck = cosine(k, 1)
      sk = sine(k, 1)
      c2k = cosine(k, 2)
      s2k = sine(k, 2)
      DO i=0,p-1
        t1rd = ad(i, k, 1) + ad(i, kp, 0)
        t1r = a(i, k, 1) + a(i, kp, 0)
        t1id = ad(i, kp, 1) - ad(i, k, 2)
        t1i = a(i, kp, 1) - a(i, k, 2)
        t2rd = ad(i, k, 0) - 0.5d0*t1rd
        t2r = a(i, k, 0) - 0.5d0*t1r
        t2id = ad(i, kp, 2) - 0.5d0*t1id
        t2i = a(i, kp, 2) - 0.5d0*t1i
        t3rd = sin60*(ad(i, k, 1)-ad(i, kp, 0))
        t3r = sin60*(a(i, k, 1)-a(i, kp, 0))
        t3id = sin60*(ad(i, kp, 1)+ad(i, k, 2))
        t3i = sin60*(a(i, kp, 1)+a(i, k, 2))
        x0pd = ad(i, k, 0) + t1rd
        x0p = a(i, k, 0) + t1r
        y0pd = ad(i, kp, 2) + t1id
        y0p = a(i, kp, 2) + t1i
        x1pd = t2rd + t3id
        x1p = t2r + t3i
        y1pd = t2id - t3rd
        y1p = t2i - t3r
        x2pd = t2rd - t3id
        x2p = t2r - t3i
        y2pd = t2id + t3rd
        y2p = t2i + t3r
        bd(i, 0, k) = x0pd
        b(i, 0, k) = x0p
        bd(i, 0, kp) = y0pd
        b(i, 0, kp) = y0p
        bd(i, 1, k) = ck*x1pd - sk*y1pd
        b(i, 1, k) = ck*x1p - sk*y1p
        bd(i, 1, kp) = sk*x1pd + ck*y1pd
        b(i, 1, kp) = sk*x1p + ck*y1p
        bd(i, 2, k) = c2k*x2pd - s2k*y2pd
        b(i, 2, k) = c2k*x2p - s2k*y2p
        bd(i, 2, kp) = s2k*x2pd + c2k*y2pd
        b(i, 2, kp) = s2k*x2p + c2k*y2p
      END DO
    END DO
  END IF
!
!     Code for K=R/2 when R is even not needed
!
!     IF (MOD(R,2).EQ.0) THEN
!        R2 = R/2
!        DO 120 I = 0, P - 1
!           T1 = A(I,R2,0) + A(I,R2,1)
!           T2 = 0.5D0*A(I,R2,0) - A(I,R2,1)
!           T3 = SIN60*A(I,R2,2)
!           B(I,0,R2) = T1
!           B(I,1,R2) = T2 + T3
!           B(I,2,R2) = -T2 + T3
! 120    CONTINUE
!     END IF
!
  RETURN
END SUBROUTINE C06FQV_D

!  Differentiation of c06fqw in forward (tangent) mode:
!   variations   of useful results: b
!   with respect to varying inputs: a b
SUBROUTINE C06FQW_D(a, ad, b, bd, p, r, cosine, sine)
  IMPLICIT NONE
!VD$R VECTOR
! CVD$R NOLSTVAL
! c CVD$R STRIP
!     MARK 12 RELEASE. NAG COPYRIGHT 1986.
!     MARK 14 REVISED. IER-703 (DEC 1989).
!
!     Radix two Hermitian to real Fourier transform kernel
!
!     Self-sorting, decimation in frequency
!
!     .. Scalar Arguments ..
  INTEGER :: p, r
!     .. Array Arguments ..
  DOUBLE PRECISION :: a(0:p-1, 0:r-1, 0:1), b(0:p-1, 0:1, 0:r-1), cosine&
& (0:r-1), sine(0:r-1)
  DOUBLE PRECISION :: ad(0:p-1, 0:r-1, 0:1), bd(0:p-1, 0:1, 0:r-1)
!     .. Local Scalars ..
  DOUBLE PRECISION :: ck, sk, x1hat, y1hat
  DOUBLE PRECISION :: x1hatd, y1hatd
  INTEGER :: i, k, kp, r2
!     .. Intrinsic Functions ..
  INTRINSIC MOD
!     .. Executable Statements ..
  DO i=0,p-1
!
!        Code for K=0 --
!
    bd(i, 0, 0) = ad(i, 0, 0) + ad(i, 0, 1)
    b(i, 0, 0) = a(i, 0, 0) + a(i, 0, 1)
    bd(i, 1, 0) = ad(i, 0, 0) - ad(i, 0, 1)
    b(i, 1, 0) = a(i, 0, 0) - a(i, 0, 1)
  END DO
!
!     Code for general K --
!
  IF (p .LT. (r-1)/2) THEN
    DO i=0,p-1
!DIR$ IVDEP
      DO k=1,(r-1)/2
        x1hatd = ad(i, k, 0) - ad(i, r-k, 0)
        x1hat = a(i, k, 0) - a(i, r-k, 0)
        y1hatd = ad(i, r-k, 1) + ad(i, k, 1)
        y1hat = a(i, r-k, 1) + a(i, k, 1)
        bd(i, 0, k) = ad(i, k, 0) + ad(i, r-k, 0)
        b(i, 0, k) = a(i, k, 0) + a(i, r-k, 0)
        bd(i, 0, r-k) = ad(i, r-k, 1) - ad(i, k, 1)
        b(i, 0, r-k) = a(i, r-k, 1) - a(i, k, 1)
        bd(i, 1, k) = cosine(k)*x1hatd - sine(k)*y1hatd
        b(i, 1, k) = cosine(k)*x1hat - sine(k)*y1hat
        bd(i, 1, r-k) = cosine(k)*y1hatd + sine(k)*x1hatd
        b(i, 1, r-k) = cosine(k)*y1hat + sine(k)*x1hat
      END DO
    END DO
  ELSE
    DO k=1,(r-1)/2
      kp = r - k
      ck = cosine(k)
      sk = sine(k)
      DO i=0,p-1
        x1hatd = ad(i, k, 0) - ad(i, kp, 0)
        x1hat = a(i, k, 0) - a(i, kp, 0)
        y1hatd = ad(i, kp, 1) + ad(i, k, 1)
        y1hat = a(i, kp, 1) + a(i, k, 1)
        bd(i, 0, k) = ad(i, k, 0) + ad(i, kp, 0)
        b(i, 0, k) = a(i, k, 0) + a(i, kp, 0)
        bd(i, 0, kp) = ad(i, kp, 1) - ad(i, k, 1)
        b(i, 0, kp) = a(i, kp, 1) - a(i, k, 1)
        bd(i, 1, k) = ck*x1hatd - sk*y1hatd
        b(i, 1, k) = ck*x1hat - sk*y1hat
        bd(i, 1, kp) = ck*y1hatd + sk*x1hatd
        b(i, 1, kp) = ck*y1hat + sk*x1hat
      END DO
    END DO
  END IF
!
!     Code for K=R/2 when R is even not needed
!
!     IF (MOD(R,2).EQ.0) THEN
!        R2 = R/2
!        DO 120 I = 0, P - 1
!           B(I,0,R2) = A(I,R2,0)
!           B(I,1,R2) = A(I,R2,1)
! 120    CONTINUE
!     END IF
!
  RETURN
END SUBROUTINE C06FQW_D

MODULE TAPENADE_D
  IMPLICIT NONE
! value of pi
  REAL*8, PARAMETER :: pi=4d0*ATAN(1d0)
! The truncation is of type T(riangular) nm
  INTEGER, PARAMETER :: nm=21
! Number of longitude points of the Gaussian grid
  INTEGER, PARAMETER :: nlon=64
! Number of latitude  points of the Gaussian grid
  INTEGER, PARAMETER :: nlat=32
! Number of vorticity levels in the vertical (should be set to 3)
  INTEGER, PARAMETER :: nvl=3
! Number of temperature levels in the vertical (equal to nvl-1)
  INTEGER, PARAMETER :: ntl=2
! Half of nsh2
  INTEGER, PARAMETER :: nsh=(nm+1)*(nm+2)/2
  INTEGER, PARAMETER :: nsh2=2*nsh
! Model time step
  INTEGER, PARAMETER :: time_step=1200
  REAL*8, PARAMETER :: nsteps_per_day=24.0d0*3600.0d0/REAL(time_step)
! dimensionless time step
  REAL*8, PARAMETER :: dtt=1d0/nsteps_per_day*pi*4d0
! Model state
! Stream function at the nvl levels
  REAL*8 :: psi(nsh2, nvl)
! Thickness at the ntl levels
  REAL*8 :: psit(nsh2, ntl)
! Potential vorticity
  REAL*8 :: qprime(nsh2, nvl)
  REAL*8 :: qprimed(nsh2, nvl)
! Model Forcing
! Constant potential vorticity forcing at the nvl levels
  REAL*8, PARAMETER :: for(nsh2, nvl)
! Spectral Coefficients
! Contains numbers 22 down to 1 for index 0 to 21
  INTEGER, PARAMETER :: nshm(0:nm)
! Contains total wavenumber n of each spherical harmonic of the corresponding index
  INTEGER, PARAMETER :: ll(nsh)
  INTEGER :: lat
! Legendre polynomials defined at Gausian latitudes
  REAL*8, PARAMETER :: pp(lat, nsh)
! Mu derivative of Legendre polynomials
  REAL*8, PARAMETER :: pd(lat, nsh)
! Weights for Legendre integrals
  REAL*8, PARAMETER :: pw(lat, nsh)
! contains zonal wavenumber m of each spherical harmonic of the corresponding index for zonal derivative operator
  REAL*8, PARAMETER :: rm(:)
! Laplace/Helmholtz direct and inverse operators
! Laplace and Helmholtz operator for Q-PSI inversion
  REAL*8, PARAMETER :: rinhel(nsh2, 0:5)
! Dissipation coefficients for each spherical harmonic
  REAL*8, PARAMETER :: diss(nsh2, 2)
!   diss(k,1) : Hyperviscosity at the three levels (tdif sets timescale)
!   diss(k,2) : Ekman friction at lower level (tdis sets timescale)
! One over Rossby rad. of def. squared of 200-500 thickness
  REAL*8, PARAMETER :: rl1
! One over Rossby rad. of def. squared of 500-800 thickness
  REAL*8, PARAMETER :: rl2
! Nondimensional relaxation coefficient of 200-500 thickness
  REAL*8, PARAMETER :: relt1
! Nondimensional relaxation coefficient of 500-800 thickness
  REAL*8, PARAMETER :: relt2
! Orography
! Gauss points in radians
  REAL*8, PARAMETER :: phi(nlat)
! Sine of phi
  REAL*8, PARAMETER :: sinfi(nlat)
! Cosine of phi
  REAL*8, PARAMETER :: cosfi(nlat)
! If .true. then orography and land-sea mask dependent friction at the lower level plus Ekman friction, else only Ekman friction
  LOGICAL, PARAMETER :: lgdiss
! Derivative of orog wrt lambda
  REAL*8, PARAMETER :: dorodl(nlat, nlon)
! Derivative of orag wrt sin(fi)
  REAL*8, PARAMETER :: dorodm(nlat, nlon)
! Landsea-mask/orography dependent friction
  REAL*8, PARAMETER :: rdiss(nlat, nlon)
! Landsea-mask/orography dependent friction
  REAL*8, PARAMETER :: ddisdx(nlat, nlon)
! Landsea-mask/orography dependent friction
  REAL*8, PARAMETER :: ddisdy(nlat, nlon)
! Copy of input gaussian grid field
  REAL*8 :: agg_copy(nlat, nlon)
  REAL*8 :: agg_copyd(nlat, nlon)
! Work space used by the nag version of the fft    
  REAL*8 :: tmp(nlat, nlon)
  REAL*8 :: tmpd(nlat, nlon)

CONTAINS
!  Differentiation of adv_nsteps in forward (tangent) mode:
!   variations   of useful results: tmp qprime
!   with respect to varying inputs: tmp qprime
!   RW status of diff variables: agg_copy:(loc) tmp:in-out qprime:in-out
!-----------------------------------------------------------------------
! performs a fourth order runge kutta time step at truncation nm
! with time step dt
! dqdt calculates the time derivative
! input  qprime at current time
! output qprime at current time plus dt
!-----------------------------------------------------------------------
  SUBROUTINE ADV_NSTEPS_D(nsteps)
    IMPLICIT NONE
    INTEGER :: nsteps
    INTEGER :: step, k, l, nvar
    REAL*8 :: dt2, dt6
    REAL*8 :: y(nsh2, nvl), dydt(nsh2, nvl), yt(nsh2, nvl)
    REAL*8 :: yd(nsh2, nvl), dydtd(nsh2, nvl), ytd(nsh2, nvl)
    REAL*8 :: dyt(nsh2, nvl), dym(nsh2, nvl)
    REAL*8 :: dytd(nsh2, nvl), dymd(nsh2, nvl)
    nvar = (nm+2)*nm
    dt2 = dtt*0.5d0
    dt6 = dtt/6d0
! Advance the model forward in time n steps
    yd = FMTOFS_D(qprime, qprimed, y)
    CALL DQDT_D(y, yd, dydt, dydtd)
    ytd = 0.0_8
    DO l=1,nvl
      DO k=1,nvar
        ytd(k, l) = yd(k, l) + dt2*dydtd(k, l)
        yt(k, l) = y(k, l) + dt2*dydt(k, l)
      END DO
    END DO
    CALL DQDT_D(yt, ytd, dyt, dytd)
    DO l=1,nvl
      DO k=1,nvar
        ytd(k, l) = yd(k, l) + dt2*dytd(k, l)
        yt(k, l) = y(k, l) + dt2*dyt(k, l)
      END DO
    END DO
    CALL DQDT_D(yt, ytd, dym, dymd)
    DO l=1,nvl
      DO k=1,nvar
        ytd(k, l) = yd(k, l) + dtt*dymd(k, l)
        yt(k, l) = y(k, l) + dtt*dym(k, l)
        dymd(k, l) = dytd(k, l) + dymd(k, l)
        dym(k, l) = dyt(k, l) + dym(k, l)
      END DO
    END DO
    CALL DQDT_D(yt, ytd, dyt, dytd)
    DO l=1,nvl
      DO k=1,nvar
        yd(k, l) = yd(k, l) + dt6*(dydtd(k, l)+dytd(k, l)+2.*dymd(k, l))
        y(k, l) = y(k, l) + dt6*(dydt(k, l)+dyt(k, l)+2.*dym(k, l))
      END DO
    END DO
    qprimed = FSTOFM_D(y, yd, nm, qprime)
! Make stream function consistent with potential vorticity
    CALL QTOPSI(qprime, psi, psit)
  END SUBROUTINE ADV_NSTEPS_D
!-----------------------------------------------------------------------
! performs a fourth order runge kutta time step at truncation nm
! with time step dt
! dqdt calculates the time derivative
! input  qprime at current time
! output qprime at current time plus dt
!-----------------------------------------------------------------------
  SUBROUTINE ADV_NSTEPS(nsteps)
    IMPLICIT NONE
    INTEGER :: nsteps
    INTEGER :: step, k, l, nvar
    REAL*8 :: dt2, dt6
    REAL*8 :: y(nsh2, nvl), dydt(nsh2, nvl), yt(nsh2, nvl)
    REAL*8 :: dyt(nsh2, nvl), dym(nsh2, nvl)
    nvar = (nm+2)*nm
    dt2 = dtt*0.5d0
    dt6 = dtt/6d0
! Advance the model forward in time n steps
    y = FMTOFS(qprime)
    CALL DQDT(y, dydt)
    DO l=1,nvl
      DO k=1,nvar
        yt(k, l) = y(k, l) + dt2*dydt(k, l)
      END DO
    END DO
    CALL DQDT(yt, dyt)
    DO l=1,nvl
      DO k=1,nvar
        yt(k, l) = y(k, l) + dt2*dyt(k, l)
      END DO
    END DO
    CALL DQDT(yt, dym)
    DO l=1,nvl
      DO k=1,nvar
        yt(k, l) = y(k, l) + dtt*dym(k, l)
        dym(k, l) = dyt(k, l) + dym(k, l)
      END DO
    END DO
    CALL DQDT(yt, dyt)
    DO l=1,nvl
      DO k=1,nvar
        y(k, l) = y(k, l) + dt6*(dydt(k, l)+dyt(k, l)+2.*dym(k, l))
      END DO
    END DO
    qprime = FSTOFM(y, nm)
! Make stream function consistent with potential vorticity
    CALL QTOPSI(qprime, psi, psit)
  END SUBROUTINE ADV_NSTEPS
!  Differentiation of dqdt in forward (tangent) mode:
!   variations   of useful results: tmp dydt
!   with respect to varying inputs: tmp y
!-----------------------------------------------------------------------
! computation of time derivative of the potential vorticity field
! input  y potential vorticity in french format
! output dydt time derivative of y in french format
! values of qprime,  psi and psit are changed
!-----------------------------------------------------------------------
  SUBROUTINE DQDT_D(y, yd, dydt, dydtd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    REAL*8, INTENT(IN) :: yd(:, :)
    REAL*8, INTENT(OUT) :: dydt(:, :)
    REAL*8, INTENT(OUT) :: dydtd(:, :)
! qprime
    REAL*8 :: local_qprime(nsh2, nvl)
    REAL*8 :: local_qprimed(nsh2, nvl)
! psi
    REAL*8 :: local_psi(nsh2, nvl)
    REAL*8 :: local_psid(nsh2, nvl)
! psit
    REAL*8 :: local_psit(nsh2, ntl)
    REAL*8 :: local_psitd(nsh2, ntl)
! time derivative of qprime
    REAL*8 :: dqprdt(nsh2, nvl)
    REAL*8 :: dqprdtd(nsh2, nvl)
    local_qprimed = FSTOFM_D(y, yd, nm, local_qprime)
    CALL QTOPSI_D(local_qprime, local_qprimed, local_psi, local_psid, &
&           local_psit, local_psitd)
! psi, psit, qprime, for, diss --> dqprdt
    dqprdtd = DDT_D(local_psi, local_psid, local_psit, local_psitd, &
&     local_qprime, local_qprimed, for, dqprdt)
    dydtd = FMTOFS_D(dqprdt, dqprdtd, dydt)
    RETURN
  END SUBROUTINE DQDT_D
!-----------------------------------------------------------------------
! computation of time derivative of the potential vorticity field
! input  y potential vorticity in french format
! output dydt time derivative of y in french format
! values of qprime,  psi and psit are changed
!-----------------------------------------------------------------------
  SUBROUTINE DQDT(y, dydt)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    REAL*8, INTENT(OUT) :: dydt(:, :)
! qprime
    REAL*8 :: local_qprime(nsh2, nvl)
! psi
    REAL*8 :: local_psi(nsh2, nvl)
! psit
    REAL*8 :: local_psit(nsh2, ntl)
! time derivative of qprime
    REAL*8 :: dqprdt(nsh2, nvl)
    local_qprime = FSTOFM(y, nm)
    CALL QTOPSI(local_qprime, local_psi, local_psit)
! psi, psit, qprime, for, diss --> dqprdt
    dqprdt = DDT(local_psi, local_psit, local_qprime, for)
    dydt = FMTOFS(dqprdt)
    RETURN
  END SUBROUTINE DQDT
!  Differentiation of ddt in forward (tangent) mode:
!   variations   of useful results: tmp dqprdt
!   with respect to varying inputs: tmp psi qprime psit
!----------------------------------------------------------------------
! ddt
!
! computation of time derivative of the potential vorticity fields
!
! input qprime,  psi,  psit
! output dqprdt
!----------------------------------------------------------------------
  FUNCTION DDT_D(psi, psid, psit, psitd, qprime, qprimed, for, dqprdt) &
& RESULT (DQPRDTD)
    IMPLICIT NONE
! stream function at the nvl levels
    REAL*8, INTENT(IN) :: psi(nsh2, nvl)
    REAL*8, INTENT(IN) :: psid(nsh2, nvl)
! thickness at the ntl levels
    REAL*8, INTENT(IN) :: psit(nsh2, ntl)
    REAL*8, INTENT(IN) :: psitd(nsh2, ntl)
! potential vorticity
    REAL*8, INTENT(IN) :: qprime(nsh2, nvl)
    REAL*8, INTENT(IN) :: qprimed(nsh2, nvl)
! constant potential vorticity forcing at the nvl levels
    REAL*8, INTENT(IN) :: for(nsh2, nvl)
    REAL*8 :: dqprdt(nsh2, nvl)
    REAL*8 :: dqprdtd(nsh2, nvl)
    INTEGER :: k, l, i, j
    REAL*8 :: dum1, dum2
    REAL*8 :: dum1d, dum2d
! advection of potential vorticity at upper level
    dqprdtd = 0.0_8
    dqprdtd(:, 1) = JACOB_D(psi(:, 1), psid(:, 1), qprime(:, 1), qprimed&
&     (:, 1), dqprdt(:, 1))
! advection of potential vorticity at middle level
    dqprdtd(:, 2) = JACOB_D(psi(:, 2), psid(:, 2), qprime(:, 2), qprimed&
&     (:, 2), dqprdt(:, 2))
! advection of potential vorticity and dissipation at lower level
    dqprdtd(:, 3) = JACOBD_D(psi(:, 3), psid(:, 3), qprime(:, 3), &
&     qprimed(:, 3), dqprdt(:, 3))
! relaxation of temperature and forcing
    DO k=1,nsh2
      dum1d = relt1*psitd(k, 1)
      dum1 = relt1*psit(k, 1)
      dum2d = relt2*psitd(k, 2)
      dum2 = relt2*psit(k, 2)
      dqprdtd(k, 1) = dqprdtd(k, 1) + dum1d
      dqprdt(k, 1) = dqprdt(k, 1) + dum1 + for(k, 1)
      dqprdtd(k, 2) = dqprdtd(k, 2) - dum1d + dum2d
      dqprdt(k, 2) = dqprdt(k, 2) - dum1 + dum2 + for(k, 2)
      dqprdtd(k, 3) = dqprdtd(k, 3) - dum2d
      dqprdt(k, 3) = dqprdt(k, 3) - dum2 + for(k, 3)
    END DO
! explicit horizontal diffusion
    DO l=1,3
      DO k=1,nsh2
        dqprdtd(k, l) = dqprdtd(k, l) + diss(k, 1)*qprimed(k, l)
        dqprdt(k, l) = dqprdt(k, l) + diss(k, 1)*qprime(k, l)
      END DO
    END DO
    RETURN
  END FUNCTION DDT_D
!----------------------------------------------------------------------
! ddt
!
! computation of time derivative of the potential vorticity fields
!
! input qprime,  psi,  psit
! output dqprdt
!----------------------------------------------------------------------
  FUNCTION DDT(psi, psit, qprime, for) RESULT (DQPRDT)
    IMPLICIT NONE
! stream function at the nvl levels
    REAL*8, INTENT(IN) :: psi(nsh2, nvl)
! thickness at the ntl levels
    REAL*8, INTENT(IN) :: psit(nsh2, ntl)
! potential vorticity
    REAL*8, INTENT(IN) :: qprime(nsh2, nvl)
! constant potential vorticity forcing at the nvl levels
    REAL*8, INTENT(IN) :: for(nsh2, nvl)
    REAL*8 :: dqprdt(nsh2, nvl)
    INTEGER :: k, l, i, j
    REAL*8 :: dum1, dum2
! advection of potential vorticity at upper level
    dqprdt(:, 1) = JACOB(psi(:, 1), qprime(:, 1))
! advection of potential vorticity at middle level
    dqprdt(:, 2) = JACOB(psi(:, 2), qprime(:, 2))
! advection of potential vorticity and dissipation at lower level
    dqprdt(:, 3) = JACOBD(psi(:, 3), qprime(:, 3))
! relaxation of temperature and forcing
    DO k=1,nsh2
      dum1 = relt1*psit(k, 1)
      dum2 = relt2*psit(k, 2)
      dqprdt(k, 1) = dqprdt(k, 1) + dum1 + for(k, 1)
      dqprdt(k, 2) = dqprdt(k, 2) - dum1 + dum2 + for(k, 2)
      dqprdt(k, 3) = dqprdt(k, 3) - dum2 + for(k, 3)
    END DO
! explicit horizontal diffusion
    DO l=1,3
      DO k=1,nsh2
        dqprdt(k, l) = dqprdt(k, l) + diss(k, 1)*qprime(k, l)
      END DO
    END DO
    RETURN
  END FUNCTION DDT
!  Differentiation of jacob in forward (tangent) mode:
!   variations   of useful results: tmp sjacob
!   with respect to varying inputs: tmp psiloc pvor
!----------------------------------------------------------------------
! advection of potential vorticity
! input psiloc,  pvor
! output sjacob
!----------------------------------------------------------------------
  FUNCTION JACOB_D(psiloc, psilocd, pvor, pvord, sjacob) RESULT (SJACOBD&
& )
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: psiloc(nsh2)
    REAL*8, INTENT(IN) :: psilocd(nsh2)
    REAL*8, INTENT(IN) :: pvor(nsh2)
    REAL*8, INTENT(IN) :: pvord(nsh2)
    REAL*8 :: sjacob(nsh2)
    REAL*8 :: sjacobd(nsh2)
    INTEGER :: i, j, k
    REAL*8 :: vv(nsh2)
    REAL*8 :: vvd(nsh2)
    REAL*8 :: dpsidl(nlat, nlon), dpsidm(nlat, nlon), dvordl(nlat, nlon)
    REAL*8 :: dpsidld(nlat, nlon), dpsidmd(nlat, nlon), dvordld(nlat, &
&   nlon)
    REAL*8 :: dvordm(nlat, nlon), gjacob(nlat, nlon), dpsidls(nsh2)
    REAL*8 :: dvordmd(nlat, nlon), gjacobd(nlat, nlon), dpsidlsd(nsh2)
! space derivatives of potential vorticity
    vvd = DDL_D(pvor, pvord, vv)
    dvordld = SPTOGG_PP_D(vv, vvd, dvordl)
    dvordmd = SPTOGG_PD_D(pvor, pvord, dvordm)
! space derivatives of streamfunction
    dpsidlsd = DDL_D(psiloc, psilocd, dpsidls)
    dpsidld = SPTOGG_PP_D(dpsidls, dpsidlsd, dpsidl)
    dpsidmd = SPTOGG_PD_D(psiloc, psilocd, dpsidm)
    gjacobd = 0.0_8
! jacobian term
    DO j=1,nlon
      DO i=1,nlat
        gjacobd(i, j) = dpsidmd(i, j)*dvordl(i, j) + dpsidm(i, j)*&
&         dvordld(i, j) - dpsidld(i, j)*dvordm(i, j) - dpsidl(i, j)*&
&         dvordmd(i, j)
        gjacob(i, j) = dpsidm(i, j)*dvordl(i, j) - dpsidl(i, j)*dvordm(i&
&         , j)
      END DO
    END DO
    sjacobd = GGTOSP_D(gjacob, gjacobd, sjacob)
! planetary vorticity advection
    DO k=1,nsh2
      sjacobd(k) = sjacobd(k) - dpsidlsd(k)
      sjacob(k) = sjacob(k) - dpsidls(k)
    END DO
    RETURN
  END FUNCTION JACOB_D
!----------------------------------------------------------------------
! advection of potential vorticity
! input psiloc,  pvor
! output sjacob
!----------------------------------------------------------------------
  FUNCTION JACOB(psiloc, pvor) RESULT (SJACOB)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: psiloc(nsh2)
    REAL*8, INTENT(IN) :: pvor(nsh2)
    REAL*8 :: sjacob(nsh2)
    INTEGER :: i, j, k
    REAL*8 :: vv(nsh2)
    REAL*8 :: dpsidl(nlat, nlon), dpsidm(nlat, nlon), dvordl(nlat, nlon)
    REAL*8 :: dvordm(nlat, nlon), gjacob(nlat, nlon), dpsidls(nsh2)
! space derivatives of potential vorticity
    vv = DDL(pvor)
    dvordl = SPTOGG_PP(vv)
    dvordm = SPTOGG_PD(pvor)
! space derivatives of streamfunction
    dpsidls = DDL(psiloc)
    dpsidl = SPTOGG_PP(dpsidls)
    dpsidm = SPTOGG_PD(psiloc)
! jacobian term
    DO j=1,nlon
      DO i=1,nlat
        gjacob(i, j) = dpsidm(i, j)*dvordl(i, j) - dpsidl(i, j)*dvordm(i&
&         , j)
      END DO
    END DO
    sjacob = GGTOSP(gjacob)
! planetary vorticity advection
    DO k=1,nsh2
      sjacob(k) = sjacob(k) - dpsidls(k)
    END DO
    RETURN
  END FUNCTION JACOB
!  Differentiation of jacobd in forward (tangent) mode:
!   variations   of useful results: tmp sjacob
!   with respect to varying inputs: tmp psiloc pvor
!----------------------------------------------------------------------
! advection of potential vorticity and dissipation on gaussian grid
! input psiloc,  pvor
! output sjacob
!----------------------------------------------------------------------
  FUNCTION JACOBD_D(psiloc, psilocd, pvor, pvord, sjacob) RESULT (&
& SJACOBD)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: psiloc(nsh2)
    REAL*8, INTENT(IN) :: psilocd(nsh2)
    REAL*8, INTENT(IN) :: pvor(nsh2)
    REAL*8, INTENT(IN) :: pvord(nsh2)
    REAL*8 :: sjacob(nsh2)
    REAL*8 :: sjacobd(nsh2)
    INTEGER :: i, j, k
    REAL*8 :: dpsidl(nlat, nlon), dpsidm(nlat, nlon), dvordl(nlat, nlon)
    REAL*8 :: dpsidld(nlat, nlon), dpsidmd(nlat, nlon), dvordld(nlat, &
&   nlon)
    REAL*8 :: dvordm(nlat, nlon), gjacob(nlat, nlon), vv(nsh2)
    REAL*8 :: dvordmd(nlat, nlon), gjacobd(nlat, nlon), vvd(nsh2)
    REAL*8 :: azeta(nlat, nlon), dpsidls(nsh2)
    REAL*8 :: azetad(nlat, nlon), dpsidlsd(nsh2)
! space derivatives of potential vorticity 
    vvd = DDL_D(pvor, pvord, vv)
    dvordld = SPTOGG_PP_D(vv, vvd, dvordl)
    dvordmd = SPTOGG_PD_D(pvor, pvord, dvordm)
! space derivatives of streamfunction
    dpsidlsd = DDL_D(psiloc, psilocd, dpsidls)
    dpsidld = SPTOGG_PP_D(dpsidls, dpsidlsd, dpsidl)
    dpsidmd = SPTOGG_PD_D(psiloc, psilocd, dpsidm)
    gjacobd = 0.0_8
! jacobian term + orographic forcing
    DO j=1,nlon
      DO i=1,nlat
        gjacobd(i, j) = dpsidmd(i, j)*(dvordl(i, j)+sinfi(i)*dorodl(i, j&
&         )) + dpsidm(i, j)*dvordld(i, j) - dpsidld(i, j)*(dvordm(i, j)+&
&         sinfi(i)*dorodm(i, j)) - dpsidl(i, j)*dvordmd(i, j)
        gjacob(i, j) = dpsidm(i, j)*(dvordl(i, j)+sinfi(i)*dorodl(i, j))&
&         - dpsidl(i, j)*(dvordm(i, j)+sinfi(i)*dorodm(i, j))
      END DO
    END DO
! dissipation 
    IF (lgdiss) THEN
!   spatially varying dissipation 
      DO k=1,nsh2
        vvd(k) = diss(k, 2)*psilocd(k)
        vv(k) = diss(k, 2)*psiloc(k)
      END DO
      azetad = SPTOGG_PP_D(vv, vvd, azeta)
      DO j=1,nlon
        DO i=1,nlat
          gjacobd(i, j) = gjacobd(i, j) - ddisdy(i, j)*dpsidmd(i, j) - &
&           ddisdx(i, j)*dpsidld(i, j) + rdiss(i, j)*azetad(i, j)
          gjacob(i, j) = gjacob(i, j) - dpsidm(i, j)*ddisdy(i, j) - &
&           dpsidl(i, j)*ddisdx(i, j) + rdiss(i, j)*azeta(i, j)
        END DO
      END DO
      sjacobd = GGTOSP_D(gjacob, gjacobd, sjacob)
    ELSE
!   uniform dissipation
      sjacobd = GGTOSP_D(gjacob, gjacobd, sjacob)
      DO k=1,nsh2
        sjacobd(k) = sjacobd(k) + diss(k, 2)*psilocd(k)
        sjacob(k) = sjacob(k) + diss(k, 2)*psiloc(k)
      END DO
    END IF
! planetary vorticity advection
    DO k=1,nsh2
      sjacobd(k) = sjacobd(k) - dpsidlsd(k)
      sjacob(k) = sjacob(k) - dpsidls(k)
    END DO
    RETURN
  END FUNCTION JACOBD_D
!----------------------------------------------------------------------
! advection of potential vorticity and dissipation on gaussian grid
! input psiloc,  pvor
! output sjacob
!----------------------------------------------------------------------
  FUNCTION JACOBD(psiloc, pvor) RESULT (SJACOB)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: psiloc(nsh2)
    REAL*8, INTENT(IN) :: pvor(nsh2)
    REAL*8 :: sjacob(nsh2)
    INTEGER :: i, j, k
    REAL*8 :: dpsidl(nlat, nlon), dpsidm(nlat, nlon), dvordl(nlat, nlon)
    REAL*8 :: dvordm(nlat, nlon), gjacob(nlat, nlon), vv(nsh2)
    REAL*8 :: azeta(nlat, nlon), dpsidls(nsh2)
! space derivatives of potential vorticity 
    vv = DDL(pvor)
    dvordl = SPTOGG_PP(vv)
    dvordm = SPTOGG_PD(pvor)
! space derivatives of streamfunction
    dpsidls = DDL(psiloc)
    dpsidl = SPTOGG_PP(dpsidls)
    dpsidm = SPTOGG_PD(psiloc)
! jacobian term + orographic forcing
    DO j=1,nlon
      DO i=1,nlat
        gjacob(i, j) = dpsidm(i, j)*(dvordl(i, j)+sinfi(i)*dorodl(i, j))&
&         - dpsidl(i, j)*(dvordm(i, j)+sinfi(i)*dorodm(i, j))
      END DO
    END DO
! dissipation 
    IF (lgdiss) THEN
!   spatially varying dissipation 
      DO k=1,nsh2
        vv(k) = diss(k, 2)*psiloc(k)
      END DO
      azeta = SPTOGG_PP(vv)
      DO j=1,nlon
        DO i=1,nlat
          gjacob(i, j) = gjacob(i, j) - dpsidm(i, j)*ddisdy(i, j) - &
&           dpsidl(i, j)*ddisdx(i, j) + rdiss(i, j)*azeta(i, j)
        END DO
      END DO
      sjacob = GGTOSP(gjacob)
    ELSE
!   uniform dissipation
      sjacob = GGTOSP(gjacob)
      DO k=1,nsh2
        sjacob(k) = sjacob(k) + diss(k, 2)*psiloc(k)
      END DO
    END IF
! planetary vorticity advection
    DO k=1,nsh2
      sjacob(k) = sjacob(k) - dpsidls(k)
    END DO
    RETURN
  END FUNCTION JACOBD
!  Differentiation of qtopsi in forward (tangent) mode:
!   variations   of useful results: psi psit
!   with respect to varying inputs: qprime
!-----------------------------------------------------------------------
! computation of streamfunction from potential vorticity
! input  qprime which is potential vorticity field
! output psi,  the streamfunction and psit,  the layer thicknesses
!-----------------------------------------------------------------------
  SUBROUTINE QTOPSI_D(qprime, qprimed, psi, psid, psit, psitd)
    IMPLICIT NONE
! potential vorticity
    REAL*8, INTENT(IN) :: qprime(:, :)
    REAL*8, INTENT(IN) :: qprimed(:, :)
! stream function at the nvl levels
    REAL*8, INTENT(OUT) :: psi(:, :)
    REAL*8, INTENT(OUT) :: psid(:, :)
! thickness at the ntl levels
    REAL*8, INTENT(OUT) :: psit(:, :)
    REAL*8, INTENT(OUT) :: psitd(:, :)
    INTEGER :: k
    REAL*8 :: r3
! only used as portable workspace
    REAL*8 :: ws(nsh2)
    REAL*8 :: wsd(nsh2)
    INTRINSIC SIZE
    psid = 0.0_8
    wsd = 0.0_8
    DO k=1,SIZE(psi, 1)
      wsd(k) = qprimed(k, 1) + qprimed(k, 3)
      ws(k) = qprime(k, 1) + qprime(k, 3)
      psid(k, 1) = rinhel(k, 1)*(wsd(k)+qprimed(k, 2))
      psi(k, 1) = rinhel(k, 1)*(ws(k)+qprime(k, 2))
      psid(k, 2) = wsd(k) - 2.d0*qprimed(k, 2)
      psi(k, 2) = ws(k) - 2.d0*qprime(k, 2)
      psid(k, 3) = qprimed(k, 1) - qprimed(k, 3)
      psi(k, 3) = qprime(k, 1) - qprime(k, 3)
    END DO
    psitd = 0.0_8
    DO k=1,SIZE(psit, 1)
      psitd(k, 1) = rinhel(k, 2)*psid(k, 2) + rinhel(k, 3)*psid(k, 3)
      psit(k, 1) = rinhel(k, 2)*psi(k, 2) + rinhel(k, 3)*psi(k, 3)
      psitd(k, 2) = rinhel(k, 4)*psid(k, 2) + rinhel(k, 5)*psid(k, 3)
      psit(k, 2) = rinhel(k, 4)*psi(k, 2) + rinhel(k, 5)*psi(k, 3)
    END DO
    r3 = 1./3.
    DO k=1,SIZE(psi, 1)
      psid(k, 2) = r3*(psid(k, 1)-psitd(k, 1)+psitd(k, 2))
      psi(k, 2) = r3*(psi(k, 1)-psit(k, 1)+psit(k, 2))
      psid(k, 1) = psid(k, 2) + psitd(k, 1)
      psi(k, 1) = psi(k, 2) + psit(k, 1)
      psid(k, 3) = psid(k, 2) - psitd(k, 2)
      psi(k, 3) = psi(k, 2) - psit(k, 2)
    END DO
    RETURN
  END SUBROUTINE QTOPSI_D
!-----------------------------------------------------------------------
! computation of streamfunction from potential vorticity
! input  qprime which is potential vorticity field
! output psi,  the streamfunction and psit,  the layer thicknesses
!-----------------------------------------------------------------------
  SUBROUTINE QTOPSI(qprime, psi, psit)
    IMPLICIT NONE
! potential vorticity
    REAL*8, INTENT(IN) :: qprime(:, :)
! stream function at the nvl levels
    REAL*8, INTENT(OUT) :: psi(:, :)
! thickness at the ntl levels
    REAL*8, INTENT(OUT) :: psit(:, :)
    INTEGER :: k
    REAL*8 :: r3
! only used as portable workspace
    REAL*8 :: ws(nsh2)
    INTRINSIC SIZE
    DO k=1,SIZE(psi, 1)
      ws(k) = qprime(k, 1) + qprime(k, 3)
      psi(k, 1) = rinhel(k, 1)*(ws(k)+qprime(k, 2))
      psi(k, 2) = ws(k) - 2.d0*qprime(k, 2)
      psi(k, 3) = qprime(k, 1) - qprime(k, 3)
    END DO
    DO k=1,SIZE(psit, 1)
      psit(k, 1) = rinhel(k, 2)*psi(k, 2) + rinhel(k, 3)*psi(k, 3)
      psit(k, 2) = rinhel(k, 4)*psi(k, 2) + rinhel(k, 5)*psi(k, 3)
    END DO
    r3 = 1./3.
    DO k=1,SIZE(psi, 1)
      psi(k, 2) = r3*(psi(k, 1)-psit(k, 1)+psit(k, 2))
      psi(k, 1) = psi(k, 2) + psit(k, 1)
      psi(k, 3) = psi(k, 2) - psit(k, 2)
    END DO
    RETURN
  END SUBROUTINE QTOPSI
!-----------------------------------------------------------------------
! computation of potential vorticity from stream function
! input psi streamfunction
! output qprime,  the potential vorticity and psit,  the layer thick.
!-----------------------------------------------------------------------
  SUBROUTINE PSITOQ(psi, psit, qprime)
    IMPLICIT NONE
! stream function at the nvl levels
    REAL*8, INTENT(IN) :: psi(:, :)
! thickness at the ntl levels
    REAL*8, INTENT(OUT) :: psit(:, :)
! potential vorticity
    REAL*8, INTENT(OUT) :: qprime(:, :)
    INTEGER :: k
    INTRINSIC SIZE
    DO k=1,SIZE(psit, 1)
      psit(k, 1) = psi(k, 1) - psi(k, 2)
      psit(k, 2) = psi(k, 2) - psi(k, 3)
      qprime(k, 1) = rinhel(k, 0)*psi(k, 1) - rl1*psit(k, 1)
      qprime(k, 2) = rinhel(k, 0)*psi(k, 2) + rl1*psit(k, 1) - rl2*psit(&
&       k, 2)
      qprime(k, 3) = rinhel(k, 0)*psi(k, 3) + rl2*psit(k, 2)
    END DO
    RETURN
  END SUBROUTINE PSITOQ
!  Differentiation of fmtofs in forward (tangent) mode:
!   variations   of useful results: z
!   with respect to varying inputs: y
!-----------------------------------------------------------------------
! transforms francos format to the french format for global fields
! input  y spectral coefficients in francos format
! output z spectral coefficients in french format
! fm format:
! k       m  n
! 1       0  0
! 2       0  1
! 3       0  2
! :       :  :
! nm+1    0  nm
! nm+2    1  1 --> real part
! nm+3    1  2 --> real part
! :       :  :
! nm+nm+1 1  nm --> real part
! :       :  :
! :       nm nm --> real part
!  repeat for imaginary part
!  disadvantage: 0 0 mode and imaginary parts of m = 0 modes are obsolete
! fs format stores all m for every n first and has no obsolete indices
! 
! k       m  n
! 1       0  1
! 2       1  1 --> real part
! 3       1  1 --> imaginary part: k = 1-3 is T1 truncation
! 4       0  2
! 5       1  2 --> real part
! 6       1  2 --> imaginary part
! 7       2  2 --> real part
! 8       2  2 --> imaginary part: k = 1-8 is T2 truncation
! etcetera
!-----------------------------------------------------------------------
  FUNCTION FMTOFS_D(y, yd, z) RESULT (ZD)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    REAL*8, INTENT(IN) :: yd(:, :)
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: z
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: zd
    INTEGER :: m, n, k, indx, l
    INTRINSIC SIZE
    INTRINSIC MAX
    INTEGER :: max1
    zd = 0.0_8
    DO l=1,SIZE(y, 2)
      k = 1
      DO m=0,nm
        IF (m .LT. 1) THEN
          max1 = 1
        ELSE
          max1 = m
        END IF
        DO n=max1,nm
          k = k + 1
          IF (m .EQ. 0) THEN
            indx = n**2
          ELSE
            indx = n**2 + 2*m - 1
          END IF
          zd(indx, l) = yd(k, l)
          z(indx, l) = y(k, l)
          IF (m .NE. 0) THEN
            zd(indx+1, l) = yd(k+nsh, l)
            z(indx+1, l) = y(k+nsh, l)
          END IF
        END DO
      END DO
    END DO
    RETURN
  END FUNCTION FMTOFS_D
!-----------------------------------------------------------------------
! transforms francos format to the french format for global fields
! input  y spectral coefficients in francos format
! output z spectral coefficients in french format
! fm format:
! k       m  n
! 1       0  0
! 2       0  1
! 3       0  2
! :       :  :
! nm+1    0  nm
! nm+2    1  1 --> real part
! nm+3    1  2 --> real part
! :       :  :
! nm+nm+1 1  nm --> real part
! :       :  :
! :       nm nm --> real part
!  repeat for imaginary part
!  disadvantage: 0 0 mode and imaginary parts of m = 0 modes are obsolete
! fs format stores all m for every n first and has no obsolete indices
! 
! k       m  n
! 1       0  1
! 2       1  1 --> real part
! 3       1  1 --> imaginary part: k = 1-3 is T1 truncation
! 4       0  2
! 5       1  2 --> real part
! 6       1  2 --> imaginary part
! 7       2  2 --> real part
! 8       2  2 --> imaginary part: k = 1-8 is T2 truncation
! etcetera
!-----------------------------------------------------------------------
  FUNCTION FMTOFS(y) RESULT (Z)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: z
    INTEGER :: m, n, k, indx, l
    INTRINSIC SIZE
    INTRINSIC MAX
    INTEGER :: max1
    DO l=1,SIZE(y, 2)
      k = 1
      DO m=0,nm
        IF (m .LT. 1) THEN
          max1 = 1
        ELSE
          max1 = m
        END IF
        DO n=max1,nm
          k = k + 1
          IF (m .EQ. 0) THEN
            indx = n**2
          ELSE
            indx = n**2 + 2*m - 1
          END IF
          z(indx, l) = y(k, l)
          IF (m .NE. 0) z(indx+1, l) = y(k+nsh, l)
        END DO
      END DO
    END DO
    RETURN
  END FUNCTION FMTOFS
!  Differentiation of fstofm in forward (tangent) mode:
!   variations   of useful results: z
!   with respect to varying inputs: y
!-----------------------------------------------------------------------
! transforms the french format to francos format for global fields
! input  y spectral coef. in french format,  ntr is truncation limit
! output z spectral coefficients in francos format
! fm format:
! k       m  n
! 1       0  0
! 2       0  1
! 3       0  2
! :       :  :
! nm+1    0  nm
! nm+2    1  1 --> real part
! nm+3    1  2 --> real part
! :       :  :
! nm+nm+1 1  nm --> real part
! :       :  :
! :       nm nm --> real part
!  repeat for imaginary part
!  disadvantage: 0 0 mode and imaginary parts of m = 0 modes are obsolete
! fs format stores all m for every n first and has no obsolete indices
! 
! k       m  n
! 1       0  1
! 2       1  1 --> real part
! 3       1  1 --> imaginary part: k = 1-3 is T1 truncation
! 4       0  2
! 5       1  2 --> real part
! 6       1  2 --> imaginary part
! 7       2  2 --> real part
! 8       2  2 --> imaginary part: k = 1-8 is T2 truncation
! etcetera
!-----------------------------------------------------------------------
  FUNCTION FSTOFM_D(y, yd, ntr, z) RESULT (ZD)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    REAL*8, INTENT(IN) :: yd(:, :)
    INTEGER, INTENT(IN) :: ntr
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: z
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: zd
    INTEGER :: m, n, k, indx, i, l
    INTRINSIC SIZE
    INTRINSIC MAX
    INTEGER :: max1
    zd = 0.0_8
    DO l=1,SIZE(y, 2)
      DO i=1,SIZE(y, 1)
        zd(i, l) = 0.0_8
        z(i, l) = 0d0
      END DO
      k = 1
      DO m=0,nm
        IF (m .LT. 1) THEN
          max1 = 1
        ELSE
          max1 = m
        END IF
        DO n=max1,nm
          k = k + 1
          IF (m .LE. ntr .AND. n .LE. ntr) THEN
            IF (m .EQ. 0) THEN
              indx = n**2
            ELSE
              indx = n**2 + 2*m - 1
            END IF
            zd(k, l) = yd(indx, l)
            z(k, l) = y(indx, l)
            IF (m .NE. 0) THEN
              zd(k+nsh, l) = yd(indx+1, l)
              z(k+nsh, l) = y(indx+1, l)
            END IF
          END IF
        END DO
      END DO
    END DO
    RETURN
  END FUNCTION FSTOFM_D
!-----------------------------------------------------------------------
! transforms the french format to francos format for global fields
! input  y spectral coef. in french format,  ntr is truncation limit
! output z spectral coefficients in francos format
! fm format:
! k       m  n
! 1       0  0
! 2       0  1
! 3       0  2
! :       :  :
! nm+1    0  nm
! nm+2    1  1 --> real part
! nm+3    1  2 --> real part
! :       :  :
! nm+nm+1 1  nm --> real part
! :       :  :
! :       nm nm --> real part
!  repeat for imaginary part
!  disadvantage: 0 0 mode and imaginary parts of m = 0 modes are obsolete
! fs format stores all m for every n first and has no obsolete indices
! 
! k       m  n
! 1       0  1
! 2       1  1 --> real part
! 3       1  1 --> imaginary part: k = 1-3 is T1 truncation
! 4       0  2
! 5       1  2 --> real part
! 6       1  2 --> imaginary part
! 7       2  2 --> real part
! 8       2  2 --> imaginary part: k = 1-8 is T2 truncation
! etcetera
!-----------------------------------------------------------------------
  FUNCTION FSTOFM(y, ntr) RESULT (Z)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    INTEGER, INTENT(IN) :: ntr
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: z
    INTEGER :: m, n, k, indx, i, l
    INTRINSIC SIZE
    INTRINSIC MAX
    INTEGER :: max1
    DO l=1,SIZE(y, 2)
      DO i=1,SIZE(y, 1)
        z(i, l) = 0d0
      END DO
      k = 1
      DO m=0,nm
        IF (m .LT. 1) THEN
          max1 = 1
        ELSE
          max1 = m
        END IF
        DO n=max1,nm
          k = k + 1
          IF (m .LE. ntr .AND. n .LE. ntr) THEN
            IF (m .EQ. 0) THEN
              indx = n**2
            ELSE
              indx = n**2 + 2*m - 1
            END IF
            z(k, l) = y(indx, l)
            IF (m .NE. 0) z(k+nsh, l) = y(indx+1, l)
          END IF
        END DO
      END DO
    END DO
    RETURN
  END FUNCTION FSTOFM
!  Differentiation of sptogg_pp in forward (tangent) mode:
!   variations   of useful results: tmp agg
!   with respect to varying inputs: tmp as
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid using
! legendre polynomials
!
! input  spectral field as
! output gaussian grid agg
!-----------------------------------------------------------------------
  FUNCTION SPTOGG_PP_D(as, asd, agg) RESULT (AGGD)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: as(nsh, 2)
    REAL*8, INTENT(IN) :: asd(nsh, 2)
! Return value
    REAL*8 :: agg(nlat, nlon)
    REAL*8 :: aggd(nlat, nlon)
    aggd = SPTOGG_D(as, asd, pp, agg)
  END FUNCTION SPTOGG_PP_D
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid using
! legendre polynomials
!
! input  spectral field as
! output gaussian grid agg
!-----------------------------------------------------------------------
  FUNCTION SPTOGG_PP(as) RESULT (AGG)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: as(nsh, 2)
! Return value
    REAL*8 :: agg(nlat, nlon)
    agg = SPTOGG(as, pp)
  END FUNCTION SPTOGG_PP
!  Differentiation of sptogg_pd in forward (tangent) mode:
!   variations   of useful results: tmp agg
!   with respect to varying inputs: tmp as
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid using
! derivatives with respect to sin(fi) .
!
! input  spectral field as
! output gaussian grid agg
!-----------------------------------------------------------------------
  FUNCTION SPTOGG_PD_D(as, asd, agg) RESULT (AGGD)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: as(nsh, 2)
    REAL*8, INTENT(IN) :: asd(nsh, 2)
! Return value
    REAL*8 :: agg(nlat, nlon)
    REAL*8 :: aggd(nlat, nlon)
    aggd = SPTOGG_D(as, asd, pd, agg)
  END FUNCTION SPTOGG_PD_D
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid using
! derivatives with respect to sin(fi) .
!
! input  spectral field as
! output gaussian grid agg
!-----------------------------------------------------------------------
  FUNCTION SPTOGG_PD(as) RESULT (AGG)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: as(nsh, 2)
! Return value
    REAL*8 :: agg(nlat, nlon)
    agg = SPTOGG(as, pd)
  END FUNCTION SPTOGG_PD
!  Differentiation of sptogg in forward (tangent) mode:
!   variations   of useful results: tmp agg
!   with respect to varying inputs: tmp as
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid
! input  spectral field as,  legendre polynomials pploc (pp or pd) 
!        where pp are legendre polynomials and pd derivatives with
!        respect to sin(fi)
! output gaussian grid agg
!-----------------------------------------------------------------------
  FUNCTION SPTOGG_D(as, asd, pploc, agg) RESULT (AGGD)
    IMPLICIT NONE
! Input 
    REAL*8, INTENT(IN) :: as(:, :)
    REAL*8, INTENT(IN) :: asd(:, :)
    REAL*8, INTENT(IN) :: pploc(:, :)
! Return value
    REAL*8 :: agg(nlat, nlon)
    REAL*8 :: aggd(nlat, nlon)
! Local data
!    real*8, allocatable :: tmp(:,:)   ! Work space used by the nag version of the fft    
    INTEGER :: i, j, k, k1, k2, m, mi, mr, nlon1
    INTEGER :: ifail
    REAL :: trigi
! inverse legendre transform
    DO j=1,nlon
      DO i=1,nlat
        agg(i, j) = 0.0d0
      END DO
    END DO
    nlon1 = nlon + 1
    k2 = nshm(0)
    aggd = 0.0_8
    DO k=1,k2
      DO i=1,nlat
        aggd(i, 1) = aggd(i, 1) + pploc(i, k)*asd(k, 1)
        agg(i, 1) = agg(i, 1) + as(k, 1)*pploc(i, k)
      END DO
    END DO
    DO m=1,nm
      mr = m + 1
      mi = nlon1 - m
      k1 = k2 + 1
      k2 = k2 + nshm(m)
      DO k=k1,k2
        DO i=1,nlat
          aggd(i, mr) = aggd(i, mr) + pploc(i, k)*asd(k, 1)
          agg(i, mr) = agg(i, mr) + as(k, 1)*pploc(i, k)
        END DO
        DO i=1,nlat
          aggd(i, mi) = aggd(i, mi) - pploc(i, k)*asd(k, 2)
          agg(i, mi) = agg(i, mi) - as(k, 2)*pploc(i, k)
        END DO
      END DO
    END DO
! inverse fourier transform
    ifail = 0
!   allocate(tmp(nlat,nlon))
    CALL C06FQF_D(nlat, nlon, agg, aggd, 'r', trigi, tmp, tmpd, ifail)
  END FUNCTION SPTOGG_D
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid
! input  spectral field as,  legendre polynomials pploc (pp or pd) 
!        where pp are legendre polynomials and pd derivatives with
!        respect to sin(fi)
! output gaussian grid agg
!-----------------------------------------------------------------------
  FUNCTION SPTOGG(as, pploc) RESULT (AGG)
    IMPLICIT NONE
! Input 
    REAL*8, INTENT(IN) :: as(:, :)
    REAL*8, INTENT(IN) :: pploc(:, :)
! Return value
    REAL*8 :: agg(nlat, nlon)
! Local data
!    real*8, allocatable :: tmp(:,:)   ! Work space used by the nag version of the fft    
    INTEGER :: i, j, k, k1, k2, m, mi, mr, nlon1
    INTEGER :: ifail
    REAL :: trigi
! inverse legendre transform
    DO j=1,nlon
      DO i=1,nlat
        agg(i, j) = 0.0d0
      END DO
    END DO
    nlon1 = nlon + 1
    k2 = nshm(0)
    DO k=1,k2
      DO i=1,nlat
        agg(i, 1) = agg(i, 1) + as(k, 1)*pploc(i, k)
      END DO
    END DO
    DO m=1,nm
      mr = m + 1
      mi = nlon1 - m
      k1 = k2 + 1
      k2 = k2 + nshm(m)
      DO k=k1,k2
        DO i=1,nlat
          agg(i, mr) = agg(i, mr) + as(k, 1)*pploc(i, k)
        END DO
        DO i=1,nlat
          agg(i, mi) = agg(i, mi) - as(k, 2)*pploc(i, k)
        END DO
      END DO
    END DO
! inverse fourier transform
    ifail = 0
!   allocate(tmp(nlat,nlon))
    CALL C06FQF(nlat, nlon, agg, 'r', trigi, tmp, ifail)
  END FUNCTION SPTOGG
!  Differentiation of ggtosp in forward (tangent) mode:
!   variations   of useful results: tmp as
!   with respect to varying inputs: tmp agg
!-----------------------------------------------------------------------
! conversion from gaussian grid (agg) to spectral coefficients (as)
! input gaussian grid field agg
! output as contains spectral coefficients
!-----------------------------------------------------------------------
  FUNCTION GGTOSP_D(agg, aggd, as) RESULT (ASD)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: agg(:, :)
    REAL*8, INTENT(IN) :: aggd(:, :)
! Return value
    REAL*8 :: as(nsh, 2)
    REAL*8 :: asd(nsh, 2)
! Local data
    INTEGER :: i, k, k1, k2, m, mi, mr, nlon1
    INTEGER :: ifail
    REAL :: trigd
! Make a local copy of agg so it is not destroyed by c06fpf
!    allocate(agg_copy(nlat,nlon))
    agg_copyd(:, :) = aggd(:, :)
    agg_copy(:, :) = agg(:, :)
! fourier transform
    ifail = 0
!    allocate(tmp(nlat,nlon))
    CALL C06FPF_D(nlat, nlon, agg_copy, agg_copyd, 'r', trigd, tmp, tmpd&
&           , ifail)
! legendre transform
    DO i=1,2
      DO k=1,nsh
        as(k, i) = 0.0d0
      END DO
    END DO
    nlon1 = nlon + 1
    k2 = nshm(0)
    asd = 0.0_8
    DO k=1,k2
      DO i=1,nlat
        asd(k, 1) = asd(k, 1) + pw(i, k)*agg_copyd(i, 1)
        as(k, 1) = as(k, 1) + agg_copy(i, 1)*pw(i, k)
      END DO
    END DO
    DO m=1,nm
      mr = m + 1
      mi = nlon1 - m
      k1 = k2 + 1
      k2 = k2 + nshm(m)
      DO k=k1,k2
        DO i=1,nlat
          asd(k, 1) = asd(k, 1) + pw(i, k)*agg_copyd(i, mr)
          as(k, 1) = as(k, 1) + agg_copy(i, mr)*pw(i, k)
          asd(k, 2) = asd(k, 2) + pw(i, k)*agg_copyd(i, mi)
          as(k, 2) = as(k, 2) + agg_copy(i, mi)*pw(i, k)
        END DO
      END DO
    END DO
  END FUNCTION GGTOSP_D
!-----------------------------------------------------------------------
! conversion from gaussian grid (agg) to spectral coefficients (as)
! input gaussian grid field agg
! output as contains spectral coefficients
!-----------------------------------------------------------------------
  FUNCTION GGTOSP(agg) RESULT (AS)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: agg(:, :)
! Return value
    REAL*8 :: as(nsh, 2)
! Local data
    INTEGER :: i, k, k1, k2, m, mi, mr, nlon1
    INTEGER :: ifail
    REAL :: trigd
! Make a local copy of agg so it is not destroyed by c06fpf
!    allocate(agg_copy(nlat,nlon))
    agg_copy(:, :) = agg(:, :)
! fourier transform
    ifail = 0
!    allocate(tmp(nlat,nlon))
    CALL C06FPF(nlat, nlon, agg_copy, 'r', trigd, tmp, ifail)
! legendre transform
    DO i=1,2
      DO k=1,nsh
        as(k, i) = 0.0d0
      END DO
    END DO
    nlon1 = nlon + 1
    k2 = nshm(0)
    DO k=1,k2
      DO i=1,nlat
        as(k, 1) = as(k, 1) + agg_copy(i, 1)*pw(i, k)
      END DO
    END DO
    DO m=1,nm
      mr = m + 1
      mi = nlon1 - m
      k1 = k2 + 1
      k2 = k2 + nshm(m)
      DO k=k1,k2
        DO i=1,nlat
          as(k, 1) = as(k, 1) + agg_copy(i, mr)*pw(i, k)
          as(k, 2) = as(k, 2) + agg_copy(i, mi)*pw(i, k)
        END DO
      END DO
    END DO
  END FUNCTION GGTOSP
!  Differentiation of ddl in forward (tangent) mode:
!   variations   of useful results: dadl
!   with respect to varying inputs: as
!-----------------------------------------------------------------------
! zonal derivative in spectral space
! input spectral field as
! output spectral field dadl which is as differentiated wrt lambda
!-----------------------------------------------------------------------
  FUNCTION DDL_D(as, asd, dadl) RESULT (DADLD)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: as(nsh, 2)
    REAL*8, INTENT(IN) :: asd(nsh, 2)
    REAL*8 :: dadl(nsh, 2)
    REAL*8 :: dadld(nsh, 2)
    INTEGER :: k
    dadld = 0.0_8
    DO k=1,nsh
      dadld(k, 1) = -(rm(k)*asd(k, 2))
      dadl(k, 1) = -(rm(k)*as(k, 2))
      dadld(k, 2) = rm(k)*asd(k, 1)
      dadl(k, 2) = rm(k)*as(k, 1)
    END DO
    RETURN
  END FUNCTION DDL_D
!-----------------------------------------------------------------------
! zonal derivative in spectral space
! input spectral field as
! output spectral field dadl which is as differentiated wrt lambda
!-----------------------------------------------------------------------
  FUNCTION DDL(as) RESULT (DADL)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: as(nsh, 2)
    REAL*8 :: dadl(nsh, 2)
    INTEGER :: k
    DO k=1,nsh
      dadl(k, 1) = -(rm(k)*as(k, 2))
      dadl(k, 2) = rm(k)*as(k, 1)
    END DO
    RETURN
  END FUNCTION DDL
END MODULE TAPENADE_D

