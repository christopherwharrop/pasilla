!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:54
!
MODULE TAPENADE_D
  IMPLICIT NONE
! value of pi
  REAL*8, PARAMETER :: pi=4d0*ATAN(1d0)
! The truncation is of type T(riangular) nm
  INTEGER, PARAMETER :: nm=21
! Number of longitude points of the Gaussian grid
  INTEGER, PARAMETER :: nlon=64
! Number of latitude  points of the Gaussian grid
  INTEGER, PARAMETER :: nlat=32
! Number of vorticity levels in the vertical (should be set to 3)
  INTEGER, PARAMETER :: nvl=3
! Number of temperature levels in the vertical (equal to nvl-1)
  INTEGER, PARAMETER :: ntl=2
! Half of nsh2
  INTEGER, PARAMETER :: nsh=(nm+1)*(nm+2)/2
  INTEGER, PARAMETER :: nsh2=2*nsh
! Model time step
  INTEGER, PARAMETER :: time_step=1200
  REAL*8, PARAMETER :: nsteps_per_day=24.0d0*3600.0d0/REAL(time_step)
! dimensionless time step
  REAL*8, PARAMETER :: dtt=1d0/nsteps_per_day*pi*4d0
! Model state
! Stream function at the nvl levels
  REAL*8 :: psi(nsh2, nvl)
! Thickness at the ntl levels
  REAL*8 :: psit(nsh2, ntl)
! Potential vorticity
  REAL*8 :: qprime(nsh2, nvl)
  REAL*8 :: qprimed(nsh2, nvl)
! Model Forcing
! Constant potential vorticity forcing at the nvl levels
  REAL*8, PARAMETER :: for(nsh2, nvl)
! Spectral Coefficients
! Contains numbers 22 down to 1 for index 0 to 21
  INTEGER, PARAMETER :: nshm(0:nm)
! Contains total wavenumber n of each spherical harmonic of the corresponding index
  INTEGER, PARAMETER :: ll(nsh)
  INTEGER :: lat
! Legendre polynomials defined at Gausian latitudes
  REAL*8, PARAMETER :: pp(lat, nsh)
! Mu derivative of Legendre polynomials
  REAL*8, PARAMETER :: pd(lat, nsh)
! Weights for Legendre integrals
  REAL*8, PARAMETER :: pw(lat, nsh)
! contains zonal wavenumber m of each spherical harmonic of the corresponding index for zonal derivative operator
  REAL*8, PARAMETER :: rm(:)
! Laplace/Helmholtz direct and inverse operators
! Laplace and Helmholtz operator for Q-PSI inversion
  REAL*8, PARAMETER :: rinhel(nsh2, 0:5)
! Dissipation coefficients for each spherical harmonic
  REAL*8, PARAMETER :: diss(nsh2, 2)
!   diss(k,1) : Hyperviscosity at the three levels (tdif sets timescale)
!   diss(k,2) : Ekman friction at lower level (tdis sets timescale)
! One over Rossby rad. of def. squared of 200-500 thickness
  REAL*8, PARAMETER :: rl1
! One over Rossby rad. of def. squared of 500-800 thickness
  REAL*8, PARAMETER :: rl2
! Nondimensional relaxation coefficient of 200-500 thickness
  REAL*8, PARAMETER :: relt1
! Nondimensional relaxation coefficient of 500-800 thickness
  REAL*8, PARAMETER :: relt2
! Orography
! Gauss points in radians
  REAL*8, PARAMETER :: phi(nlat)
! Sine of phi
  REAL*8, PARAMETER :: sinfi(nlat)
! Cosine of phi
  REAL*8, PARAMETER :: cosfi(nlat)
! If .true. then orography and land-sea mask dependent friction at the lower level plus Ekman friction, else only Ekman friction
  LOGICAL, PARAMETER :: lgdiss
! Derivative of orog wrt lambda
  REAL*8, PARAMETER :: dorodl(nlat, nlon)
! Derivative of orag wrt sin(fi)
  REAL*8, PARAMETER :: dorodm(nlat, nlon)
! Landsea-mask/orography dependent friction
  REAL*8, PARAMETER :: rdiss(nlat, nlon)
! Landsea-mask/orography dependent friction
  REAL*8, PARAMETER :: ddisdx(nlat, nlon)
! Landsea-mask/orography dependent friction
  REAL*8, PARAMETER :: ddisdy(nlat, nlon)
! Copy of input gaussian grid field
  REAL*8 :: agg_copy(nlat, nlon)
  REAL*8 :: agg_copyd(nlat, nlon)
! Work space used by the nag version of the fft    
  REAL*8 :: tmp(nlat, nlon)
  REAL*8 :: tmpd(nlat, nlon)

CONTAINS
!  Differentiation of adv_nsteps in forward (tangent) mode:
!   variations   of useful results: tmp qprime
!   with respect to varying inputs: tmp qprime
!   RW status of diff variables: agg_copy:(loc) tmp:in-out qprime:in-out
!-----------------------------------------------------------------------
! performs a fourth order runge kutta time step at truncation nm
! with time step dt
! dqdt calculates the time derivative
! input  qprime at current time
! output qprime at current time plus dt
!-----------------------------------------------------------------------
  SUBROUTINE ADV_NSTEPS_D(nsteps)
    IMPLICIT NONE
    INTEGER :: nsteps
    INTEGER :: step, k, l, nvar
    REAL*8 :: dt2, dt6
    REAL*8 :: y(nsh2, nvl), dydt(nsh2, nvl), yt(nsh2, nvl)
    REAL*8 :: yd(nsh2, nvl), dydtd(nsh2, nvl), ytd(nsh2, nvl)
    REAL*8 :: dyt(nsh2, nvl), dym(nsh2, nvl)
    REAL*8 :: dytd(nsh2, nvl), dymd(nsh2, nvl)
    nvar = (nm+2)*nm
    dt2 = dtt*0.5d0
    dt6 = dtt/6d0
! Advance the model forward in time n steps
    yd = FMTOFS_D(qprime, qprimed, y)
    CALL DQDT_D(y, yd, dydt, dydtd)
    ytd = 0.0_8
    DO l=1,nvl
      DO k=1,nvar
        ytd(k, l) = yd(k, l) + dt2*dydtd(k, l)
        yt(k, l) = y(k, l) + dt2*dydt(k, l)
      END DO
    END DO
    CALL DQDT_D(yt, ytd, dyt, dytd)
    DO l=1,nvl
      DO k=1,nvar
        ytd(k, l) = yd(k, l) + dt2*dytd(k, l)
        yt(k, l) = y(k, l) + dt2*dyt(k, l)
      END DO
    END DO
    CALL DQDT_D(yt, ytd, dym, dymd)
    DO l=1,nvl
      DO k=1,nvar
        ytd(k, l) = yd(k, l) + dtt*dymd(k, l)
        yt(k, l) = y(k, l) + dtt*dym(k, l)
        dymd(k, l) = dytd(k, l) + dymd(k, l)
        dym(k, l) = dyt(k, l) + dym(k, l)
      END DO
    END DO
    CALL DQDT_D(yt, ytd, dyt, dytd)
    DO l=1,nvl
      DO k=1,nvar
        yd(k, l) = yd(k, l) + dt6*(dydtd(k, l)+dytd(k, l)+2.*dymd(k, l))
        y(k, l) = y(k, l) + dt6*(dydt(k, l)+dyt(k, l)+2.*dym(k, l))
      END DO
    END DO
    qprimed = FSTOFM_D(y, yd, nm, qprime)
! Make stream function consistent with potential vorticity
    CALL QTOPSI(qprime, psi, psit)
  END SUBROUTINE ADV_NSTEPS_D
!-----------------------------------------------------------------------
! performs a fourth order runge kutta time step at truncation nm
! with time step dt
! dqdt calculates the time derivative
! input  qprime at current time
! output qprime at current time plus dt
!-----------------------------------------------------------------------
  SUBROUTINE ADV_NSTEPS(nsteps)
    IMPLICIT NONE
    INTEGER :: nsteps
    INTEGER :: step, k, l, nvar
    REAL*8 :: dt2, dt6
    REAL*8 :: y(nsh2, nvl), dydt(nsh2, nvl), yt(nsh2, nvl)
    REAL*8 :: dyt(nsh2, nvl), dym(nsh2, nvl)
    nvar = (nm+2)*nm
    dt2 = dtt*0.5d0
    dt6 = dtt/6d0
! Advance the model forward in time n steps
    y = FMTOFS(qprime)
    CALL DQDT(y, dydt)
    DO l=1,nvl
      DO k=1,nvar
        yt(k, l) = y(k, l) + dt2*dydt(k, l)
      END DO
    END DO
    CALL DQDT(yt, dyt)
    DO l=1,nvl
      DO k=1,nvar
        yt(k, l) = y(k, l) + dt2*dyt(k, l)
      END DO
    END DO
    CALL DQDT(yt, dym)
    DO l=1,nvl
      DO k=1,nvar
        yt(k, l) = y(k, l) + dtt*dym(k, l)
        dym(k, l) = dyt(k, l) + dym(k, l)
      END DO
    END DO
    CALL DQDT(yt, dyt)
    DO l=1,nvl
      DO k=1,nvar
        y(k, l) = y(k, l) + dt6*(dydt(k, l)+dyt(k, l)+2.*dym(k, l))
      END DO
    END DO
    qprime = FSTOFM(y, nm)
! Make stream function consistent with potential vorticity
    CALL QTOPSI(qprime, psi, psit)
  END SUBROUTINE ADV_NSTEPS
!  Differentiation of dqdt in forward (tangent) mode:
!   variations   of useful results: tmp dydt
!   with respect to varying inputs: tmp y
!-----------------------------------------------------------------------
! computation of time derivative of the potential vorticity field
! input  y potential vorticity in french format
! output dydt time derivative of y in french format
! values of qprime,  psi and psit are changed
!-----------------------------------------------------------------------
  SUBROUTINE DQDT_D(y, yd, dydt, dydtd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    REAL*8, INTENT(IN) :: yd(:, :)
    REAL*8, INTENT(OUT) :: dydt(:, :)
    REAL*8, INTENT(OUT) :: dydtd(:, :)
! qprime
    REAL*8 :: local_qprime(nsh2, nvl)
    REAL*8 :: local_qprimed(nsh2, nvl)
! psi
    REAL*8 :: local_psi(nsh2, nvl)
    REAL*8 :: local_psid(nsh2, nvl)
! psit
    REAL*8 :: local_psit(nsh2, ntl)
    REAL*8 :: local_psitd(nsh2, ntl)
! time derivative of qprime
    REAL*8 :: dqprdt(nsh2, nvl)
    REAL*8 :: dqprdtd(nsh2, nvl)
    local_qprimed = FSTOFM_D(y, yd, nm, local_qprime)
    CALL QTOPSI_D(local_qprime, local_qprimed, local_psi, local_psid, &
&           local_psit, local_psitd)
! psi, psit, qprime, for, diss --> dqprdt
    dqprdtd = DDT_D(local_psi, local_psid, local_psit, local_psitd, &
&     local_qprime, local_qprimed, for, dqprdt)
    dydtd = FMTOFS_D(dqprdt, dqprdtd, dydt)
    RETURN
  END SUBROUTINE DQDT_D
!-----------------------------------------------------------------------
! computation of time derivative of the potential vorticity field
! input  y potential vorticity in french format
! output dydt time derivative of y in french format
! values of qprime,  psi and psit are changed
!-----------------------------------------------------------------------
  SUBROUTINE DQDT(y, dydt)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    REAL*8, INTENT(OUT) :: dydt(:, :)
! qprime
    REAL*8 :: local_qprime(nsh2, nvl)
! psi
    REAL*8 :: local_psi(nsh2, nvl)
! psit
    REAL*8 :: local_psit(nsh2, ntl)
! time derivative of qprime
    REAL*8 :: dqprdt(nsh2, nvl)
    local_qprime = FSTOFM(y, nm)
    CALL QTOPSI(local_qprime, local_psi, local_psit)
! psi, psit, qprime, for, diss --> dqprdt
    dqprdt = DDT(local_psi, local_psit, local_qprime, for)
    dydt = FMTOFS(dqprdt)
    RETURN
  END SUBROUTINE DQDT
!  Differentiation of ddt in forward (tangent) mode:
!   variations   of useful results: tmp dqprdt
!   with respect to varying inputs: tmp psi qprime psit
!----------------------------------------------------------------------
! ddt
!
! computation of time derivative of the potential vorticity fields
!
! input qprime,  psi,  psit
! output dqprdt
!----------------------------------------------------------------------
  FUNCTION DDT_D(psi, psid, psit, psitd, qprime, qprimed, for, dqprdt) &
& RESULT (DQPRDTD)
    IMPLICIT NONE
! stream function at the nvl levels
    REAL*8, INTENT(IN) :: psi(nsh2, nvl)
    REAL*8, INTENT(IN) :: psid(nsh2, nvl)
! thickness at the ntl levels
    REAL*8, INTENT(IN) :: psit(nsh2, ntl)
    REAL*8, INTENT(IN) :: psitd(nsh2, ntl)
! potential vorticity
    REAL*8, INTENT(IN) :: qprime(nsh2, nvl)
    REAL*8, INTENT(IN) :: qprimed(nsh2, nvl)
! constant potential vorticity forcing at the nvl levels
    REAL*8, INTENT(IN) :: for(nsh2, nvl)
    REAL*8 :: dqprdt(nsh2, nvl)
    REAL*8 :: dqprdtd(nsh2, nvl)
    INTEGER :: k, l, i, j
    REAL*8 :: dum1, dum2
    REAL*8 :: dum1d, dum2d
! advection of potential vorticity at upper level
    dqprdtd = 0.0_8
    dqprdtd(:, 1) = JACOB_D(psi(:, 1), psid(:, 1), qprime(:, 1), qprimed&
&     (:, 1), dqprdt(:, 1))
! advection of potential vorticity at middle level
    dqprdtd(:, 2) = JACOB_D(psi(:, 2), psid(:, 2), qprime(:, 2), qprimed&
&     (:, 2), dqprdt(:, 2))
! advection of potential vorticity and dissipation at lower level
    dqprdtd(:, 3) = JACOBD_D(psi(:, 3), psid(:, 3), qprime(:, 3), &
&     qprimed(:, 3), dqprdt(:, 3))
! relaxation of temperature and forcing
    DO k=1,nsh2
      dum1d = relt1*psitd(k, 1)
      dum1 = relt1*psit(k, 1)
      dum2d = relt2*psitd(k, 2)
      dum2 = relt2*psit(k, 2)
      dqprdtd(k, 1) = dqprdtd(k, 1) + dum1d
      dqprdt(k, 1) = dqprdt(k, 1) + dum1 + for(k, 1)
      dqprdtd(k, 2) = dqprdtd(k, 2) - dum1d + dum2d
      dqprdt(k, 2) = dqprdt(k, 2) - dum1 + dum2 + for(k, 2)
      dqprdtd(k, 3) = dqprdtd(k, 3) - dum2d
      dqprdt(k, 3) = dqprdt(k, 3) - dum2 + for(k, 3)
    END DO
! explicit horizontal diffusion
    DO l=1,3
      DO k=1,nsh2
        dqprdtd(k, l) = dqprdtd(k, l) + diss(k, 1)*qprimed(k, l)
        dqprdt(k, l) = dqprdt(k, l) + diss(k, 1)*qprime(k, l)
      END DO
    END DO
    RETURN
  END FUNCTION DDT_D
!----------------------------------------------------------------------
! ddt
!
! computation of time derivative of the potential vorticity fields
!
! input qprime,  psi,  psit
! output dqprdt
!----------------------------------------------------------------------
  FUNCTION DDT(psi, psit, qprime, for) RESULT (DQPRDT)
    IMPLICIT NONE
! stream function at the nvl levels
    REAL*8, INTENT(IN) :: psi(nsh2, nvl)
! thickness at the ntl levels
    REAL*8, INTENT(IN) :: psit(nsh2, ntl)
! potential vorticity
    REAL*8, INTENT(IN) :: qprime(nsh2, nvl)
! constant potential vorticity forcing at the nvl levels
    REAL*8, INTENT(IN) :: for(nsh2, nvl)
    REAL*8 :: dqprdt(nsh2, nvl)
    INTEGER :: k, l, i, j
    REAL*8 :: dum1, dum2
! advection of potential vorticity at upper level
    dqprdt(:, 1) = JACOB(psi(:, 1), qprime(:, 1))
! advection of potential vorticity at middle level
    dqprdt(:, 2) = JACOB(psi(:, 2), qprime(:, 2))
! advection of potential vorticity and dissipation at lower level
    dqprdt(:, 3) = JACOBD(psi(:, 3), qprime(:, 3))
! relaxation of temperature and forcing
    DO k=1,nsh2
      dum1 = relt1*psit(k, 1)
      dum2 = relt2*psit(k, 2)
      dqprdt(k, 1) = dqprdt(k, 1) + dum1 + for(k, 1)
      dqprdt(k, 2) = dqprdt(k, 2) - dum1 + dum2 + for(k, 2)
      dqprdt(k, 3) = dqprdt(k, 3) - dum2 + for(k, 3)
    END DO
! explicit horizontal diffusion
    DO l=1,3
      DO k=1,nsh2
        dqprdt(k, l) = dqprdt(k, l) + diss(k, 1)*qprime(k, l)
      END DO
    END DO
    RETURN
  END FUNCTION DDT
!  Differentiation of jacob in forward (tangent) mode:
!   variations   of useful results: tmp sjacob
!   with respect to varying inputs: tmp psiloc pvor
!----------------------------------------------------------------------
! advection of potential vorticity
! input psiloc,  pvor
! output sjacob
!----------------------------------------------------------------------
  FUNCTION JACOB_D(psiloc, psilocd, pvor, pvord, sjacob) RESULT (SJACOBD&
& )
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: psiloc(nsh2)
    REAL*8, INTENT(IN) :: psilocd(nsh2)
    REAL*8, INTENT(IN) :: pvor(nsh2)
    REAL*8, INTENT(IN) :: pvord(nsh2)
    REAL*8 :: sjacob(nsh2)
    REAL*8 :: sjacobd(nsh2)
    INTEGER :: i, j, k
    REAL*8 :: vv(nsh2)
    REAL*8 :: vvd(nsh2)
    REAL*8 :: dpsidl(nlat, nlon), dpsidm(nlat, nlon), dvordl(nlat, nlon)
    REAL*8 :: dpsidld(nlat, nlon), dpsidmd(nlat, nlon), dvordld(nlat, &
&   nlon)
    REAL*8 :: dvordm(nlat, nlon), gjacob(nlat, nlon), dpsidls(nsh2)
    REAL*8 :: dvordmd(nlat, nlon), gjacobd(nlat, nlon), dpsidlsd(nsh2)
! space derivatives of potential vorticity
    vvd = DDL_D(pvor, pvord, vv)
    dvordld = SPTOGG_PP_D(vv, vvd, dvordl)
    dvordmd = SPTOGG_PD_D(pvor, pvord, dvordm)
! space derivatives of streamfunction
    dpsidlsd = DDL_D(psiloc, psilocd, dpsidls)
    dpsidld = SPTOGG_PP_D(dpsidls, dpsidlsd, dpsidl)
    dpsidmd = SPTOGG_PD_D(psiloc, psilocd, dpsidm)
    gjacobd = 0.0_8
! jacobian term
    DO j=1,nlon
      DO i=1,nlat
        gjacobd(i, j) = dpsidmd(i, j)*dvordl(i, j) + dpsidm(i, j)*&
&         dvordld(i, j) - dpsidld(i, j)*dvordm(i, j) - dpsidl(i, j)*&
&         dvordmd(i, j)
        gjacob(i, j) = dpsidm(i, j)*dvordl(i, j) - dpsidl(i, j)*dvordm(i&
&         , j)
      END DO
    END DO
    sjacobd = GGTOSP_D(gjacob, gjacobd, sjacob)
! planetary vorticity advection
    DO k=1,nsh2
      sjacobd(k) = sjacobd(k) - dpsidlsd(k)
      sjacob(k) = sjacob(k) - dpsidls(k)
    END DO
    RETURN
  END FUNCTION JACOB_D
!----------------------------------------------------------------------
! advection of potential vorticity
! input psiloc,  pvor
! output sjacob
!----------------------------------------------------------------------
  FUNCTION JACOB(psiloc, pvor) RESULT (SJACOB)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: psiloc(nsh2)
    REAL*8, INTENT(IN) :: pvor(nsh2)
    REAL*8 :: sjacob(nsh2)
    INTEGER :: i, j, k
    REAL*8 :: vv(nsh2)
    REAL*8 :: dpsidl(nlat, nlon), dpsidm(nlat, nlon), dvordl(nlat, nlon)
    REAL*8 :: dvordm(nlat, nlon), gjacob(nlat, nlon), dpsidls(nsh2)
! space derivatives of potential vorticity
    vv = DDL(pvor)
    dvordl = SPTOGG_PP(vv)
    dvordm = SPTOGG_PD(pvor)
! space derivatives of streamfunction
    dpsidls = DDL(psiloc)
    dpsidl = SPTOGG_PP(dpsidls)
    dpsidm = SPTOGG_PD(psiloc)
! jacobian term
    DO j=1,nlon
      DO i=1,nlat
        gjacob(i, j) = dpsidm(i, j)*dvordl(i, j) - dpsidl(i, j)*dvordm(i&
&         , j)
      END DO
    END DO
    sjacob = GGTOSP(gjacob)
! planetary vorticity advection
    DO k=1,nsh2
      sjacob(k) = sjacob(k) - dpsidls(k)
    END DO
    RETURN
  END FUNCTION JACOB
!  Differentiation of jacobd in forward (tangent) mode:
!   variations   of useful results: tmp sjacob
!   with respect to varying inputs: tmp psiloc pvor
!----------------------------------------------------------------------
! advection of potential vorticity and dissipation on gaussian grid
! input psiloc,  pvor
! output sjacob
!----------------------------------------------------------------------
  FUNCTION JACOBD_D(psiloc, psilocd, pvor, pvord, sjacob) RESULT (&
& SJACOBD)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: psiloc(nsh2)
    REAL*8, INTENT(IN) :: psilocd(nsh2)
    REAL*8, INTENT(IN) :: pvor(nsh2)
    REAL*8, INTENT(IN) :: pvord(nsh2)
    REAL*8 :: sjacob(nsh2)
    REAL*8 :: sjacobd(nsh2)
    INTEGER :: i, j, k
    REAL*8 :: dpsidl(nlat, nlon), dpsidm(nlat, nlon), dvordl(nlat, nlon)
    REAL*8 :: dpsidld(nlat, nlon), dpsidmd(nlat, nlon), dvordld(nlat, &
&   nlon)
    REAL*8 :: dvordm(nlat, nlon), gjacob(nlat, nlon), vv(nsh2)
    REAL*8 :: dvordmd(nlat, nlon), gjacobd(nlat, nlon), vvd(nsh2)
    REAL*8 :: azeta(nlat, nlon), dpsidls(nsh2)
    REAL*8 :: azetad(nlat, nlon), dpsidlsd(nsh2)
! space derivatives of potential vorticity 
    vvd = DDL_D(pvor, pvord, vv)
    dvordld = SPTOGG_PP_D(vv, vvd, dvordl)
    dvordmd = SPTOGG_PD_D(pvor, pvord, dvordm)
! space derivatives of streamfunction
    dpsidlsd = DDL_D(psiloc, psilocd, dpsidls)
    dpsidld = SPTOGG_PP_D(dpsidls, dpsidlsd, dpsidl)
    dpsidmd = SPTOGG_PD_D(psiloc, psilocd, dpsidm)
    gjacobd = 0.0_8
! jacobian term + orographic forcing
    DO j=1,nlon
      DO i=1,nlat
        gjacobd(i, j) = dpsidmd(i, j)*(dvordl(i, j)+sinfi(i)*dorodl(i, j&
&         )) + dpsidm(i, j)*dvordld(i, j) - dpsidld(i, j)*(dvordm(i, j)+&
&         sinfi(i)*dorodm(i, j)) - dpsidl(i, j)*dvordmd(i, j)
        gjacob(i, j) = dpsidm(i, j)*(dvordl(i, j)+sinfi(i)*dorodl(i, j))&
&         - dpsidl(i, j)*(dvordm(i, j)+sinfi(i)*dorodm(i, j))
      END DO
    END DO
! dissipation 
    IF (lgdiss) THEN
!   spatially varying dissipation 
      DO k=1,nsh2
        vvd(k) = diss(k, 2)*psilocd(k)
        vv(k) = diss(k, 2)*psiloc(k)
      END DO
      azetad = SPTOGG_PP_D(vv, vvd, azeta)
      DO j=1,nlon
        DO i=1,nlat
          gjacobd(i, j) = gjacobd(i, j) - ddisdy(i, j)*dpsidmd(i, j) - &
&           ddisdx(i, j)*dpsidld(i, j) + rdiss(i, j)*azetad(i, j)
          gjacob(i, j) = gjacob(i, j) - dpsidm(i, j)*ddisdy(i, j) - &
&           dpsidl(i, j)*ddisdx(i, j) + rdiss(i, j)*azeta(i, j)
        END DO
      END DO
      sjacobd = GGTOSP_D(gjacob, gjacobd, sjacob)
    ELSE
!   uniform dissipation
      sjacobd = GGTOSP_D(gjacob, gjacobd, sjacob)
      DO k=1,nsh2
        sjacobd(k) = sjacobd(k) + diss(k, 2)*psilocd(k)
        sjacob(k) = sjacob(k) + diss(k, 2)*psiloc(k)
      END DO
    END IF
! planetary vorticity advection
    DO k=1,nsh2
      sjacobd(k) = sjacobd(k) - dpsidlsd(k)
      sjacob(k) = sjacob(k) - dpsidls(k)
    END DO
    RETURN
  END FUNCTION JACOBD_D
!----------------------------------------------------------------------
! advection of potential vorticity and dissipation on gaussian grid
! input psiloc,  pvor
! output sjacob
!----------------------------------------------------------------------
  FUNCTION JACOBD(psiloc, pvor) RESULT (SJACOB)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: psiloc(nsh2)
    REAL*8, INTENT(IN) :: pvor(nsh2)
    REAL*8 :: sjacob(nsh2)
    INTEGER :: i, j, k
    REAL*8 :: dpsidl(nlat, nlon), dpsidm(nlat, nlon), dvordl(nlat, nlon)
    REAL*8 :: dvordm(nlat, nlon), gjacob(nlat, nlon), vv(nsh2)
    REAL*8 :: azeta(nlat, nlon), dpsidls(nsh2)
! space derivatives of potential vorticity 
    vv = DDL(pvor)
    dvordl = SPTOGG_PP(vv)
    dvordm = SPTOGG_PD(pvor)
! space derivatives of streamfunction
    dpsidls = DDL(psiloc)
    dpsidl = SPTOGG_PP(dpsidls)
    dpsidm = SPTOGG_PD(psiloc)
! jacobian term + orographic forcing
    DO j=1,nlon
      DO i=1,nlat
        gjacob(i, j) = dpsidm(i, j)*(dvordl(i, j)+sinfi(i)*dorodl(i, j))&
&         - dpsidl(i, j)*(dvordm(i, j)+sinfi(i)*dorodm(i, j))
      END DO
    END DO
! dissipation 
    IF (lgdiss) THEN
!   spatially varying dissipation 
      DO k=1,nsh2
        vv(k) = diss(k, 2)*psiloc(k)
      END DO
      azeta = SPTOGG_PP(vv)
      DO j=1,nlon
        DO i=1,nlat
          gjacob(i, j) = gjacob(i, j) - dpsidm(i, j)*ddisdy(i, j) - &
&           dpsidl(i, j)*ddisdx(i, j) + rdiss(i, j)*azeta(i, j)
        END DO
      END DO
      sjacob = GGTOSP(gjacob)
    ELSE
!   uniform dissipation
      sjacob = GGTOSP(gjacob)
      DO k=1,nsh2
        sjacob(k) = sjacob(k) + diss(k, 2)*psiloc(k)
      END DO
    END IF
! planetary vorticity advection
    DO k=1,nsh2
      sjacob(k) = sjacob(k) - dpsidls(k)
    END DO
    RETURN
  END FUNCTION JACOBD
!  Differentiation of qtopsi in forward (tangent) mode:
!   variations   of useful results: psi psit
!   with respect to varying inputs: qprime
!-----------------------------------------------------------------------
! computation of streamfunction from potential vorticity
! input  qprime which is potential vorticity field
! output psi,  the streamfunction and psit,  the layer thicknesses
!-----------------------------------------------------------------------
  SUBROUTINE QTOPSI_D(qprime, qprimed, psi, psid, psit, psitd)
    IMPLICIT NONE
! potential vorticity
    REAL*8, INTENT(IN) :: qprime(:, :)
    REAL*8, INTENT(IN) :: qprimed(:, :)
! stream function at the nvl levels
    REAL*8, INTENT(OUT) :: psi(:, :)
    REAL*8, INTENT(OUT) :: psid(:, :)
! thickness at the ntl levels
    REAL*8, INTENT(OUT) :: psit(:, :)
    REAL*8, INTENT(OUT) :: psitd(:, :)
    INTEGER :: k
    REAL*8 :: r3
! only used as portable workspace
    REAL*8 :: ws(nsh2)
    REAL*8 :: wsd(nsh2)
    INTRINSIC SIZE
    psid = 0.0_8
    wsd = 0.0_8
    DO k=1,SIZE(psi, 1)
      wsd(k) = qprimed(k, 1) + qprimed(k, 3)
      ws(k) = qprime(k, 1) + qprime(k, 3)
      psid(k, 1) = rinhel(k, 1)*(wsd(k)+qprimed(k, 2))
      psi(k, 1) = rinhel(k, 1)*(ws(k)+qprime(k, 2))
      psid(k, 2) = wsd(k) - 2.d0*qprimed(k, 2)
      psi(k, 2) = ws(k) - 2.d0*qprime(k, 2)
      psid(k, 3) = qprimed(k, 1) - qprimed(k, 3)
      psi(k, 3) = qprime(k, 1) - qprime(k, 3)
    END DO
    psitd = 0.0_8
    DO k=1,SIZE(psit, 1)
      psitd(k, 1) = rinhel(k, 2)*psid(k, 2) + rinhel(k, 3)*psid(k, 3)
      psit(k, 1) = rinhel(k, 2)*psi(k, 2) + rinhel(k, 3)*psi(k, 3)
      psitd(k, 2) = rinhel(k, 4)*psid(k, 2) + rinhel(k, 5)*psid(k, 3)
      psit(k, 2) = rinhel(k, 4)*psi(k, 2) + rinhel(k, 5)*psi(k, 3)
    END DO
    r3 = 1./3.
    DO k=1,SIZE(psi, 1)
      psid(k, 2) = r3*(psid(k, 1)-psitd(k, 1)+psitd(k, 2))
      psi(k, 2) = r3*(psi(k, 1)-psit(k, 1)+psit(k, 2))
      psid(k, 1) = psid(k, 2) + psitd(k, 1)
      psi(k, 1) = psi(k, 2) + psit(k, 1)
      psid(k, 3) = psid(k, 2) - psitd(k, 2)
      psi(k, 3) = psi(k, 2) - psit(k, 2)
    END DO
    RETURN
  END SUBROUTINE QTOPSI_D
!-----------------------------------------------------------------------
! computation of streamfunction from potential vorticity
! input  qprime which is potential vorticity field
! output psi,  the streamfunction and psit,  the layer thicknesses
!-----------------------------------------------------------------------
  SUBROUTINE QTOPSI(qprime, psi, psit)
    IMPLICIT NONE
! potential vorticity
    REAL*8, INTENT(IN) :: qprime(:, :)
! stream function at the nvl levels
    REAL*8, INTENT(OUT) :: psi(:, :)
! thickness at the ntl levels
    REAL*8, INTENT(OUT) :: psit(:, :)
    INTEGER :: k
    REAL*8 :: r3
! only used as portable workspace
    REAL*8 :: ws(nsh2)
    INTRINSIC SIZE
    DO k=1,SIZE(psi, 1)
      ws(k) = qprime(k, 1) + qprime(k, 3)
      psi(k, 1) = rinhel(k, 1)*(ws(k)+qprime(k, 2))
      psi(k, 2) = ws(k) - 2.d0*qprime(k, 2)
      psi(k, 3) = qprime(k, 1) - qprime(k, 3)
    END DO
    DO k=1,SIZE(psit, 1)
      psit(k, 1) = rinhel(k, 2)*psi(k, 2) + rinhel(k, 3)*psi(k, 3)
      psit(k, 2) = rinhel(k, 4)*psi(k, 2) + rinhel(k, 5)*psi(k, 3)
    END DO
    r3 = 1./3.
    DO k=1,SIZE(psi, 1)
      psi(k, 2) = r3*(psi(k, 1)-psit(k, 1)+psit(k, 2))
      psi(k, 1) = psi(k, 2) + psit(k, 1)
      psi(k, 3) = psi(k, 2) - psit(k, 2)
    END DO
    RETURN
  END SUBROUTINE QTOPSI
!-----------------------------------------------------------------------
! computation of potential vorticity from stream function
! input psi streamfunction
! output qprime,  the potential vorticity and psit,  the layer thick.
!-----------------------------------------------------------------------
  SUBROUTINE PSITOQ(psi, psit, qprime)
    IMPLICIT NONE
! stream function at the nvl levels
    REAL*8, INTENT(IN) :: psi(:, :)
! thickness at the ntl levels
    REAL*8, INTENT(OUT) :: psit(:, :)
! potential vorticity
    REAL*8, INTENT(OUT) :: qprime(:, :)
    INTEGER :: k
    INTRINSIC SIZE
    DO k=1,SIZE(psit, 1)
      psit(k, 1) = psi(k, 1) - psi(k, 2)
      psit(k, 2) = psi(k, 2) - psi(k, 3)
      qprime(k, 1) = rinhel(k, 0)*psi(k, 1) - rl1*psit(k, 1)
      qprime(k, 2) = rinhel(k, 0)*psi(k, 2) + rl1*psit(k, 1) - rl2*psit(&
&       k, 2)
      qprime(k, 3) = rinhel(k, 0)*psi(k, 3) + rl2*psit(k, 2)
    END DO
    RETURN
  END SUBROUTINE PSITOQ
!  Differentiation of fmtofs in forward (tangent) mode:
!   variations   of useful results: z
!   with respect to varying inputs: y
!-----------------------------------------------------------------------
! transforms francos format to the french format for global fields
! input  y spectral coefficients in francos format
! output z spectral coefficients in french format
! fm format:
! k       m  n
! 1       0  0
! 2       0  1
! 3       0  2
! :       :  :
! nm+1    0  nm
! nm+2    1  1 --> real part
! nm+3    1  2 --> real part
! :       :  :
! nm+nm+1 1  nm --> real part
! :       :  :
! :       nm nm --> real part
!  repeat for imaginary part
!  disadvantage: 0 0 mode and imaginary parts of m = 0 modes are obsolete
! fs format stores all m for every n first and has no obsolete indices
! 
! k       m  n
! 1       0  1
! 2       1  1 --> real part
! 3       1  1 --> imaginary part: k = 1-3 is T1 truncation
! 4       0  2
! 5       1  2 --> real part
! 6       1  2 --> imaginary part
! 7       2  2 --> real part
! 8       2  2 --> imaginary part: k = 1-8 is T2 truncation
! etcetera
!-----------------------------------------------------------------------
  FUNCTION FMTOFS_D(y, yd, z) RESULT (ZD)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    REAL*8, INTENT(IN) :: yd(:, :)
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: z
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: zd
    INTEGER :: m, n, k, indx, l
    INTRINSIC SIZE
    INTRINSIC MAX
    INTEGER :: max1
    zd = 0.0_8
    DO l=1,SIZE(y, 2)
      k = 1
      DO m=0,nm
        IF (m .LT. 1) THEN
          max1 = 1
        ELSE
          max1 = m
        END IF
        DO n=max1,nm
          k = k + 1
          IF (m .EQ. 0) THEN
            indx = n**2
          ELSE
            indx = n**2 + 2*m - 1
          END IF
          zd(indx, l) = yd(k, l)
          z(indx, l) = y(k, l)
          IF (m .NE. 0) THEN
            zd(indx+1, l) = yd(k+nsh, l)
            z(indx+1, l) = y(k+nsh, l)
          END IF
        END DO
      END DO
    END DO
    RETURN
  END FUNCTION FMTOFS_D
!-----------------------------------------------------------------------
! transforms francos format to the french format for global fields
! input  y spectral coefficients in francos format
! output z spectral coefficients in french format
! fm format:
! k       m  n
! 1       0  0
! 2       0  1
! 3       0  2
! :       :  :
! nm+1    0  nm
! nm+2    1  1 --> real part
! nm+3    1  2 --> real part
! :       :  :
! nm+nm+1 1  nm --> real part
! :       :  :
! :       nm nm --> real part
!  repeat for imaginary part
!  disadvantage: 0 0 mode and imaginary parts of m = 0 modes are obsolete
! fs format stores all m for every n first and has no obsolete indices
! 
! k       m  n
! 1       0  1
! 2       1  1 --> real part
! 3       1  1 --> imaginary part: k = 1-3 is T1 truncation
! 4       0  2
! 5       1  2 --> real part
! 6       1  2 --> imaginary part
! 7       2  2 --> real part
! 8       2  2 --> imaginary part: k = 1-8 is T2 truncation
! etcetera
!-----------------------------------------------------------------------
  FUNCTION FMTOFS(y) RESULT (Z)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: z
    INTEGER :: m, n, k, indx, l
    INTRINSIC SIZE
    INTRINSIC MAX
    INTEGER :: max1
    DO l=1,SIZE(y, 2)
      k = 1
      DO m=0,nm
        IF (m .LT. 1) THEN
          max1 = 1
        ELSE
          max1 = m
        END IF
        DO n=max1,nm
          k = k + 1
          IF (m .EQ. 0) THEN
            indx = n**2
          ELSE
            indx = n**2 + 2*m - 1
          END IF
          z(indx, l) = y(k, l)
          IF (m .NE. 0) z(indx+1, l) = y(k+nsh, l)
        END DO
      END DO
    END DO
    RETURN
  END FUNCTION FMTOFS
!  Differentiation of fstofm in forward (tangent) mode:
!   variations   of useful results: z
!   with respect to varying inputs: y
!-----------------------------------------------------------------------
! transforms the french format to francos format for global fields
! input  y spectral coef. in french format,  ntr is truncation limit
! output z spectral coefficients in francos format
! fm format:
! k       m  n
! 1       0  0
! 2       0  1
! 3       0  2
! :       :  :
! nm+1    0  nm
! nm+2    1  1 --> real part
! nm+3    1  2 --> real part
! :       :  :
! nm+nm+1 1  nm --> real part
! :       :  :
! :       nm nm --> real part
!  repeat for imaginary part
!  disadvantage: 0 0 mode and imaginary parts of m = 0 modes are obsolete
! fs format stores all m for every n first and has no obsolete indices
! 
! k       m  n
! 1       0  1
! 2       1  1 --> real part
! 3       1  1 --> imaginary part: k = 1-3 is T1 truncation
! 4       0  2
! 5       1  2 --> real part
! 6       1  2 --> imaginary part
! 7       2  2 --> real part
! 8       2  2 --> imaginary part: k = 1-8 is T2 truncation
! etcetera
!-----------------------------------------------------------------------
  FUNCTION FSTOFM_D(y, yd, ntr, z) RESULT (ZD)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    REAL*8, INTENT(IN) :: yd(:, :)
    INTEGER, INTENT(IN) :: ntr
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: z
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: zd
    INTEGER :: m, n, k, indx, i, l
    INTRINSIC SIZE
    INTRINSIC MAX
    INTEGER :: max1
    zd = 0.0_8
    DO l=1,SIZE(y, 2)
      DO i=1,SIZE(y, 1)
        zd(i, l) = 0.0_8
        z(i, l) = 0d0
      END DO
      k = 1
      DO m=0,nm
        IF (m .LT. 1) THEN
          max1 = 1
        ELSE
          max1 = m
        END IF
        DO n=max1,nm
          k = k + 1
          IF (m .LE. ntr .AND. n .LE. ntr) THEN
            IF (m .EQ. 0) THEN
              indx = n**2
            ELSE
              indx = n**2 + 2*m - 1
            END IF
            zd(k, l) = yd(indx, l)
            z(k, l) = y(indx, l)
            IF (m .NE. 0) THEN
              zd(k+nsh, l) = yd(indx+1, l)
              z(k+nsh, l) = y(indx+1, l)
            END IF
          END IF
        END DO
      END DO
    END DO
    RETURN
  END FUNCTION FSTOFM_D
!-----------------------------------------------------------------------
! transforms the french format to francos format for global fields
! input  y spectral coef. in french format,  ntr is truncation limit
! output z spectral coefficients in francos format
! fm format:
! k       m  n
! 1       0  0
! 2       0  1
! 3       0  2
! :       :  :
! nm+1    0  nm
! nm+2    1  1 --> real part
! nm+3    1  2 --> real part
! :       :  :
! nm+nm+1 1  nm --> real part
! :       :  :
! :       nm nm --> real part
!  repeat for imaginary part
!  disadvantage: 0 0 mode and imaginary parts of m = 0 modes are obsolete
! fs format stores all m for every n first and has no obsolete indices
! 
! k       m  n
! 1       0  1
! 2       1  1 --> real part
! 3       1  1 --> imaginary part: k = 1-3 is T1 truncation
! 4       0  2
! 5       1  2 --> real part
! 6       1  2 --> imaginary part
! 7       2  2 --> real part
! 8       2  2 --> imaginary part: k = 1-8 is T2 truncation
! etcetera
!-----------------------------------------------------------------------
  FUNCTION FSTOFM(y, ntr) RESULT (Z)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y(:, :)
    INTEGER, INTENT(IN) :: ntr
    REAL*8, DIMENSION(SIZE(y, 1), SIZE(y, 2)) :: z
    INTEGER :: m, n, k, indx, i, l
    INTRINSIC SIZE
    INTRINSIC MAX
    INTEGER :: max1
    DO l=1,SIZE(y, 2)
      DO i=1,SIZE(y, 1)
        z(i, l) = 0d0
      END DO
      k = 1
      DO m=0,nm
        IF (m .LT. 1) THEN
          max1 = 1
        ELSE
          max1 = m
        END IF
        DO n=max1,nm
          k = k + 1
          IF (m .LE. ntr .AND. n .LE. ntr) THEN
            IF (m .EQ. 0) THEN
              indx = n**2
            ELSE
              indx = n**2 + 2*m - 1
            END IF
            z(k, l) = y(indx, l)
            IF (m .NE. 0) z(k+nsh, l) = y(indx+1, l)
          END IF
        END DO
      END DO
    END DO
    RETURN
  END FUNCTION FSTOFM
!  Differentiation of sptogg_pp in forward (tangent) mode:
!   variations   of useful results: tmp agg
!   with respect to varying inputs: tmp as
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid using
! legendre polynomials
!
! input  spectral field as
! output gaussian grid agg
!-----------------------------------------------------------------------
  FUNCTION SPTOGG_PP_D(as, asd, agg) RESULT (AGGD)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: as(nsh, 2)
    REAL*8, INTENT(IN) :: asd(nsh, 2)
! Return value
    REAL*8 :: agg(nlat, nlon)
    REAL*8 :: aggd(nlat, nlon)
    aggd = SPTOGG_D(as, asd, pp, agg)
  END FUNCTION SPTOGG_PP_D
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid using
! legendre polynomials
!
! input  spectral field as
! output gaussian grid agg
!-----------------------------------------------------------------------
  FUNCTION SPTOGG_PP(as) RESULT (AGG)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: as(nsh, 2)
! Return value
    REAL*8 :: agg(nlat, nlon)
    agg = SPTOGG(as, pp)
  END FUNCTION SPTOGG_PP
!  Differentiation of sptogg_pd in forward (tangent) mode:
!   variations   of useful results: tmp agg
!   with respect to varying inputs: tmp as
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid using
! derivatives with respect to sin(fi) .
!
! input  spectral field as
! output gaussian grid agg
!-----------------------------------------------------------------------
  FUNCTION SPTOGG_PD_D(as, asd, agg) RESULT (AGGD)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: as(nsh, 2)
    REAL*8, INTENT(IN) :: asd(nsh, 2)
! Return value
    REAL*8 :: agg(nlat, nlon)
    REAL*8 :: aggd(nlat, nlon)
    aggd = SPTOGG_D(as, asd, pd, agg)
  END FUNCTION SPTOGG_PD_D
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid using
! derivatives with respect to sin(fi) .
!
! input  spectral field as
! output gaussian grid agg
!-----------------------------------------------------------------------
  FUNCTION SPTOGG_PD(as) RESULT (AGG)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: as(nsh, 2)
! Return value
    REAL*8 :: agg(nlat, nlon)
    agg = SPTOGG(as, pd)
  END FUNCTION SPTOGG_PD
!  Differentiation of sptogg in forward (tangent) mode:
!   variations   of useful results: tmp agg
!   with respect to varying inputs: tmp as
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid
! input  spectral field as,  legendre polynomials pploc (pp or pd) 
!        where pp are legendre polynomials and pd derivatives with
!        respect to sin(fi)
! output gaussian grid agg
!-----------------------------------------------------------------------
  FUNCTION SPTOGG_D(as, asd, pploc, agg) RESULT (AGGD)
    IMPLICIT NONE
! Input 
    REAL*8, INTENT(IN) :: as(:, :)
    REAL*8, INTENT(IN) :: asd(:, :)
    REAL*8, INTENT(IN) :: pploc(:, :)
! Return value
    REAL*8 :: agg(nlat, nlon)
    REAL*8 :: aggd(nlat, nlon)
! Local data
!    real*8, allocatable :: tmp(:,:)   ! Work space used by the nag version of the fft    
    INTEGER :: i, j, k, k1, k2, m, mi, mr, nlon1
    INTEGER :: ifail
    REAL :: trigi
! inverse legendre transform
    DO j=1,nlon
      DO i=1,nlat
        agg(i, j) = 0.0d0
      END DO
    END DO
    nlon1 = nlon + 1
    k2 = nshm(0)
    aggd = 0.0_8
    DO k=1,k2
      DO i=1,nlat
        aggd(i, 1) = aggd(i, 1) + pploc(i, k)*asd(k, 1)
        agg(i, 1) = agg(i, 1) + as(k, 1)*pploc(i, k)
      END DO
    END DO
    DO m=1,nm
      mr = m + 1
      mi = nlon1 - m
      k1 = k2 + 1
      k2 = k2 + nshm(m)
      DO k=k1,k2
        DO i=1,nlat
          aggd(i, mr) = aggd(i, mr) + pploc(i, k)*asd(k, 1)
          agg(i, mr) = agg(i, mr) + as(k, 1)*pploc(i, k)
        END DO
        DO i=1,nlat
          aggd(i, mi) = aggd(i, mi) - pploc(i, k)*asd(k, 2)
          agg(i, mi) = agg(i, mi) - as(k, 2)*pploc(i, k)
        END DO
      END DO
    END DO
! inverse fourier transform
    ifail = 0
!   allocate(tmp(nlat,nlon))
    CALL C06FQF_D(nlat, nlon, agg, aggd, 'r', trigi, tmp, tmpd, ifail)
  END FUNCTION SPTOGG_D
!-----------------------------------------------------------------------
! conversion from spectral coefficients to gaussian grid
! input  spectral field as,  legendre polynomials pploc (pp or pd) 
!        where pp are legendre polynomials and pd derivatives with
!        respect to sin(fi)
! output gaussian grid agg
!-----------------------------------------------------------------------
  FUNCTION SPTOGG(as, pploc) RESULT (AGG)
    IMPLICIT NONE
! Input 
    REAL*8, INTENT(IN) :: as(:, :)
    REAL*8, INTENT(IN) :: pploc(:, :)
! Return value
    REAL*8 :: agg(nlat, nlon)
! Local data
!    real*8, allocatable :: tmp(:,:)   ! Work space used by the nag version of the fft    
    INTEGER :: i, j, k, k1, k2, m, mi, mr, nlon1
    INTEGER :: ifail
    REAL :: trigi
! inverse legendre transform
    DO j=1,nlon
      DO i=1,nlat
        agg(i, j) = 0.0d0
      END DO
    END DO
    nlon1 = nlon + 1
    k2 = nshm(0)
    DO k=1,k2
      DO i=1,nlat
        agg(i, 1) = agg(i, 1) + as(k, 1)*pploc(i, k)
      END DO
    END DO
    DO m=1,nm
      mr = m + 1
      mi = nlon1 - m
      k1 = k2 + 1
      k2 = k2 + nshm(m)
      DO k=k1,k2
        DO i=1,nlat
          agg(i, mr) = agg(i, mr) + as(k, 1)*pploc(i, k)
        END DO
        DO i=1,nlat
          agg(i, mi) = agg(i, mi) - as(k, 2)*pploc(i, k)
        END DO
      END DO
    END DO
! inverse fourier transform
    ifail = 0
!   allocate(tmp(nlat,nlon))
    CALL C06FQF(nlat, nlon, agg, 'r', trigi, tmp, ifail)
  END FUNCTION SPTOGG
!  Differentiation of ggtosp in forward (tangent) mode:
!   variations   of useful results: tmp as
!   with respect to varying inputs: tmp agg
!-----------------------------------------------------------------------
! conversion from gaussian grid (agg) to spectral coefficients (as)
! input gaussian grid field agg
! output as contains spectral coefficients
!-----------------------------------------------------------------------
  FUNCTION GGTOSP_D(agg, aggd, as) RESULT (ASD)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: agg(:, :)
    REAL*8, INTENT(IN) :: aggd(:, :)
! Return value
    REAL*8 :: as(nsh, 2)
    REAL*8 :: asd(nsh, 2)
! Local data
    INTEGER :: i, k, k1, k2, m, mi, mr, nlon1
    INTEGER :: ifail
    REAL :: trigd
! Make a local copy of agg so it is not destroyed by c06fpf
!    allocate(agg_copy(nlat,nlon))
    agg_copyd(:, :) = aggd(:, :)
    agg_copy(:, :) = agg(:, :)
! fourier transform
    ifail = 0
!    allocate(tmp(nlat,nlon))
    CALL C06FPF_D(nlat, nlon, agg_copy, agg_copyd, 'r', trigd, tmp, tmpd&
&           , ifail)
! legendre transform
    DO i=1,2
      DO k=1,nsh
        as(k, i) = 0.0d0
      END DO
    END DO
    nlon1 = nlon + 1
    k2 = nshm(0)
    asd = 0.0_8
    DO k=1,k2
      DO i=1,nlat
        asd(k, 1) = asd(k, 1) + pw(i, k)*agg_copyd(i, 1)
        as(k, 1) = as(k, 1) + agg_copy(i, 1)*pw(i, k)
      END DO
    END DO
    DO m=1,nm
      mr = m + 1
      mi = nlon1 - m
      k1 = k2 + 1
      k2 = k2 + nshm(m)
      DO k=k1,k2
        DO i=1,nlat
          asd(k, 1) = asd(k, 1) + pw(i, k)*agg_copyd(i, mr)
          as(k, 1) = as(k, 1) + agg_copy(i, mr)*pw(i, k)
          asd(k, 2) = asd(k, 2) + pw(i, k)*agg_copyd(i, mi)
          as(k, 2) = as(k, 2) + agg_copy(i, mi)*pw(i, k)
        END DO
      END DO
    END DO
  END FUNCTION GGTOSP_D
!-----------------------------------------------------------------------
! conversion from gaussian grid (agg) to spectral coefficients (as)
! input gaussian grid field agg
! output as contains spectral coefficients
!-----------------------------------------------------------------------
  FUNCTION GGTOSP(agg) RESULT (AS)
    IMPLICIT NONE
! Input
    REAL*8, INTENT(IN) :: agg(:, :)
! Return value
    REAL*8 :: as(nsh, 2)
! Local data
    INTEGER :: i, k, k1, k2, m, mi, mr, nlon1
    INTEGER :: ifail
    REAL :: trigd
! Make a local copy of agg so it is not destroyed by c06fpf
!    allocate(agg_copy(nlat,nlon))
    agg_copy(:, :) = agg(:, :)
! fourier transform
    ifail = 0
!    allocate(tmp(nlat,nlon))
    CALL C06FPF(nlat, nlon, agg_copy, 'r', trigd, tmp, ifail)
! legendre transform
    DO i=1,2
      DO k=1,nsh
        as(k, i) = 0.0d0
      END DO
    END DO
    nlon1 = nlon + 1
    k2 = nshm(0)
    DO k=1,k2
      DO i=1,nlat
        as(k, 1) = as(k, 1) + agg_copy(i, 1)*pw(i, k)
      END DO
    END DO
    DO m=1,nm
      mr = m + 1
      mi = nlon1 - m
      k1 = k2 + 1
      k2 = k2 + nshm(m)
      DO k=k1,k2
        DO i=1,nlat
          as(k, 1) = as(k, 1) + agg_copy(i, mr)*pw(i, k)
          as(k, 2) = as(k, 2) + agg_copy(i, mi)*pw(i, k)
        END DO
      END DO
    END DO
  END FUNCTION GGTOSP
!  Differentiation of ddl in forward (tangent) mode:
!   variations   of useful results: dadl
!   with respect to varying inputs: as
!-----------------------------------------------------------------------
! zonal derivative in spectral space
! input spectral field as
! output spectral field dadl which is as differentiated wrt lambda
!-----------------------------------------------------------------------
  FUNCTION DDL_D(as, asd, dadl) RESULT (DADLD)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: as(nsh, 2)
    REAL*8, INTENT(IN) :: asd(nsh, 2)
    REAL*8 :: dadl(nsh, 2)
    REAL*8 :: dadld(nsh, 2)
    INTEGER :: k
    dadld = 0.0_8
    DO k=1,nsh
      dadld(k, 1) = -(rm(k)*asd(k, 2))
      dadl(k, 1) = -(rm(k)*as(k, 2))
      dadld(k, 2) = rm(k)*asd(k, 1)
      dadl(k, 2) = rm(k)*as(k, 1)
    END DO
    RETURN
  END FUNCTION DDL_D
!-----------------------------------------------------------------------
! zonal derivative in spectral space
! input spectral field as
! output spectral field dadl which is as differentiated wrt lambda
!-----------------------------------------------------------------------
  FUNCTION DDL(as) RESULT (DADL)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: as(nsh, 2)
    REAL*8 :: dadl(nsh, 2)
    INTEGER :: k
    DO k=1,nsh
      dadl(k, 1) = -(rm(k)*as(k, 2))
      dadl(k, 2) = rm(k)*as(k, 1)
    END DO
    RETURN
  END FUNCTION DDL
END MODULE TAPENADE_D
